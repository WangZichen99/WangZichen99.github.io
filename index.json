[{
    "title": "Mybatis笔记",
    "date": "",
    "description": "Mybatis笔记",
    "body": "Mybatis 1、第一个Mybatis程序 1.1、搭建环境 搭建数据库：\nCREATE DATABASE `mybatis`;  USE `mybatis`;  CREATE TABLE `user` (  `id` INT(20) NOT NULL PRIMARY KEY,  `name` VARCHAR(30) DEFAULT NULL,  `pwd` VARCHAR(30) DEFAULT NULL )ENGINE = INNODB DEFAULT CHARSET = utf8; 新建项目：\n 新建一个maven项目 删除src目录 导入maven依赖  \u0026lt;dependencies\u0026gt;  \u0026lt;!--mysql驱动--\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;8.0.25\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;!--mybatis--\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;3.5.6\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;4.13\u0026lt;/version\u0026gt;  \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;1.18.22\u0026lt;/version\u0026gt;  \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt;  \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 1.2、创建一个模块  编写mybatis的核心配置文件  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;!--核心配置文件--\u0026gt; \u0026lt;configuration\u0026gt;  \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt;  \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt;  \u0026lt;!--事务管理--\u0026gt;  \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;\u0026gt;\u0026lt;/transactionManager\u0026gt;  \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt;  \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.jdbc.Driver\u0026#34;/\u0026gt;  \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mybatis?userSSL=true\u0026amp;amp;useUnicode=true\u0026amp;amp;characterEncoding=utf-8\u0026amp;amp;serverTimezone=GMT%2B8\u0026#34;/\u0026gt;  \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt;  \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;123456\u0026#34;/\u0026gt;  \u0026lt;/dataSource\u0026gt;  \u0026lt;/environment\u0026gt;  \u0026lt;/environments\u0026gt;   \u0026lt;!--每一个mapper.xml都需要在mybatis配置文件中注册--\u0026gt;  \u0026lt;mappers\u0026gt;  \u0026lt;mapper resource=\u0026#34;com/wzc/dao/UserMapper.xml\u0026#34;/\u0026gt;  \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt;  编写mybatis的工具类  //sqlSessionFactory --\u0026gt; sqlSession public class MybatisUtils {   private static SqlSessionFactory sqlSessionFactory;   static {  try {  //使用Mybatis获取sqlSessionFactory对象  String resource = \u0026#34;mybatis-config.xml\u0026#34;;  InputStream inputStream = Resources.getResourceAsStream(resource);  sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);  } catch (IOException e) {  e.printStackTrace();  }  }   public static SqlSession getSqlSession() {  return sqlSessionFactory.openSession();  }  } 1.3、编写代码  实体类  @Data @AllArgsConstructor @NoArgsConstructor public class User {  private int id;  private String name;  private String pwd; }  Dao接口  public interface UserDao {  List\u0026lt;User\u0026gt; userList(); }  mapper.xml  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt;  \u0026lt;mapper namespace=\u0026#34;com.wzc.dao.UserDao\u0026#34;\u0026gt;  \u0026lt;select id=\u0026#34;userList\u0026#34; resultType=\u0026#34;com.wzc.pojo.User\u0026#34;\u0026gt;  select * from user;  \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 1.4、测试 public class UserDaoTest {  @Test  public void test1() {  //获取sqlSession对象  SqlSession sqlSession = MybatisUtils.getSqlSession();   try {   //方法一：getMapper，推荐（不需要强转以及写错字符串）  UserDao mapper = sqlSession.getMapper(UserDao.class);  List\u0026lt;User\u0026gt; userList = mapper.userList();   //方法二：不推荐使用  //List\u0026lt;User\u0026gt; userList = sqlSession.selectList(\u0026#34;com.wzc.dao.UserDao.userList\u0026#34;);   for (User user : userList) {  System.out.println(user);  }   } finally {  //关闭sqlSession  sqlSession.close();  }  } } 2、CRUD 2.1 namespace namespace中的包名要和mapper接口的包名一致\n2.2、select 查询语句\n id：对应接口中的方法名 resultType：sql语句的返回值 parameterType：参数类型  \u0026lt;select id=\u0026#34;getUserById\u0026#34; parameterType=\u0026#34;int\u0026#34; resultType=\u0026#34;com.wzc.pojo.User\u0026#34;\u0026gt;  select * from user where id = #{id}; \u0026lt;/select\u0026gt; public class UserDaoTest {  @Test  public void userListTest() {  try (SqlSession sqlSession = MybatisUtils.getSqlSession()) {  UserDao mapper = sqlSession.getMapper(UserDao.class);  List\u0026lt;User\u0026gt; userList = mapper.userList();  for (User user : userList) {  System.out.println(user);  }  }  } } 2.3、insert \u0026lt;insert id=\u0026#34;addUser\u0026#34; parameterType=\u0026#34;com.wzc.pojo.User\u0026#34;\u0026gt;  insert into user (id, name, pwd) values (#{id}, #{name}, #{pwd}); \u0026lt;/insert\u0026gt; 2.4、update \u0026lt;update id=\u0026#34;updateUserById\u0026#34; parameterType=\u0026#34;com.wzc.pojo.User\u0026#34;\u0026gt;  update user set name = #{name}, pwd = #{pwd} where id = #{id}; \u0026lt;/update\u0026gt; 2.5、delete \u0026lt;delete id=\u0026#34;deleteUserById\u0026#34; parameterType=\u0026#34;int\u0026#34;\u0026gt;  delete from user where id = #{id}; \u0026lt;/delete\u0026gt; 注意点：\n 增删改操作都需要提交事务：sqlSession.commit();  3、万能Map 当实体类中字段过多时，应当考虑使用Map\npublic interface UserDao {  int addUserMap(Map\u0026lt;String, Object\u0026gt; user); } Map传递参数直接在sql中取出key即可\n4、模糊查询  传递带通配符的参数  public class UserDaoTest {  List\u0026lt;User\u0026gt; userList = mapper.getUserLikeName(\u0026#34;%i%\u0026#34;); } 在sql中拼接通配符  \u0026lt;select id=\u0026#34;getUserLikeName\u0026#34; resultType=\u0026#34;com.wzc.pojo.User\u0026#34;\u0026gt;  select * from user where name like concat(\u0026#39;%\u0026#39;, #{name}, \u0026#39;%\u0026#39;); \u0026lt;/select\u0026gt; 5、配置解析 5.1、核心配置文件  mybatis-config.xml  configuration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） 5.2、环境配置（environments） Mybatis可以配置成适应多种环境，但是尽管可以配置多种环境，每个SqlSessionFactory实例只能选择一种环境\nMybatis默认的事务管理器就是JDBC\n5.3、属性（properties） 属性可以外部配置和动态替换，既可以在java属性文件中配置，也可以使用properties子元素指定\n编写配置文件db.properties\ndriver=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/mybatis?userSSL=true\u0026amp;useUnicode=true\u0026amp;characterEncoding=utf-8\u0026amp;serverTimezone=GMT%2B8 #username=root #password=123456 在核心配置文件中引入\n\u0026lt;configuration\u0026gt;  \u0026lt;!--引入外部配置文件--\u0026gt;  \u0026lt;properties resource=\u0026#34;db.properties\u0026#34;\u0026gt;  \u0026lt;!--优先读取property属性指定的配置，然后才读取外部配置文件覆盖同名属性--\u0026gt;  \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt;  \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;123456\u0026#34;/\u0026gt;  \u0026lt;/properties\u0026gt; \u0026lt;/configuration\u0026gt; 优先读取property标签中的属性，然后读取外部配置文件中的属性并覆盖同名的属性\n5.4、类型别名（typeAliases）  类型别名是为java类型设置一个短的名字 存在的意义仅在于用来减少类完全限定名的冗余  \u0026lt;typeAliases\u0026gt;  \u0026lt;typeAlias type=\u0026#34;com.wzc.pojo.User\u0026#34; alias=\u0026#34;User\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; 也可以指定一个包名，Mybatis会在包名下面搜索需要的java bean，默认的别名为类名\n\u0026lt;typeAliases\u0026gt;  \u0026lt;!--\u0026lt;typeAlias type=\u0026#34;com.wzc.pojo.User\u0026#34; alias=\u0026#34;User\u0026#34;/\u0026gt;--\u0026gt;  \u0026lt;package name=\u0026#34;com.wzc.pojo\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; 5.5、设置（settings）  logImpl：指定Mybatis所用日志 cacheEnabled：全局开启或关闭缓存 lazyLoadingEnabled：全局懒加载开关  6、其他配置  typeHandler（类型处理器） objectFactory（类型工厂） plugins（插件）  mybatis-generator-core mybatis-plus 通用mapper    7、映射器（mappers） MapperRegistry：注册绑定Mapper文件\n方法一：【推荐使用】\n\u0026lt;!--每一个mapper.xml都需要在mybatis配置文件中注册--\u0026gt; \u0026lt;mappers\u0026gt;  \u0026lt;mapper resource=\u0026#34;com/wzc/mapper/UserMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; 方法二：使用class文件绑定注册\n\u0026lt;mappers\u0026gt;  \u0026lt;mapper class=\u0026#34;com.wzc.mapper.UserMapper\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; 注意点：\n 接口和Mapper配置文件必须同名 接口和Mapper配置文件必须在同一个包下  方法三：使用扫描包进行注入\n注意点和方法二一样\n\u0026lt;mappers\u0026gt;  \u0026lt;package name=\u0026#34;com.wzc.mapper\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; 8、生命周期和作用域 生命周期和作用域是重要的，因为错误的使用会导致严重的并发问题\nSqlSessionFactoryBuilder：\n 一旦创建了SqlSessionFactory，就不再需要SqlSessionFactoryBuilder 局部变量  SqlSessionFactory：\n 可以理解为数据库连接池 一旦创建就应该在程序运行期间一直存在， 没有理由丢弃或重新创建一个实例（单例模式或静态单例模式实现） SqlSessionFactory的最佳作用域是应用作用域  SqlSession：\n 可以理解为连接池的一个请求 SqlSession实例不是线程安全的，所以不能被共享，最佳作用域是请求或方法作用域 用完之后需要关闭，释放资源  9、resultMap 结果集映射，解决数据库字段名与实体类属性名称不一致的问题\n\u0026lt;resultMap id=\u0026#34;UserMap\u0026#34; type=\u0026#34;User\u0026#34;\u0026gt;  \u0026lt;!--column：数据库中的字段，property：实体类中的属性--\u0026gt;  \u0026lt;result column=\u0026#34;id\u0026#34; property=\u0026#34;id\u0026#34;/\u0026gt;  \u0026lt;result column=\u0026#34;name\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt;  \u0026lt;result column=\u0026#34;pwd\u0026#34; property=\u0026#34;password\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; 10、日志 10.1、日志工厂 Mybatis的settings中提供了日志配置的设置logImpl 支持的选项有：\n SLF4J LOG4J【掌握】 LOG4J2 JDK_LOGGING COMMONS_LOGGING STDOUT_LOGGING【掌握】 NO_LOGGING  STDOUT_LOGGING标准日志输出：\n\u0026lt;settings\u0026gt;  \u0026lt;setting name=\u0026#34;logImpl\u0026#34; value=\u0026#34;STDOUT_LOGGING\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt; 6.2、Log4j  先导入log4j的包  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;org.apache.logging.log4j\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;log4j-core\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;2.17.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; log4j.properties  # 将等级为DEBUG的日志输出到console和file这两个目的地 log4j.rootLogger=DEBUG,console # ,file # 控制台输出相关设置 log4j.appender.console=org.apache.log4j.ConsoleAppender log4j.appender.console.Target=System.out log4j.appender.console.Threshold=DEBUG log4j.appender.console.layout=org.apache.log4j.PatternLayout log4j.appender.console.layout.ConversionPattern=[%c]-%m%n # 文件输出相关设置 # log4j.appender.file=org.apache.log4j.RollingFileAppender # log4j.appender.file.File=输出文件路径 # log4j.appender.file.MaxFileSize=最大文件大小 # log4j.appender.file.Threshold=DEBUG # log4j.appender.console.layout=org.apache.log4j.PatternLayout # log4j.appender.console.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n # 日志输出级别 log4j.logger.org.mybatis=DEBUG log4j.logger.java.sql=DEBUG log4j.logger.java.sql.Statement=DEBUG log4j.logger.java.sql.ResultSet=DEBUG log4j.logger.java.sql.PreparedStatement=DEBUG 配置log4j日志实现  \u0026lt;settings\u0026gt;  \u0026lt;setting name=\u0026#34;logImpl\u0026#34; value=\u0026#34;LOG4J\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt; 简单使用\n 导入org.apache.log4j.Logger 获取日志对象  static Logger logger = Logger.getLogger(UserMapperTest.class); 日志级别  logger.info(\u0026#34;info: 进入了test2\u0026#34;); logger.debug(\u0026#34;debug: 进入了test2\u0026#34;); logger.error(\u0026#34;error: 进入了test2\u0026#34;); 7、分页 7.1、使用limit分页 select * from user limit startIndex, pageSize; 使用Mybatis实现分页，核心为sql\n 接口  List\u0026lt;User\u0026gt; userPage(Map\u0026lt;String, Integer\u0026gt; condition); Mapper.xml  \u0026lt;select id=\u0026#34;userPage\u0026#34; parameterType=\u0026#34;map\u0026#34; resultMap=\u0026#34;UserMap\u0026#34;\u0026gt;  select * from user limit #{startIndex}, #{pageSize}; \u0026lt;/select\u0026gt; 测试  @Test public void userPageTest() {  try (SqlSession sqlSession = MybatisUtil.getSqlSession()) {  UserMapper mapper = sqlSession.getMapper(UserMapper.class);  Map\u0026lt;String, Integer\u0026gt; condition = new HashMap\u0026lt;\u0026gt;();  condition.put(\u0026#34;startIndex\u0026#34;, 1);  condition.put(\u0026#34;pageSize\u0026#34;, 2);  List\u0026lt;User\u0026gt; userList = mapper.userPage(condition);  for (User user : userList) {  System.out.println(user);  }  } } 7.2、RowBounds分页【不推荐使用】  接口  List\u0026lt;User\u0026gt; userRowBounds(); mapper.xml  \u0026lt;select id=\u0026#34;userRowBounds\u0026#34; resultMap=\u0026#34;UserMap\u0026#34;\u0026gt;  select * from user; \u0026lt;/select\u0026gt; 测试  @Test public void userRowBoundsTest() {  try (SqlSession sqlSession = MybatisUtil.getSqlSession()) {  List\u0026lt;User\u0026gt; userList = sqlSession.selectList(\u0026#34;com.wzc.mapper.UserMapper.userRowBounds\u0026#34;, null, new RowBounds(1, 2));  for (User user : userList) {  System.out.println(user);  }  } } 7.3、分页插件 pageHelper：https://pagehelper.github.io/docs/howtouse/\n8、使用注解开发  接口  public interface UserMapper {  @Select(\u0026#34;select * from user\u0026#34;)  List\u0026lt;User\u0026gt; userList(); } 配置文件中绑定接口  \u0026lt;mappers\u0026gt;  \u0026lt;mapper class=\u0026#34;com.wzc.mapper.UserMapper\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; Mybatis实现流程\n8.1、注解CRUD public interface UserMapper {  @Select(\u0026#34;select * from user\u0026#34;)  List\u0026lt;User\u0026gt; userList();   //方法存在多个参数时，所有参数前面必须加上@Param注解  @Select(\u0026#34;select id, name, pwd as password from user where id = #{id}\u0026#34;)  User getUserById(@Param(\u0026#34;id\u0026#34;) int id);   @Insert(\u0026#34;insert into user(id, name, pwd) values(#{id}, #{name}, #{password})\u0026#34;)  int addUser(User user);   @Update(\u0026#34;update user set name = #{name}, pwd = #{password} where id = #{id}\u0026#34;)  int updateUser(User user);   @Delete(\u0026#34;delete from user where id = #{id}\u0026#34;)  int deleteUser(@Param(\u0026#34;id\u0026#34;) int id); } 【注意：必须将接口绑定到配置文件中】\n关于@Param注解\n 基本类型或String类型需要添加@Param注解，引用类型不需要添加  9、Lombok  安装插件 导入jar包  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;1.18.22\u0026lt;/version\u0026gt;  \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 在实体类上加注解  10、多对一处理 CREATE TABLE `teacher`(  `id` INT(10) NOT NULL,  `name` VARCHAR(30) DEFAULT NULL,  PRIMARY KEY (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8;  INSERT INTO `teacher`(`id`, `name`) VALUES (1, \u0026#39;张老师\u0026#39;);  CREATE TABLE `student` (  `id` INT(10) NOT NULL,  `name` varchar(30) DEFAULT NULL,  `tid` INT(10) DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `fktid` (`tid`),  CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8;  INSERT INTO `student` (`id`, `name`, `tid`) VALUES (1, \u0026#39;小明\u0026#39;, 1); INSERT INTO `student` (`id`, `name`, `tid`) VALUES (2, \u0026#39;小李\u0026#39;, 1); INSERT INTO `student` (`id`, `name`, `tid`) VALUES (3, \u0026#39;小赵\u0026#39;, 1); INSERT INTO `student` (`id`, `name`, `tid`) VALUES (4, \u0026#39;小王\u0026#39;, 1); 10.1、按照查询嵌套处理（子查询） \u0026lt;mapper namespace=\u0026#34;com.wzc.mapper.StudentMapper\u0026#34;\u0026gt;  \u0026lt;resultMap id=\u0026#34;studentTeacher\u0026#34; type=\u0026#34;Student\u0026#34;\u0026gt;  \u0026lt;result property=\u0026#34;id\u0026#34; column=\u0026#34;id\u0026#34;/\u0026gt;  \u0026lt;result property=\u0026#34;name\u0026#34; column=\u0026#34;name\u0026#34;/\u0026gt;  \u0026lt;!--对象：association，集合：collection--\u0026gt;  \u0026lt;association property=\u0026#34;teacher\u0026#34; column=\u0026#34;tid\u0026#34; javaType=\u0026#34;Teacher\u0026#34; select=\u0026#34;selectTeacher\u0026#34;/\u0026gt;  \u0026lt;/resultMap\u0026gt;  \u0026lt;select id=\u0026#34;studentList\u0026#34; resultMap=\u0026#34;studentTeacher\u0026#34;\u0026gt;  select * from student  \u0026lt;/select\u0026gt;  \u0026lt;select id=\u0026#34;selectTeacher\u0026#34; resultType=\u0026#34;Teacher\u0026#34;\u0026gt;  select * from teacher where id = #{tid}  \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 10.2、按照结果嵌套处理（联表查询） \u0026lt;mapper\u0026gt;  \u0026lt;resultMap id=\u0026#34;studentTeacher\u0026#34; type=\u0026#34;Student\u0026#34;\u0026gt;  \u0026lt;result property=\u0026#34;id\u0026#34; column=\u0026#34;sid\u0026#34;/\u0026gt;  \u0026lt;result property=\u0026#34;name\u0026#34; column=\u0026#34;sname\u0026#34;/\u0026gt;  \u0026lt;association property=\u0026#34;teacher\u0026#34; javaType=\u0026#34;Teacher\u0026#34;\u0026gt;  \u0026lt;result property=\u0026#34;id\u0026#34; column=\u0026#34;tid\u0026#34;/\u0026gt;  \u0026lt;result property=\u0026#34;name\u0026#34; column=\u0026#34;tname\u0026#34;/\u0026gt;  \u0026lt;/association\u0026gt;  \u0026lt;/resultMap\u0026gt;  \u0026lt;select id=\u0026#34;studentList\u0026#34; resultMap=\u0026#34;studentTeacher\u0026#34;\u0026gt;  select s.id sid, s.name sname, t.id tid, t.name tname from student s left join teacher t on t.id = s.tid  \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 11、一对多处理 一个老师教多个学生\n11.1、按结果嵌套（联表查询） \u0026lt;mapper namespace=\u0026#34;com.wzc.mapper.TeacherMapper\u0026#34;\u0026gt;  \u0026lt;!--按结果嵌套--\u0026gt;  \u0026lt;resultMap id=\u0026#34;teacherStudent\u0026#34; type=\u0026#34;Teacher\u0026#34;\u0026gt;  \u0026lt;result property=\u0026#34;id\u0026#34; column=\u0026#34;tid\u0026#34;/\u0026gt;  \u0026lt;result property=\u0026#34;name\u0026#34; column=\u0026#34;tname\u0026#34;/\u0026gt;  \u0026lt;collection property=\u0026#34;students\u0026#34; ofType=\u0026#34;Student\u0026#34;\u0026gt;  \u0026lt;result property=\u0026#34;id\u0026#34; column=\u0026#34;sid\u0026#34;/\u0026gt;  \u0026lt;result property=\u0026#34;name\u0026#34; column=\u0026#34;sname\u0026#34;/\u0026gt;  \u0026lt;result property=\u0026#34;tid\u0026#34; column=\u0026#34;stid\u0026#34;/\u0026gt;  \u0026lt;/collection\u0026gt;  \u0026lt;/resultMap\u0026gt;  \u0026lt;select id=\u0026#34;getTeacher\u0026#34; resultMap=\u0026#34;teacherStudent\u0026#34;\u0026gt;  select t.id tid, t.name tname, s.id sid, s.name sname, s.tid stid from teacher t left join student s on t.id = s.tid where t.id = #{id}  \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 11.2、按查询嵌套 \u0026lt;mapper\u0026gt;  \u0026lt;resultMap id=\u0026#34;teacherStudent\u0026#34; type=\u0026#34;Teacher\u0026#34;\u0026gt;  \u0026lt;result property=\u0026#34;id\u0026#34; column=\u0026#34;id\u0026#34;/\u0026gt;  \u0026lt;result property=\u0026#34;name\u0026#34; column=\u0026#34;name\u0026#34;/\u0026gt;  \u0026lt;collection property=\u0026#34;students\u0026#34; column=\u0026#34;id\u0026#34; javaType=\u0026#34;ArrayList\u0026#34; ofType=\u0026#34;Student\u0026#34; select=\u0026#34;studentList\u0026#34;/\u0026gt;  \u0026lt;/resultMap\u0026gt;  \u0026lt;select id=\u0026#34;getTeacher\u0026#34; resultMap=\u0026#34;teacherStudent\u0026#34;\u0026gt;  select * from teacher where id = #{id}  \u0026lt;/select\u0026gt;  \u0026lt;select id=\u0026#34;studentList\u0026#34; resultType=\u0026#34;Student\u0026#34;\u0026gt;  select * from student where tid = #{id}  \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 11.3、小结  关联-association【多对一】 集合-collection【一对多】 javaType：用来指定实体类中属性的类型 ofType：用来指定泛型的类型 注意点：  保证sql的可读性 多对一和一对多中，属性名和字段的问题    12、动态SQL 动态SQL就是根据不同的条件生成不同的SQL语句\nCREATE TABLE `blog` (  `id` bigint NOT NULL COMMENT \u0026#39;博客id\u0026#39;,  `title` varchar(100) NOT NULL COMMENT \u0026#39;博客标题\u0026#39;,  `author` varchar(30) NOT NULL COMMENT \u0026#39;博客作者\u0026#39;,  `create_time` datetime NOT NULL COMMENT \u0026#39;创建时间\u0026#39;,  `views` int NOT NULL COMMENT \u0026#39;浏览量\u0026#39; ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 实体类\n@Data public class Blog {  private int id;  private String title;  private String author;  private Date createTime;  private int views; } 12.1、IF标签 \u0026lt;select id=\u0026#34;blogListByIf\u0026#34; parameterType=\u0026#34;Map\u0026#34; resultType=\u0026#34;Blog\u0026#34;\u0026gt;  select * from blog  \u0026lt;where\u0026gt;  \u0026lt;if test=\u0026#34;title != null\u0026#34;\u0026gt;  and title like concat(\u0026#34;%\u0026#34;, #{title}, \u0026#34;%\u0026#34;)  \u0026lt;/if\u0026gt;  \u0026lt;if test=\u0026#34;author != null\u0026#34;\u0026gt;  /*从第二个if开始必须要加and*/  and author like concat(\u0026#34;%\u0026#34;, #{author}, \u0026#34;%\u0026#34;)  \u0026lt;/if\u0026gt;  \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; 12.2、choose（when, otherwise） 类似switch-case\n\u0026lt;select id=\u0026#34;blogListByChoose\u0026#34; parameterType=\u0026#34;Map\u0026#34; resultType=\u0026#34;Blog\u0026#34;\u0026gt;  select * from blog  \u0026lt;where\u0026gt;  \u0026lt;choose\u0026gt;  \u0026lt;when test=\u0026#34;title != null\u0026#34;\u0026gt;  /*当一个choose前还有choose标签的时候第一个条件也要加and*/  and title like concat(\u0026#34;%\u0026#34;, #{title}, \u0026#34;%\u0026#34;)  \u0026lt;/when\u0026gt;  \u0026lt;when test=\u0026#34;author != null\u0026#34;\u0026gt;  and author like concat(\u0026#34;%\u0026#34;, #{author}, \u0026#34;%\u0026#34;)  \u0026lt;/when\u0026gt;  \u0026lt;otherwise\u0026gt;  /*前面都不执行时会执行otherwise*/  and views \u0026gt;= 1000  \u0026lt;/otherwise\u0026gt;  \u0026lt;/choose\u0026gt;  \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; 12.3、trim（where, set） \u0026lt;update id=\u0026#34;updateBlog\u0026#34; parameterType=\u0026#34;Blog\u0026#34;\u0026gt;  update blog  \u0026lt;set\u0026gt;  \u0026lt;if test=\u0026#34;title != null\u0026#34;\u0026gt;  title = #{title},  \u0026lt;/if\u0026gt;  \u0026lt;if test=\u0026#34;author != null\u0026#34;\u0026gt;  author = #{author},  \u0026lt;/if\u0026gt;  \u0026lt;/set\u0026gt;  where id = #{id} \u0026lt;/update\u0026gt; SQL片段\n 使用sql标签抽取公共的sql  \u0026lt;sql id=\u0026#34;ifSql\u0026#34;\u0026gt;  \u0026lt;if test=\u0026#34;title != null\u0026#34;\u0026gt;  and title like concat(\u0026#34;%\u0026#34;, #{title}, \u0026#34;%\u0026#34;)  \u0026lt;/if\u0026gt;  \u0026lt;if test=\u0026#34;author != null\u0026#34;\u0026gt;  /*从第二个if开始必须要加and*/  and author like concat(\u0026#34;%\u0026#34;, #{author}, \u0026#34;%\u0026#34;)  \u0026lt;/if\u0026gt; \u0026lt;/sql\u0026gt; 在需要的地方使用include引用  \u0026lt;select id=\u0026#34;blogListByIf\u0026#34; parameterType=\u0026#34;Map\u0026#34; resultType=\u0026#34;Blog\u0026#34;\u0026gt;  select * from blog  \u0026lt;where\u0026gt;  \u0026lt;include refid=\u0026#34;ifSql\u0026#34;\u0026gt;\u0026lt;/include\u0026gt;  \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; 注意点：\n 最好基于单表定义sql片段 不要存在where标签  12.4、foreach collection：要遍历集合的参数名 item：遍历项 open：起始追加 close：结尾追加 separate：分隔符\n\u0026lt;select id=\u0026#34;blogListByForeach\u0026#34; parameterType=\u0026#34;List\u0026#34; resultType=\u0026#34;Blog\u0026#34;\u0026gt;  select * from blog where  \u0026lt;foreach collection=\u0026#34;ids\u0026#34; item=\u0026#34;id\u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34; separator=\u0026#34;or\u0026#34;\u0026gt;  id = #{id}  \u0026lt;/foreach\u0026gt; \u0026lt;/select\u0026gt; 13、Mybatis缓存  Mybatis系统中定义了两级缓存：一级和二级缓存 默认情况下，只有一级缓存开启（sqlSession级别的缓存，也称为本地缓存） 二级缓存需要配置开启，也可以通过实现Cache接口实现（namespace级别的缓存，也称为全局缓存）  13.1、一级缓存 public class UserMapperTest {  @Test  public void test1() {  try (SqlSession sqlSession = MybatisUtil.getSqlSession()) {  /*一级缓存：sqlSession级别，第二次查询时从缓存中取结果，两次查询的结果相同*/  UserMapper mapper = sqlSession.getMapper(UserMapper.class);  User user1 = mapper.getUserById(1);  User user2 = mapper.getUserById(1);  System.out.println(user1);  System.out.println(user2);  System.out.println(user1 == user2);  }  } } 缓存失效情况：\n 增删改操作，可能会改变数据，所以会刷新缓存 查询不同的sql 查询不同的mapper 手动清除缓存（sqlSession.clearCache()）  小结：一级缓存是默认开启的，只在一次sqlSession中有效\n13.2、二级缓存 二级缓存工作机制：\n 当一次会话关闭后，一级缓存中的数据会被保存到二级缓存中，新会话从二级缓存中获取数据 不同的mapper对应不同的二级缓存  使用步骤：\n 开启二级缓存（默认就是开启的）  \u0026lt;!--开启二级缓存--\u0026gt; \u0026lt;setting name=\u0026#34;cacheEnabled\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; mapper.xml中添加cache标签  \u0026lt;!--在当前mapper中使用二级缓存，FIFO策略，每60秒刷新缓存，缓存空间大小512，只读--\u0026gt; \u0026lt;cache eviction=\u0026#34;FIFO\u0026#34; flushInterval=\u0026#34;60000\u0026#34; size=\u0026#34;512\u0026#34; readOnly=\u0026#34;true\u0026#34;/\u0026gt; 测试  public class UserMapperTest {  @Test  public void test2() {  try (SqlSession sqlSession1 = MybatisUtil.getSqlSession();  SqlSession sqlSession2 = MybatisUtil.getSqlSession()) {  UserMapper mapper1 = sqlSession1.getMapper(UserMapper.class);  UserMapper mapper2 = sqlSession2.getMapper(UserMapper.class);  User user1 = mapper1.getUserById(1);  System.out.println(user1);  sqlSession1.close();  /*一级缓存关闭后，其中的数据会保存到二级缓存，再次查询从二级缓存中获取数据*/  User user2 = mapper2.getUserById(1);  System.out.println(user2);  System.out.println(user1 == user2);  }  } } 注意： 实体类需要实现Serializable接口序列化，否则会报NotSerializableException\n13.3、缓存原理  先看二级缓存中有没有 再看一级缓存中有没有 查询数据库   13.6、自定义缓存ehcache Ehcache是一种广泛使用的开源java分布式缓存，主要面向通用缓存\n 导包  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;org.mybatis.caches\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;mybatis-ehcache\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;1.2.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 配置文件指定使用ehcache  \u0026lt;cache type=\u0026#34;org.mybatis.caches.ehcache.EhcacheCache\u0026#34;/\u0026gt; 编写ehcache的配置文件  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;ehcache xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;  xsi:noNamespaceSchemaLocation=\u0026#34;http://ehcache.org/ehcache.xsd\u0026#34;  updateCheck=\u0026#34;false\u0026#34;\u0026gt;  \u0026lt;diskStore path=\u0026#34;./tmpdir/Tmp_EhCache\u0026#34;/\u0026gt;   \u0026lt;defaultCache  eternal=\u0026#34;false\u0026#34;  maxElementsInMemory=\u0026#34;10000\u0026#34;  overflowToDisk=\u0026#34;false\u0026#34;  diskPersistent=\u0026#34;false\u0026#34;  timeToIdleSeconds=\u0026#34;1800\u0026#34;  timeToLiveSeconds=\u0026#34;259200\u0026#34;  memoryStoreEvictionPolicy=\u0026#34;LRU\u0026#34;/\u0026gt;   \u0026lt;cache  name=\u0026#34;cloud_user\u0026#34;  eternal=\u0026#34;false\u0026#34;  maxElementsInMemory=\u0026#34;5000\u0026#34;  overflowToDisk=\u0026#34;false\u0026#34;  diskPersistent=\u0026#34;false\u0026#34;  timeToIdleSeconds=\u0026#34;1800\u0026#34;  timeToLiveSeconds=\u0026#34;1800\u0026#34;  memoryStoreEvictionPolicy=\u0026#34;LRU\u0026#34;/\u0026gt; \u0026lt;/ehcache\u0026gt; ",
    "ref": "/post/mybatisnote/"
  },{
    "title": "我的第一篇博客",
    "date": "",
    "description": "我的第一篇博客",
    "body": "我的第一篇博客\n",
    "ref": "/post/myfirstblog/"
  }]
