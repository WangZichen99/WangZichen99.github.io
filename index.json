[{
    "title": "认知觉醒读书笔记",
    "date": "",
    "description": "",
    "body": "认知觉醒读书笔记 1.1、大脑：重新认识你自己 三层大脑\n  演进过程  爬行动物 本能脑  哺乳动物 情绪脑  人类 理智脑    三层大脑对比 本能脑 低级 强大 婴儿时期趋于完善（2岁） 神经元细胞数量多，距离心脏近 运行速度快 控制大脑能力强 更接近原始社会-生存-及时享乐、避难趋易、急于求成  情绪脑 低级 次强 青春期早期（12岁）  理智脑 高级 弱小 成年早期（22岁） 数量少，距离远 速度慢且耗能 控制大脑能力弱 更接近现代社会   结果\n 明知读书重要，却转身掏出手机 明知跑步有益，却两天没了下文 明知要事优先，却围绕琐事打转  大多数时候我们以为自己在思考，实则都是对自身行为和欲望的合理化\n成长是克服天性的过程\n提升理智脑 ≠ 削弱本能脑和情绪脑\n理智脑指挥，本能脑行动\n1.2、焦虑的根源 焦虑的形式：\n 完成焦虑：内在欲望太广或时间安排太紧从而无法做到从容 定位焦虑：将起步的自己与他人取得的成就相比 选择焦虑：选择太多，不知道如何抉择 环境焦虑：环境迫使 难度焦虑：不下决心认真对待难度大的事情，而在周围打转  焦虑的原因：\n 总结起来就是：相同时做很多事，又想立即看到效果（欲望与能力差距较大） 人的一切痛苦本质上都是对自己的无能的愤怒 ———— 王小波  graph TD A(想同时做很多事) -- B(急于求成) -- E(天性) C(想不怎么努力就看到效果) -- D(避难趋易) -- E(天性)  1.3、耐心：得耐心者得天下 宏观上：\n  复利效应：   舒适区边缘   微观上：\n 学习过程与权重  过程：学习————思考————行动————改变 权重：改变 \u0026gt; 行动 \u0026gt; 思考 \u0026gt; 学习 人们在学习过程中总是看到自己学习了多少，而不是看到自己改变了多少 书中的一两个观点改变了我 \u0026gt; 我今天读书5个小时   平台期   拥有耐性：\n 接纳天性（缺乏耐心） 延迟满足（该有的享受一点也不会少，只不过不是现在，而是在完成该做的之后） 提升认知，看到事情的深层意义 享受高级乐趣（学习的乐趣，健身的乐趣）取代低级乐趣（玩手机）  2.1、模糊：人生是一场消除模糊的比赛 意识分层：潜意识负责生理系统，意识负责社会系统\n意识分层导致的问题：模糊\n产生模糊的原因：\n 处理信息速度不对等 意识难以左右潜意识，但潜意识可以左右意识  人们不愿消除模糊，因为消除模糊意味着走出舒适区，人们不愿做这种高耗能的事情， 而总是在重复那些已经掌握的事情，从而导致自己无法进步\n所有的困难只因为我们对其的认知模糊，这种模糊阻碍了我们，导致拖延、不愿面对问题， 如果我们能够在一开始就主动消除模糊，就不会徒增烦恼\n所有的痛苦都不会凭空消失， 唯一的办法就是在它们变得模糊， 在它们进入潜意识前正视它、拆解它\n选择模糊会导致行动力不足\n解决办法是：细化过程，建立一条单行道，消除选择\n",
    "ref": "/post/cognitiveawakennote/"
  },{
    "title": "SpringMVC笔记",
    "date": "",
    "description": "SpringMVC笔记",
    "body": "SpringMVC 1、SpringMVC执行原理  用户访问后首先被web.xml中的DispatchServlet拦截下来 DispatchServlet调用HandlerMapping处理器映射，HandlerMapping根据请求url查找Handler HandlerExecution根据url到springmvc-servlet.xml中查找控制器controller，并将解析后的信息传递给DispatchServlet HandlerAdapter为处理器适配器，按照特定的规则执行Handler Handler让具体的controller执行 controller将执行信息(ModelAndView)返回给HandlerAdapter HandlerAdapter将视图逻辑名或模型传递给DispatchServlet DispatchServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名 视图解析器ViewResolver将解析的逻辑视图名传给DispatchServlet DispatchServlet根据视图解析器解析的结果，调用具体的视图   web.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34;  xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;  xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34;  version=\u0026#34;4.0\u0026#34;\u0026gt;   \u0026lt;!--注册DispatchServlet--\u0026gt;  \u0026lt;servlet\u0026gt;  \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt;  \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt;  \u0026lt;!--关联一个springmvc配置文件：【servlet-name】-servlet.xml--\u0026gt;  \u0026lt;init-param\u0026gt;  \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt;  \u0026lt;param-value\u0026gt;classpath:springmvc-servlet.xml\u0026lt;/param-value\u0026gt;  \u0026lt;/init-param\u0026gt;  \u0026lt;!--启动级别-1--\u0026gt;  \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt;  \u0026lt;/servlet\u0026gt;   \u0026lt;!--/匹配所有请求：（不包括.jsp）--\u0026gt;  \u0026lt;!--/*匹配所有请求（包括.jsp）--\u0026gt;  \u0026lt;servlet-mapping\u0026gt;  \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt;  \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt;  \u0026lt;/servlet-mapping\u0026gt;  \u0026lt;/web-app\u0026gt; springmvc-servlet.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34;  xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;  xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt;   \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\u0026#34;/\u0026gt;  \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\u0026#34;/\u0026gt;   \u0026lt;!--视图解析器：DispatcherServlet返回的ModelAndView--\u0026gt;  \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026#34; id=\u0026#34;internalResourceViewResolver\u0026#34;\u0026gt;  \u0026lt;!--前缀--\u0026gt;  \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/WEB-INF/jsp/\u0026#34;/\u0026gt;  \u0026lt;!--后缀--\u0026gt;  \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.jsp\u0026#34;/\u0026gt;  \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; HelloController.java (实现了Controller接口就成为了一个视图解析器，返回ModelAndView)\npublic class HelloController implements Controller {  @Override  public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception {  //ModelAndView模型和视图  ModelAndView mv = new ModelAndView();  //封装对象放在ModelAndView中  mv.addObject(\u0026#34;msg\u0026#34;, \u0026#34;HelloSpringMVC\u0026#34;);  //封装要跳转的视图放在ModelAndView中  mv.setViewName(\u0026#34;hello\u0026#34;); ///WEB-INF/jsp/hello.jsp  //返回ModelAndView  return mv;  } } 在spring-servlet.xml中注册bean，id对应请求路径，class对应视图解析器\n\u0026lt;!--Handler--\u0026gt; \u0026lt;bean id=\u0026#34;/hello\u0026#34; class=\u0026#34;com.wzc.controller.HelloController\u0026#34;/\u0026gt; 2、使用注解开发 配置资源过滤问题\n \u0026lt;build\u0026gt;  \u0026lt;resources\u0026gt;  \u0026lt;resource\u0026gt;  \u0026lt;directory\u0026gt;src/main/java\u0026lt;/directory\u0026gt;  \u0026lt;includes\u0026gt;  \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt;  \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt;  \u0026lt;/includes\u0026gt;  \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt;  \u0026lt;/resource\u0026gt;  \u0026lt;resource\u0026gt;  \u0026lt;directory\u0026gt;src/main/resources\u0026lt;/directory\u0026gt;  \u0026lt;includes\u0026gt;  \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt;  \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt;  \u0026lt;/includes\u0026gt;  \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt;  \u0026lt;/resource\u0026gt;  \u0026lt;/resources\u0026gt; \u0026lt;/build\u0026gt; web.xml注册DispatchServlet\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34;  xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;  xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34;  version=\u0026#34;4.0\u0026#34;\u0026gt;   \u0026lt;!--注册DispatchServlet--\u0026gt;  \u0026lt;servlet\u0026gt;  \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt;  \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt;  \u0026lt;!--关联一个springmvc配置文件：【servlet-name】-servlet.xml--\u0026gt;  \u0026lt;init-param\u0026gt;  \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt;  \u0026lt;param-value\u0026gt;classpath:springmvc-servlet.xml\u0026lt;/param-value\u0026gt;  \u0026lt;/init-param\u0026gt;  \u0026lt;!--启动级别-1--\u0026gt;  \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt;  \u0026lt;/servlet\u0026gt;   \u0026lt;!--/匹配所有请求：（不包括.jsp）--\u0026gt;  \u0026lt;!--/*匹配所有请求（包括.jsp）--\u0026gt;  \u0026lt;servlet-mapping\u0026gt;  \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt;  \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt;  \u0026lt;/servlet-mapping\u0026gt;  \u0026lt;/web-app\u0026gt; springmvc-servlet.xml配置文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34;  xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;  xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34;  xmlns:mvc=\u0026#34;http://www.springframework.org/schema/mvc\u0026#34;  xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\u0026#34;\u0026gt;  \u0026lt;!--自动扫描包，让指定包下的注解生效，有IOC容器统一管理--\u0026gt;  \u0026lt;context:component-scan base-package=\u0026#34;com.wzc.controller\u0026#34;/\u0026gt;  \u0026lt;!--让Spring MVC不处理静态资源--\u0026gt;  \u0026lt;mvc:default-servlet-handler/\u0026gt;  \u0026lt;!--支持mvc注解驱动，在spring中一般采用@RequestMapping注解来完成映射关系， 要使RequestMapping注解生效必须向上下文注册DefaultAnnotationHandlerMapping和AnnotationMethodHandlerAdapter实例， 这两个实例分别在类级别和方法级别处理，annotation-driven配置帮助我们自动完成两个实例的注入--\u0026gt;  \u0026lt;mvc:annotation-driven/\u0026gt;  \u0026lt;!--视图解析器--\u0026gt;  \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026#34; id=\u0026#34;internalResourceViewResolver\u0026#34;\u0026gt;  \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/WEB-INF/jsp/\u0026#34;/\u0026gt;  \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.jsp\u0026#34;/\u0026gt;  \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; HelloController.java\n @Controller @RequestMapping(\u0026#34;/api\u0026#34;) public class HelloController {  @RequestMapping(\u0026#34;/hello\u0026#34;)  public String hello(Model model) {  //封装数据  model.addAttribute(\u0026#34;msg\u0026#34;, \u0026#34;hello annotation\u0026#34;);  //视图解析器解析WEB-INF/jsp/hello.jsp  return \u0026#34;hello\u0026#34;;  } } 使用Spring MVC必须配置的三大件：处理器映射器、处理器配置器、视图解析器\n通常我们只需手动配置视图解析器，处理器映射器和处理器配置器只需要开启注解驱动即可，省去了大量的xml配置\n3、Controller和RestFul风格 3.1、实现Controller接口 public class HelloController implements Controller {  @Override  public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception {  //ModelAndView模型和视图  ModelAndView mv = new ModelAndView();  //封装对象放在ModelAndView中  mv.addObject(\u0026#34;msg\u0026#34;, \u0026#34;HelloSpringMVC\u0026#34;);  //封装要跳转的视图放在ModelAndView中  mv.setViewName(\u0026#34;hello\u0026#34;); ///WEB-INF/jsp/hello.jsp  //返回ModelAndView  return mv;  } } 缺点：一个controller中只能实现一个方法\n3.2、使用注解@Controller  开启自动扫描   \u0026lt;context:component-scan base-package=\u0026#34;com.wzc.controller\u0026#34;/\u0026gt; 在类上添加@Controller注解 在方法上添加@RequestMapping  3.3、@RequestMapping RequestMapping注解用于映射url到控制器类或一个特定的方法，可同时注解在类和方法上\n访问时的顺序是类/方法\n3.4、RestFul风格 RestFul风格可以通过不同的请求方式来实现不同的效果，比如：\n http://127.0.0.1/item/1————查询, GET http://127.0.0.1/item————新增, POST http://127.0.0.1/item————修改, PUT http://127.0.0.1/item————删除, DELETE  在SpringMVC中可以使用@PathVariable注解，让方法的参数值对应绑定到一个url模板变量上\n @Controller public class RestFulController {  @RequestMapping(\u0026#34;/add/{a}/{b}\u0026#34;)  public String add(@PathVariable(\u0026#34;a\u0026#34;) int a, @PathVariable(\u0026#34;b\u0026#34;) int b, Model model) {  model.addAttribute(\u0026#34;msg\u0026#34;, a + b);  return \u0026#34;restful\u0026#34;;  } } 注解介绍：\n@GetMapping(\u0026quot;\\hello\u0026quot;)表示get请求\n@PostMapping(\u0026quot;\\hello\u0026quot;)表示post请求\n@PutMapping(\u0026quot;\\hello\u0026quot;)表示put请求\n@DeleteMapping(\u0026quot;\\hello\u0026quot;)表示delete请求\n使用路径变量的好处：\n 使路径变得更加简洁 获得参数更加方便  3.5、重定向和转发 通过SpringMVC实现重定向和转发，无需视图解析器\n @Controller public class ForwardAndRedirect {  //转发一  @RequestMapping(\u0026#34;/ForwardAndRedirect/forward1\u0026#34;)  public String forward1(Model model) {  model.addAttribute(\u0026#34;msg\u0026#34;, \u0026#34;转发到restful.jsp\u0026#34;);  return \u0026#34;/WEB-INF/jsp/restful.jsp\u0026#34;;  }   //转发二  @RequestMapping(\u0026#34;/ForwardAndRedirect/forward2\u0026#34;)  public String forward2() {  return \u0026#34;forward:/index.jsp\u0026#34;;  }   //重定向（重定向不走视图解析器，并且重定向不能访问WEB-INF下的内容）  @RequestMapping(\u0026#34;/ForwardAndRedirect/redirect\u0026#34;)  public String redirect() {  return \u0026#34;redirect:/index.jsp\u0026#34;;  } } 3.6、SpringMVC参数接收  @Controller @RequestMapping(\u0026#34;/user\u0026#34;) public class UserController {  @GetMapping(\u0026#34;/get\u0026#34;)  public String get(@RequestParam(\u0026#34;username\u0026#34;) String name, Model model) {  model.addAttribute(\u0026#34;msg\u0026#34;, name);  return \u0026#34;/WEB-INF/jsp/restful.jsp\u0026#34;;  }   @GetMapping(\u0026#34;getUser\u0026#34;)  public void getUser(User user) {  System.out.println(user);  } } 在使用实体类接收参数时，前端需要将参数名与实体类变量名称一一对应，否则无法接收到所传参数\n3.7、乱码问题 在post请求中，前端传递中文时会产生乱码问题\n方法一：使用过滤器解决乱码\npublic class EncodingFilter implements Filter {  @Override  public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {  servletRequest.setCharacterEncoding(\u0026#34;utf-8\u0026#34;);  servletResponse.setCharacterEncoding(\u0026#34;utf-8\u0026#34;);  filterChain.doFilter(servletRequest, servletResponse);  } } web.xml中配置filter\n \u0026lt;web-app\u0026gt;  \u0026lt;filter\u0026gt;  \u0026lt;filter-name\u0026gt;encodingFilter\u0026lt;/filter-name\u0026gt;  \u0026lt;filter-class\u0026gt;com.wzc.filter.EncodingFilter\u0026lt;/filter-class\u0026gt;  \u0026lt;/filter\u0026gt;  \u0026lt;filter-mapping\u0026gt;  \u0026lt;filter-name\u0026gt;encodingFilter\u0026lt;/filter-name\u0026gt;  \u0026lt;!--/不包括jsp页面--\u0026gt;  \u0026lt;!--/*包括jsp页面--\u0026gt;  \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt;  \u0026lt;/filter-mapping\u0026gt; \u0026lt;/web-app\u0026gt; 方法二：springmvc提供的编码过滤器\n \u0026lt;web-app\u0026gt;  \u0026lt;filter\u0026gt;  \u0026lt;filter-name\u0026gt;encoding\u0026lt;/filter-name\u0026gt;  \u0026lt;filter-class\u0026gt;org.springframework.web.filter.CharacterEncodingFilter\u0026lt;/filter-class\u0026gt;  \u0026lt;init-param\u0026gt;  \u0026lt;param-name\u0026gt;encoding\u0026lt;/param-name\u0026gt;  \u0026lt;param-value\u0026gt;utf-8\u0026lt;/param-value\u0026gt;  \u0026lt;/init-param\u0026gt;  \u0026lt;/filter\u0026gt;  \u0026lt;filter-mapping\u0026gt;  \u0026lt;filter-name\u0026gt;encoding\u0026lt;/filter-name\u0026gt;  \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt;  \u0026lt;/filter-mapping\u0026gt; \u0026lt;/web-app\u0026gt; 4、JSON 4.1、Jackson  导包   \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;2.11.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 使用方法   @Controller public class UserController {  @GetMapping(\u0026#34;/getUser\u0026#34;)  @ResponseBody  public String getUser() throws JsonProcessingException {  ObjectMapper mapper = new ObjectMapper();  User user = new User(1, \u0026#34;王子琛\u0026#34;, 22);  String result = mapper.writeValueAsString(user);  return result;  } } 乱码问题的解决方法： \u0026lt;!--Json乱码问题解决--\u0026gt; \u0026lt;mvc:annotation-driven\u0026gt;  \u0026lt;mvc:message-converters\u0026gt;  \u0026lt;bean class=\u0026#34;org.springframework.http.converter.StringHttpMessageConverter\u0026#34;\u0026gt;  \u0026lt;constructor-arg value=\u0026#34;UTF-8\u0026#34;/\u0026gt;  \u0026lt;/bean\u0026gt;  \u0026lt;bean class=\u0026#34;org.springframework.http.converter.cbor.MappingJackson2CborHttpMessageConverter\u0026#34;\u0026gt;  \u0026lt;property name=\u0026#34;objectMapper\u0026#34;\u0026gt;  \u0026lt;bean class=\u0026#34;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\u0026#34;\u0026gt;  \u0026lt;property name=\u0026#34;failOnEmptyBeans\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt;  \u0026lt;/bean\u0026gt;  \u0026lt;/property\u0026gt;  \u0026lt;/bean\u0026gt;  \u0026lt;/mvc:message-converters\u0026gt; \u0026lt;/mvc:annotation-driven\u0026gt; @Controller和@RestController的区别：\n @Controller会走是解析器 @RestController会返回字符串 @ResponseBody是配合@Controller来使用，如果使用了@RestController就不需要了  返回日期类型\n @RestController public class UserController {  @GetMapping(\u0026#34;/getDate\u0026#34;)  public String getDate() throws JsonProcessingException {  ObjectMapper mapper = new ObjectMapper();  //不使用时间戳方式返回Date  mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);  //自定义文件格式  mapper.setDateFormat(new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;));  return mapper.writeValueAsString(new Date());  } } 封装工具类JsonUtil\npublic class JsonUtil {  public static String getJson(Object object) {  return getJson(object, \u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;);  }   public static String getJson(Object object, String format) {  ObjectMapper mapper = new ObjectMapper();  mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);  mapper.setDateFormat(new SimpleDateFormat(format));  try {  return mapper.writeValueAsString(object);  } catch (JsonProcessingException e) {  e.printStackTrace();  }  return null;  } } 4.2、FastJson  导包   \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;1.2.75\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 用法   java对象转Json字符串  JSON.toJSONString()   Json字符串转java对象  JSON.parseObject()   java对象转Json对象  JSON.toJSON()   JSON对象转java对象  JSON.parseJavaObject()    5、整合SSM  数据库  CREATE DATABASE `ssmbuild`;  USE `ssmbuild`;  CREATE TABLE `books` (  `bookID` INT(10) NOT NULL auto_increment COMMENT \u0026#39;id\u0026#39;,  `bookName` VARCHAR(100) NOT NULL COMMENT \u0026#39;书名\u0026#39;,  `bookCounts` INT(11) NOT NULL COMMENT \u0026#39;数量\u0026#39;,  `detail` VARCHAR(200) NOT NULL COMMENT \u0026#39;描述\u0026#39;,  KEY `bookID` (`bookID`) ) ENGINE = INNODB  DEFAULT CHARSET = utf8;  INSERT INTO `books`(`bookID`, `bookName`, `bookCounts`, `detail`) VALUES (1, \u0026#39;Java\u0026#39;, 1, \u0026#39;从入门到放弃\u0026#39;),  (2, \u0026#39;MySQL\u0026#39;, 10, \u0026#39;从删库到跑路\u0026#39;),  (3, \u0026#39;Linux\u0026#39;, 5, \u0026#39;从进门到进牢\u0026#39;); 导包和静态资源导出问题  \u0026lt;project\u0026gt;  \u0026lt;dependencies\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;8.0.25\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;!--数据库连接池c3p0--\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;com.mchange\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;c3p0\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;0.9.5.2\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;3.5.6\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;mybatis-spring\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;2.0.6\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;5.2.5.RELEASE\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;spring-jdbc\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;5.2.5.RELEASE\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;servlet-api\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;2.5\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;javax.servlet.jsp\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;jsp-api\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;2.2\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;jstl\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;1.2\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;1.2.75\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;1.18.16\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;/dependencies\u0026gt;  \u0026lt;build\u0026gt;  \u0026lt;resources\u0026gt;  \u0026lt;resource\u0026gt;  \u0026lt;directory\u0026gt;*/src/main/java\u0026lt;/directory\u0026gt;  \u0026lt;includes\u0026gt;  \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt;  \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt;  \u0026lt;/includes\u0026gt;  \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt;  \u0026lt;/resource\u0026gt;  \u0026lt;resource\u0026gt;  \u0026lt;directory\u0026gt;*/src/main/resources\u0026lt;/directory\u0026gt;  \u0026lt;includes\u0026gt;  \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt;  \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt;  \u0026lt;/includes\u0026gt;  \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt;  \u0026lt;/resource\u0026gt;  \u0026lt;/resources\u0026gt;  \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; 5.1、Mybatis层  mybatis-config.xml  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt;   \u0026lt;!--配置数据源，交给Spring去做--\u0026gt;   \u0026lt;typeAliases\u0026gt;  \u0026lt;package name=\u0026#34;com.wzc.pojo\u0026#34;/\u0026gt;  \u0026lt;/typeAliases\u0026gt;   \u0026lt;mappers\u0026gt;  \u0026lt;package name=\u0026#34;com.wzc.mapper\u0026#34;/\u0026gt;  \u0026lt;/mappers\u0026gt;  \u0026lt;/configuration\u0026gt; Books  @Data @AllArgsConstructor @NoArgsConstructor public class Books {  private int bookID;  private String bookName;  private int bookCounts;  private String detail; } BookMapper  public interface BookMapper {  int addBook(Books book);   int deleteBookById(@Param(\u0026#34;Id\u0026#34;) int id);   int updateBook(Books book);   Books queryBookById(@Param(\u0026#34;Id\u0026#34;) int id);   List\u0026lt;Books\u0026gt; queryAllBook(); } BookMapper.xml  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.wzc.com.wzc.controller.mapper.BookMapper\u0026#34;\u0026gt;  \u0026lt;insert id=\u0026#34;addBook\u0026#34; parameterType=\u0026#34;Books\u0026#34;\u0026gt;  insert into ssmbuild.books(bookID, bookName, bookCounts, detail) VALUES (#{bookID}, #{bookName}, #{bookCounts}, #{detail})  \u0026lt;/insert\u0026gt;   \u0026lt;delete id=\u0026#34;deleteBookById\u0026#34; parameterType=\u0026#34;int\u0026#34;\u0026gt;  delete from ssmbuild.books where bookID = #{id}  \u0026lt;/delete\u0026gt;   \u0026lt;update id=\u0026#34;updateBook\u0026#34; parameterType=\u0026#34;Books\u0026#34;\u0026gt;  update ssmbuild.books set bookName = #{bookName}, bookCounts = #{bookCounts}, detail = #{detail} where bookID = #{bookId}  \u0026lt;/update\u0026gt;   \u0026lt;select id=\u0026#34;queryBookById\u0026#34; parameterType=\u0026#34;int\u0026#34; resultType=\u0026#34;Books\u0026#34;\u0026gt;  select bookID, bookName, bookCounts, detail from ssmbuild.books where bookID = #{id}  \u0026lt;/select\u0026gt;   \u0026lt;select id=\u0026#34;queryAllBook\u0026#34; resultType=\u0026#34;Books\u0026#34;\u0026gt;  select bookID, bookName, bookCounts, detail from ssmbuild.books;  \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; BookService  public interface BookService {  int addBook(Books book);   int deleteBookById(@Param(\u0026#34;Id\u0026#34;) int id);   int updateBook(Books book);   Books queryBookById(@Param(\u0026#34;Id\u0026#34;) int id);   List\u0026lt;Books\u0026gt; queryAllBook(); } BookServiceImpl  public class BookServiceImpl implements BookService {  private BookMapper bookMapper;   public void setBookMapper(BookMapper bookMapper) {  this.bookMapper = bookMapper;  }   @Override  public int addBook(Books book) {  return bookMapper.addBook(book);  }   @Override  public int deleteBookById(int id) {  return bookMapper.deleteBookById(id);  }   @Override  public int updateBook(Books book) {  return bookMapper.updateBook(book);  }   @Override  public Books queryBookById(int id) {  return bookMapper.queryBookById(id);  }   @Override  public List\u0026lt;Books\u0026gt; queryAllBook() {  return bookMapper.queryAllBook();  } } 5.2、Spring层 spring-dao.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34;  xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;  xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34;  xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt;   \u0026lt;!--关联数据库配置文件--\u0026gt;  \u0026lt;context:property-placeholder location=\u0026#34;classpath:database.properties\u0026#34;/\u0026gt;   \u0026lt;!--连接池 dbcp：半自动化操作，不能自动连接 c3p0：自动化操作（自动化加载配置文件并自动设置到对象中） druid，hikari--\u0026gt;  \u0026lt;bean id=\u0026#34;datasource\u0026#34; class=\u0026#34;com.mchange.v2.c3p0.ComboPooledDataSource\u0026#34;\u0026gt;  \u0026lt;property name=\u0026#34;driverClass\u0026#34; value=\u0026#34;${jdbc.driver}\u0026#34;/\u0026gt;  \u0026lt;property name=\u0026#34;jdbcUrl\u0026#34; value=\u0026#34;${jdbc.url}\u0026#34;/\u0026gt;  \u0026lt;property name=\u0026#34;user\u0026#34; value=\u0026#34;${jdbc.username}\u0026#34;/\u0026gt;  \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${jdbc.password}\u0026#34;/\u0026gt;  \u0026lt;!--c3p0私有属性--\u0026gt;  \u0026lt;property name=\u0026#34;maxPoolSize\u0026#34; value=\u0026#34;30\u0026#34;/\u0026gt;  \u0026lt;property name=\u0026#34;minPoolSize\u0026#34; value=\u0026#34;10\u0026#34;/\u0026gt;  \u0026lt;!--关闭连接后不自动commit--\u0026gt;  \u0026lt;property name=\u0026#34;autoCommitOnClose\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt;  \u0026lt;!--获取连接超时时间--\u0026gt;  \u0026lt;property name=\u0026#34;checkoutTimeout\u0026#34; value=\u0026#34;10000\u0026#34;/\u0026gt;  \u0026lt;!--连接失败重试次数--\u0026gt;  \u0026lt;property name=\u0026#34;acquireRetryAttempts\u0026#34; value=\u0026#34;2\u0026#34;/\u0026gt;  \u0026lt;/bean\u0026gt;   \u0026lt;!--sqlSessionFactory--\u0026gt;  \u0026lt;bean id=\u0026#34;sqlSessionFactory\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionFactoryBean\u0026#34;\u0026gt;  \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;datasource\u0026#34;/\u0026gt;  \u0026lt;!--绑定Mybatis配置文件--\u0026gt;  \u0026lt;property name=\u0026#34;configLocation\u0026#34; value=\u0026#34;classpath:mybatis-config.xml\u0026#34;/\u0026gt;  \u0026lt;/bean\u0026gt;   \u0026lt;!--配置dao接口扫描包，动态实现了dao接口可以注入到spring容器中--\u0026gt;  \u0026lt;bean class=\u0026#34;org.mybatis.spring.mapper.MapperScannerConfigurer\u0026#34;\u0026gt;  \u0026lt;!--注入sqlSessionFactory--\u0026gt;  \u0026lt;property name=\u0026#34;sqlSessionFactoryBeanName\u0026#34; value=\u0026#34;sqlSessionFactory\u0026#34;/\u0026gt;  \u0026lt;!--要扫描的dao包--\u0026gt;  \u0026lt;property name=\u0026#34;basePackage\u0026#34; value=\u0026#34;com.wzc.mapper\u0026#34;/\u0026gt;  \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; spring-service.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34;  xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;  xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34;  xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt;   \u0026lt;!--扫描service下的包--\u0026gt;  \u0026lt;context:component-scan base-package=\u0026#34;com.wzc.service\u0026#34;/\u0026gt;   \u0026lt;!--声明式事务配置--\u0026gt;  \u0026lt;bean id=\u0026#34;transactionManager\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DataSourceTransactionManager\u0026#34;\u0026gt;  \u0026lt;!--注入数据源--\u0026gt;  \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;datasource\u0026#34;/\u0026gt;  \u0026lt;/bean\u0026gt;   \u0026lt;!--aop事务支持--\u0026gt; \u0026lt;/beans\u0026gt; 5.3、SpringMVC层 spring-mvc.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34;  xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;  xmlns:mvn=\u0026#34;http://www.springframework.org/schema/mvc\u0026#34;  xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34;  xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt;   \u0026lt;!--注解驱动--\u0026gt;  \u0026lt;mvn:annotation-driven/\u0026gt;  \u0026lt;!--静态资源配置过滤--\u0026gt;  \u0026lt;mvn:default-servlet-handler/\u0026gt;  \u0026lt;!--扫描包：controller--\u0026gt;  \u0026lt;context:component-scan base-package=\u0026#34;com.wzc.controller\u0026#34;/\u0026gt;  \u0026lt;!--视图解析器--\u0026gt;  \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026#34;\u0026gt;  \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/WEB-INF/jsp/\u0026#34;/\u0026gt;  \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.jsp\u0026#34;/\u0026gt;  \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; web.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34;  xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;  xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34;  version=\u0026#34;4.0\u0026#34;\u0026gt;  \u0026lt;!--DispatchServlet--\u0026gt;  \u0026lt;servlet\u0026gt;  \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt;  \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt;  \u0026lt;init-param\u0026gt;  \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt;  \u0026lt;param-value\u0026gt;classpath:applicationContext.xml\u0026lt;/param-value\u0026gt;  \u0026lt;/init-param\u0026gt;  \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt;  \u0026lt;/servlet\u0026gt;  \u0026lt;servlet-mapping\u0026gt;  \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt;  \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt;  \u0026lt;/servlet-mapping\u0026gt;   \u0026lt;!--乱码过滤--\u0026gt;  \u0026lt;filter\u0026gt;  \u0026lt;filter-name\u0026gt;encodingFilter\u0026lt;/filter-name\u0026gt;  \u0026lt;filter-class\u0026gt;org.springframework.web.filter.CharacterEncodingFilter\u0026lt;/filter-class\u0026gt;  \u0026lt;init-param\u0026gt;  \u0026lt;param-name\u0026gt;encoding\u0026lt;/param-name\u0026gt;  \u0026lt;param-value\u0026gt;utf-8\u0026lt;/param-value\u0026gt;  \u0026lt;/init-param\u0026gt;  \u0026lt;/filter\u0026gt;  \u0026lt;filter-mapping\u0026gt;  \u0026lt;filter-name\u0026gt;encodingFilter\u0026lt;/filter-name\u0026gt;  \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt;  \u0026lt;/filter-mapping\u0026gt;   \u0026lt;!--Session--\u0026gt;  \u0026lt;session-config\u0026gt;  \u0026lt;session-timeout\u0026gt;15\u0026lt;/session-timeout\u0026gt;  \u0026lt;/session-config\u0026gt; \u0026lt;/web-app\u0026gt; applicationContext.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34;  xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;  xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt;   \u0026lt;import resource=\u0026#34;classpath:spring-dao.xml\u0026#34;/\u0026gt;  \u0026lt;import resource=\u0026#34;classpath:spring-service.xml\u0026#34;/\u0026gt;  \u0026lt;import resource=\u0026#34;classpath:spring-mvc.xml\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; 6、拦截器 拦截器只会拦截controller中的方法，而不会拦截静态资源\n实现InterceptorHandler接口就可以自定义一个拦截器\n拦截器是AOP思想的具体应用\npublic class MyInterceptor implements HandlerInterceptor {  @Override  public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {  // return true为放行，return false为拦截  return HandlerInterceptor.super.preHandle(request, response, handler);  }   @Override  public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {  HandlerInterceptor.super.postHandle(request, response, handler, modelAndView);  }   @Override  public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {  HandlerInterceptor.super.afterCompletion(request, response, handler, ex);  } } \u0026lt;!--拦截器配置--\u0026gt; \u0026lt;mvc:interceptors\u0026gt;  \u0026lt;mvc:interceptor\u0026gt;  \u0026lt;mvc:mapping path=\u0026#34;/**\u0026#34;/\u0026gt;  \u0026lt;bean class=\u0026#34;com.wzc.config.MyInterceptor\u0026#34;/\u0026gt;  \u0026lt;/mvc:interceptor\u0026gt; \u0026lt;/mvc:interceptors\u0026gt; 未登录用户拦截\nmain.jsp\n\u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;首页\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;首页\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;${sessionScope.username}\u0026lt;/p\u0026gt; \u0026lt;a href=\u0026#34;${pageContext.request.contextPath}/user/logout\u0026#34;\u0026gt;注销\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; login.jsp\n\u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;登录\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form action=\u0026#34;${pageContext.request.contextPath}/user/login\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;label\u0026gt;用户名：\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34;\u0026gt; \u0026lt;label\u0026gt;密码：\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;pwd\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; LoginController\n@Controller @RequestMapping(\u0026#34;/user\u0026#34;) public class LoginController {  @GetMapping(\u0026#34;/main\u0026#34;)  public String main() {  return \u0026#34;main\u0026#34;;  }   @GetMapping(\u0026#34;/login\u0026#34;)  public String login() {  return \u0026#34;login\u0026#34;;  }   @PostMapping(\u0026#34;/login\u0026#34;)  public String login(Login login, HttpServletRequest request) {  request.getSession().setAttribute(\u0026#34;username\u0026#34;, login.getUsername());  return \u0026#34;main\u0026#34;;  }   @GetMapping(\u0026#34;/logout\u0026#34;)  public String logout(HttpServletRequest request) {  request.getSession().removeAttribute(\u0026#34;username\u0026#34;);  return \u0026#34;login\u0026#34;;  //如果要返回首页，需要写成return \u0026#34;redirect:/user/main\u0026#34;，否则需要点击两次注销才会被拦截  // 如果写成return \u0026#34;main\u0026#34;，返回的还是main.jsp，这时第一次点击注销时无法触发拦截器  } } LoginInterceptor\npublic class LoginInterceptor implements HandlerInterceptor {  @Override  public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {  //如果session中有username或者访问登录页面就放行  if (request.getSession().getAttribute(\u0026#34;username\u0026#34;) != null || request.getRequestURI().toLowerCase().contains(\u0026#34;login\u0026#34;)) {  return true;  }  request.getRequestDispatcher(\u0026#34;/WEB-INF/jsp/login.jsp\u0026#34;).forward(request, response);  return false;  } } 7、文件上传与下载 @RestController @RequestMapping(\u0026#34;/file\u0026#34;) public class FileController {  @PostMapping(\u0026#34;/upload\u0026#34;)  public String upload (@RequestParam(\u0026#34;file\u0026#34;)CommonsMultipartFile file, HttpServletRequest request) throws IOException {  String filename = file.getOriginalFilename();  if (StringUtils.isEmpty(filename)) {  return \u0026#34;redirect:/index.jsp\u0026#34;;  }  String path = request.getServletContext().getRealPath(\u0026#34;/upload\u0026#34;);  File filepath = new File(path);  if (!filepath.exists()) {  filepath.mkdirs();  }  //读写文件  try (InputStream inputStream = file.getInputStream();  FileOutputStream fileOutputStream = new FileOutputStream(new File(filepath, filename));) {  int len = 0;  byte[] buffer = new byte[1024];  while ((len = inputStream.read(buffer)) != -1) {  fileOutputStream.write(buffer, 0, len);  fileOutputStream.flush();  }  }  return \u0026#34;上传成功！\u0026#34;;  }   @PostMapping(\u0026#34;/upload1\u0026#34;)  public String upload1 (@RequestParam(\u0026#34;file\u0026#34;)CommonsMultipartFile file, HttpServletRequest request) throws IOException {   String path = request.getServletContext().getRealPath(\u0026#34;/upload\u0026#34;);  File filepath = new File(path);  if (!filepath.exists()) {  filepath.mkdirs();  }  //直接写文件  file.transferTo(new File(filepath + File.separator + file.getOriginalFilename()));  return \u0026#34;上传成功！\u0026#34;;  }   @RequestMapping(\u0026#34;download\u0026#34;)  public void download(HttpServletRequest request, HttpServletResponse response, String filename) throws UnsupportedEncodingException {  //设置response响应头  response.reset();  response.setCharacterEncoding(\u0026#34;UTF-8\u0026#34;);  response.setContentType(\u0026#34;multipart/form-data\u0026#34;);  response.setHeader(\u0026#34;Content-Disposition\u0026#34;, \u0026#34;attachment;fileName=\u0026#34; + URLEncoder.encode(filename, \u0026#34;UTF-8\u0026#34;));   File file = new File(request.getServletContext().getRealPath(\u0026#34;/upload\u0026#34;), filename);  try (FileInputStream fileInputStream = new FileInputStream(file);  ServletOutputStream outputStream = response.getOutputStream()) {  int len = 0;  byte[] buffer = new byte[1024];  while ((len = fileInputStream.read(buffer)) != -1) {  outputStream.write(buffer, 0, len);  outputStream.flush();  }  } catch (FileNotFoundException e) {  e.printStackTrace();  } catch (IOException e) {  e.printStackTrace();  }  } } ",
    "ref": "/post/springmvcnote/"
  },{
    "title": "Spring笔记",
    "date": "",
    "description": "",
    "body": "Spring学习笔记 1、介绍 1.1、导包 导入spring-webmvc和spring-jdbc\n\u0026lt;project\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;5.2.0.RELEASE\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;spring-jdbc\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;5.2.0.RELEASE\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt; \u0026lt;/project\u0026gt; 1.2、优点   开源免费\n  轻量级、非入侵式\n  控制反转（IOC）、面向切面编程（AOP）\n  支持事务处理，对框架整合的支持\n  总结：Spring就是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架\n1.3、组成 1.4、拓展 在Spring官网有这个介绍：现代化的java开发，就是基于Spring的开发\nSpring Boot：Build Anything\nSpring Cloud：Coordinate Anything\nSpring Cloud Data Flow：Connect Everything\n  Spring Boot\n 一个快速开发的脚手架 基于Spring Boot可以快速的开发单个微服务 约定大于配置    Spring Cloud\n Spring Cloud是基于Spring Boot实现的    弊端：发展了太久之后就违背了原来的理念，配置十分繁琐\n2、IOC理论推导   UserDao接口\n  UserDaoImpl实现类\n  UserService业务接口\n  UserServiceImpl业务实现类\n  在之前的业务中，用户的需求可能会影响原来的代码，需要根据需求修改源代码，如果代码量十分大，修改一次的成本十分昂贵\n使用一个Set接口实现，已经发生了革命性的变化\nprivate UserDao userDao; //利用set进行动态实现值的注入 public void setUserDao(UserDao userDao) { this.userDao = userDao; }  之前，程序是主动创建对象，控制权在程序员手上 使用了set注入后，程序不再具有主动性，而是变成了被动的接收对象  这种思想，从本质上解决了问题，程序员不再管理对象的创建，系统的耦合性大大降低，可以更加专注于业务的实现，这是IOC的原型\nIoC本质 控制反转IoC（Inversion of Control），是一种设计思想，DI（依赖注入）是实现IoC的一种方法。\n没有IoC的程序中，我们使用面向对象编程，对象的创建与对象间的依赖关系完全硬编程在程序中，对象的创建由程序自己控制 控制反转后将对象的创建转移给第三方，获得依赖对象的方式反转了。\n控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器， 其实现方法是依赖注入（Dependency Injection，DI）\n3、Hello Spring  控制：谁来控制对象的创建，传统应用程序的对象是由程序本身控制创建的，使用Spring后，对象是由Spring创建的 反转：程序本身不创建对象，而变成被动的接收对象 依赖注入：就是利用set方法来进行注入的 IoC是一种编程思想，由主动的编程变成被动的接收  4、IoC创建对象的方式  使用无参构造创建对象（默认） 如果要使用有参构造创建对象  下标赋值  \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.wzc.pojo.User\u0026#34;\u0026gt; \u0026lt;constructor-arg index=\u0026#34;0\u0026#34; value=\u0026#34;wzc\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 类型（不建议使用）  \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.wzc.pojo.User\u0026#34;\u0026gt; \u0026lt;constructor-arg type=\u0026#34;java.lang.String\u0026#34; value=\u0026#34;wzc\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 参数名  \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.wzc.pojo.User\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;name\u0026#34; value=\u0026#34;wzc\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   总结：在配置文件加载的时候，容器中管理的对象已经初始化了\n5、Spring配置 5.1、别名 \u0026lt;!--别名，可以通过别名获取对象--\u0026gt; \u0026lt;alias name=\u0026#34;user\u0026#34; alias=\u0026#34;userNew\u0026#34;/\u0026gt; 5.2、Bean的配置 \u0026lt;!--有参构造对象，name也可以取别名，可以取多个--\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.wzc.pojo.User\u0026#34; name=\u0026#34;user2, u2\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;name\u0026#34; value=\u0026#34;wzc\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 5.3、Import import一般用于团队开发，可以将多个配置文件，导入合并为一个\n如果项目中有多人开发，三个人使用不同的类开发，不同的类需要注册在不同的bean中， 可以利用import将所有人的beans.xml合并为一个总的，使用的时候，直接使用总的配置就可以\n6、依赖注入 6.1、构造器注入 前面已经说过\n6.2、Set方法注入【重点】  依赖注入：Set方法注入  依赖：bean对象的创建依赖于容器 注入：bean对象中的所有属性，由容器来注入 name属性值与类中的成员变量名以及set方法的参数名都无关, 只与对应的set方法名有关 如果通过set方法注入属性，那么Spring会通过默认的空参构造方法来实例化对象， 所以如果在类中写了一个带有参数的构造方法，一定要把空参数的构造方法写上， 否则spring没有办法实例化对象，导致报错。  \u0026lt;bean id=\u0026#34;address\u0026#34; class=\u0026#34;com.wzc.pojo.Address\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;address\u0026#34; value=\u0026#34;北京\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;student\u0026#34; class=\u0026#34;com.wzc.pojo.Student\u0026#34;\u0026gt; \u0026lt;!--普通值注入: Spring会将name值的每个单词首字母转换成大写, 然后再在前面拼接上\u0026#34;set\u0026#34;构成一个方法名, 然后去对应的类中查找该方法,通过反射调用,实现注入--\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;wzc\u0026#34;/\u0026gt; \u0026lt;!--Bean注入--\u0026gt; \u0026lt;property name=\u0026#34;address\u0026#34; ref=\u0026#34;address\u0026#34;/\u0026gt; \u0026lt;!--数组注入--\u0026gt; \u0026lt;property name=\u0026#34;books\u0026#34;\u0026gt; \u0026lt;array\u0026gt; \u0026lt;value\u0026gt;活着\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;平凡的世界\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;你当像鸟飞往你的山\u0026lt;/value\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--List注入--\u0026gt; \u0026lt;property name=\u0026#34;hobbies\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;看书\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;打篮球\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;听音乐\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--Map注入--\u0026gt; \u0026lt;property name=\u0026#34;cards\u0026#34;\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry key=\u0026#34;身份证\u0026#34; value=\u0026#34;110154158754582057\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;银行卡\u0026#34; value=\u0026#34;1111 2222 3333 4444\u0026#34;/\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--Set注入--\u0026gt; \u0026lt;property name=\u0026#34;games\u0026#34;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;value\u0026gt;穿越火线\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;NBA2KOL2\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;QQ飞车\u0026lt;/value\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--null值注入--\u0026gt; \u0026lt;property name=\u0026#34;wife\u0026#34;\u0026gt; \u0026lt;null/\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--Properties注入--\u0026gt; \u0026lt;property name=\u0026#34;info\u0026#34;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;prop key=\u0026#34;学号\u0026#34;\u0026gt;1725840658\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;性别\u0026#34;\u0026gt;男\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;邮箱\u0026#34;\u0026gt;194829422@qq.com\u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;   6.3、拓展方式注入 使用p命名和c命名空间注入\n 导入xml约束  xmlns:p=\u0026#34;http://www.springframework.org/schema/p\u0026#34; xmlns:c=\u0026#34;http://www.springframework.org/schema/c\u0026#34; 注入  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34;  xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;  xmlns:p=\u0026#34;http://www.springframework.org/schema/p\u0026#34;  xmlns:c=\u0026#34;http://www.springframework.org/schema/c\u0026#34;  xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt;   \u0026lt;!--p命名空间注入（无参构造，set方法注入），可以直接注入属性的值--\u0026gt;  \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.wzc.pojo.User\u0026#34; p:name=\u0026#34;wzc\u0026#34; p:age=\u0026#34;22\u0026#34;/\u0026gt;   \u0026lt;!--c命名空间注入（有参构造）--\u0026gt;  \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.wzc.pojo.User\u0026#34; c:name=\u0026#34;wzc\u0026#34; c:age=\u0026#34;22\u0026#34;/\u0026gt;  \u0026lt;/beans\u0026gt; 测试  public class UserTest {  public static void main(String[] args) {  ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;userbeans.xml\u0026#34;);  User user = context.getBean(\u0026#34;user\u0026#34;, User.class);  System.out.println(user.toString());  } } 6.4、Bean的作用域  单例模式（Spring默认机制）  \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.wzc.pojo.User\u0026#34; c:name=\u0026#34;wzc\u0026#34; c:age=\u0026#34;22\u0026#34; scope=\u0026#34;singleton\u0026#34;/\u0026gt; 原型模式：每次从容器中get的时候都会产生一个新对象  \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.wzc.pojo.User\u0026#34; c:name=\u0026#34;wzc\u0026#34; c:age=\u0026#34;22\u0026#34; scope=\u0026#34;prototype\u0026#34;/\u0026gt; 其余的request、session、application这些只能在web开发中使用到  7、Bean的自动装配  自动装配是Spring满足bean依赖的一种方式 Spring会在上下文中自动寻找，并装配属性  在Spring中有三种装配方式\n 在xml中显示装配 在java中显示装配 隐式的自动装配【重要】  7.1、byName自动装配 \u0026lt;bean id=\u0026#34;dog\u0026#34; class=\u0026#34;com.wzc.pojo.Dog\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;cat\u0026#34; class=\u0026#34;com.wzc.pojo.Cat\u0026#34;/\u0026gt; \u0026lt;!--byName会自动在容器上下文中查找bean的id前加上\u0026#34;set\u0026#34;和对应属性的set方法名称相同的bean进行自动注入--\u0026gt; \u0026lt;bean id=\u0026#34;person\u0026#34; class=\u0026#34;com.wzc.pojo.Person\u0026#34; autowire=\u0026#34;byName\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;wzc\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 7.2、byType自动装配 \u0026lt;bean id=\u0026#34;dog\u0026#34; class=\u0026#34;com.wzc.pojo.Dog\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;cat\u0026#34; class=\u0026#34;com.wzc.pojo.Cat\u0026#34;/\u0026gt; \u0026lt;!--byType会自动在容器上下文中查找bean的类型和该对象属性类型相同的bean进行自动注入（必须保证全局唯一）--\u0026gt; \u0026lt;bean id=\u0026#34;person\u0026#34; class=\u0026#34;com.wzc.pojo.Person\u0026#34; autowire=\u0026#34;byType\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;wzc\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 7.3、constructor自动装配 \u0026lt;bean id=\u0026#34;dog\u0026#34; class=\u0026#34;com.wzc.pojo.Dog\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;cat\u0026#34; class=\u0026#34;com.wzc.pojo.Cat\u0026#34;/\u0026gt; \u0026lt;!--通过构造方法进行自动注入，Spring会匹配与构造方法参数类型一致的bean进行注入， 如果构造方法参数没有完全匹配则注入失败--\u0026gt; \u0026lt;bean id=\u0026#34;person\u0026#34; class=\u0026#34;com.wzc.pojo.Person\u0026#34; autowire=\u0026#34;constructor\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;wzc\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 小结：\n byName的时候，需要保证所有bean的id唯一 byType的时候，需要保证所有bean的class唯一  7.4、使用注解实现自动装配 要使用注解须知：\n 导入约束：context约束 配置注解的支持  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34;  xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;  xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34;  xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt;   \u0026lt;context:annotation-config/\u0026gt;  \u0026lt;/beans\u0026gt; @Autowired注解\n直接在属性上使用即可，也可以在set方法上使用\n科普：\n@Nullable 字段标记这个注解后，说明这个字段可以为null //如果定义了@Autowired的require属性为false，说明这个对象可以为空 @Autowired(require = false) @Autowired默认使用byType方式注入，如果beans.xml中有多个type符合的bean， 则使用@Qualifier(value = \u0026ldquo;name\u0026rdquo;)注入id为name的bean\n@Autowired @Qualifier(value = \u0026#34;dog\u0026#34;) private Dog dog1; @Resource注解\n@Resource(name = \u0026#34;cat1\u0026#34;) private Cat cat; 小结： @Autowired和@Resource的区别：\n @Autowired默认按照byType方式装配 @Resource默认按照byName方式装配  8、使用注解开发 在Spring4之后，要使用注解开发，必须保证aop的包导入了\n使用注解需要导入context约束，增加注解的支持\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34;  xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;  xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34;  xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt;   \u0026lt;context:component-scan base-package=\u0026#34;com.wzc\u0026#34;/\u0026gt;  \u0026lt;context:annotation-config/\u0026gt;   \u0026lt;/beans\u0026gt;   bean\n@Component：表示组件，放在类上表示这个类被Spring管理\n  属性如何注入\n  @Component //等价于\u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.wzc.pojo.User\u0026#34;/\u0026gt; public class User {   @Value(\u0026#34;wzc\u0026#34;) //等价于\u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;wzc\u0026#34;/\u0026gt;  private String name;   public String getName() {  return name;  }   @Value(\u0026#34;wzc\u0026#34;) //等价于\u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;wzc\u0026#34;/\u0026gt;  public void setName(String name) {  this.name = name;  } }  衍生的注解\n@Component有几个衍生注解，我们在web开发中，会按照mvc三层架构分层\n dao：@Repository service：@Service controller：@Controller  这四个注解功能相同，代表将某个类注册到Spring容器中，装配bean\n  自动装配\n@Autowired\n@Resource\n  作用域\n@Scope(value = \u0026ldquo;prototype\u0026rdquo;)\n  小结\nxml与注解：\n xml更万能，适用于任何场合，维护简单方便 注解只能对当前类生效，维护相对复杂 xml一般用来管理bean，注解只负责属性的注入    9、使用java的方式配置Spring 所有配置由注解完成\n两种方法注入bean：\n @Component建立的对象通过getBean(\u0026ldquo;user\u0026rdquo;)获取 配置类中定义一个方法，使用@Bean注解声明，通过getBean(\u0026ldquo;getUser\u0026rdquo;)获取  实体类\n@Component() //第一种方法直接使用Component注解注入bean，通过getBean(\u0026#34;user\u0026#34;)来得到bean public class User {  @Value(\u0026#34;wzc\u0026#34;)  private String name;   public String getName() {  return name;  }   public void setName(String name) {  this.name = name;  }   @Override  public String toString() {  return \u0026#34;User{\u0026#34; +  \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; +  \u0026#39;}\u0026#39;;  } } 配置类\n@Configuration //@Configuration代表这是一个配置类(第二种方法) @ComponentScan(\u0026#34;com.wzc.pojo\u0026#34;) //自动扫描com.wzc.pojo下的bean进行注入，这里注入的是user(与第一种方法配合使用) public class UserConfig {   @Bean //注册一个Bean，相当于一个bean标签，这个方法的名字就是bean标签中的id，方法的返回值就是bean标签中的class，这里注入的是getUser  public User getUser() {  return new User();  } } 测试类\npublic class UserTest {  @Test  public void test1() {  //如果使用配置类注入，使用AnnotationConfigApplicationContext来获取容器  ApplicationContext context = new AnnotationConfigApplicationContext(UserConfig.class);  User user1 = context.getBean(\u0026#34;getUser\u0026#34;, User.class);  User user2 = context.getBean(\u0026#34;user\u0026#34;, User.class);  user1.setName(\u0026#34;test\u0026#34;);  System.out.println(user1);  System.out.println(user2);  System.out.println(user1 == user2); //user1和user2不是同一个对象  } } 这种纯java的配置方式在SpringBoot中随处可见\n10、代理模式 代理模式是SpringAOP的底层实现\n代理模式的分类：\n 静态代理 动态代理  10.1、静态代理 角色分析：\n 抽象角色：一般会使用接口或者抽象类来解决 (租房) 真实角色：被代理的角色 (房东) 代理角色：代理真实角色，代理真实角色后，会做一些附属操作 (中介) 客户：访问代理对象 (客户)  代理模式的好处：\n 可以使真实角色的操作更加纯粹，不用关注一些公共的业务 公共业务交给代理角色，实现了业务的分工 公共业务发生扩展的时候，方便集中管理  缺点：\n 一个真实角色就会产生一个代理角色，代码量会翻倍  接口 (租房)\n//租房 public interface Rent {   public void rent();  } 真实角色 (房东)\npublic class Host implements Rent {   @Override  public void rent() {  System.out.println(\u0026#34;房东要出租房子\u0026#34;);  } } 代理角色 (中介)\npublic class Proxy implements Rent {   //要代理的角色  private Host host;   public Proxy() {  }   public Proxy(Host host) {  this.host = host;  }   @Override  public void rent() {  lookHouse();  host.rent();  signContract();  fee();  }   /** * 看房(附属操作) */  public void lookHouse() {  System.out.println(\u0026#34;中介带领看房\u0026#34;);  }   /** * 签合同(附属操作) */  public void signContract() {  System.out.println(\u0026#34;签租赁合同\u0026#34;);  }   /** * 收中介费(附属操作) */  public void fee() {  System.out.println(\u0026#34;收中介费\u0026#34;);  }  } 客户端访问代理角色\npublic class Client {  public static void main(String[] args) {  //房东要租房子  Host host = new Host();  //代理中介帮房东租房子，代理会有一些附属操作  Proxy proxy = new Proxy(host);  //找中介租房子  proxy.rent();  } } 10.2、静态代理加深理解 接口\npublic interface UserService {  public void insert();   public void delete();   public void update();   public void select(); } 真实角色\npublic class UserServiceImpl implements UserService {  @Override  public void insert() {  System.out.println(\u0026#34;增加用户\u0026#34;);  }   @Override  public void delete() {  System.out.println(\u0026#34;删除用户\u0026#34;);  }   @Override  public void update() {  System.out.println(\u0026#34;修改用户\u0026#34;);  }   @Override  public void select() {  System.out.println(\u0026#34;查询用户\u0026#34;);  } } 代理角色\npublic class UserServiceProxy implements UserService {  private UserServiceImpl userService;   public void setUserService(UserServiceImpl userService) {  this.userService = userService;  }   @Override  public void insert() {  log(\u0026#34;insert\u0026#34;);  userService.insert();  }   @Override  public void delete() {  log(\u0026#34;delete\u0026#34;);  userService.delete();  }   @Override  public void update() {  log(\u0026#34;update\u0026#34;);  userService.update();  }   @Override  public void select() {  log(\u0026#34;select\u0026#34;);  userService.select();  }   //日志输出(附属方法)  public void log(String msg) {  System.out.println(\u0026#34;使用了\u0026#34; + msg + \u0026#34;方法\u0026#34;);  }  } 客户端\npublic class Client {  public static void main(String[] args) {  //真实角色  UserServiceImpl userService = new UserServiceImpl();   //代理角色(添加日至输出)  UserServiceProxy userServiceProxy = new UserServiceProxy();  userServiceProxy.setUserService(userService);   userServiceProxy.insert();  } } 10.3、动态代理  动态代理和静态代理角色一样 动态代理的代理类是自动生成的(通过反射)，不是直接写好的 动态代理分为两大类：基于接口的动态代理，基于类的动态代理  基于接口\u0026mdash;JDK动态代理 √ 基于类\u0026mdash;cglib java字节码实现\u0026mdash;javasist    需要了解两个类：Proxy：代理，InvocationHandler：调用处理程序\n接口\npublic interface UserService {  public void insert();   public void delete();   public void update();   public void select(); } 真实角色\npublic class UserServiceImpl implements UserService {  @Override  public void insert() {  System.out.println(\u0026#34;增加用户\u0026#34;);  }   @Override  public void delete() {  System.out.println(\u0026#34;删除用户\u0026#34;);  }   @Override  public void update() {  System.out.println(\u0026#34;修改用户\u0026#34;);  }   @Override  public void select() {  System.out.println(\u0026#34;查询用户\u0026#34;);  } } InvocationHandler动态代理\npublic class ProxyInvocationHandler implements InvocationHandler {  private Object target; //要代理的角色   public void setTarget(Object target) {  this.target = target;  }   /** * 生成代理类 */  public Object getProxy() {  return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(), this);  }   /** * 返回代理实例 */  @Override  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {  log(method.getName());  Object result = method.invoke(target, args);  return result;  }   /** * 附属方法：写日志 */  public void log(String msg) {  System.out.println(\u0026#34;执行了\u0026#34; + msg + \u0026#34;方法\u0026#34;);  }  } 客户端\npublic class Client {  public static void main(String[] args) {  //真实角色  UserServiceImpl userService = new UserServiceImpl();  //代理角色  ProxyInvocationHandler handler = new ProxyInvocationHandler();  //设置要代理的对象  handler.setTarget(userService);  //动态生成代理类  UserService proxy = (UserService) handler.getProxy();  proxy.insert();  } } 动态代理的好处：\n 可以使真实角色的操作更加纯粹，不用关注一些公共业务 公共业务交给代理角色，实现了业务的分工 公共业务发生扩展的时候方便集中管理 一个动态代理类代理的是一个接口，一般就是对应的一类业务 一个动态代理可以代理多个类，只要是实现了同一个接口即可  11、AOP 11.1、什么是AOP AOP（Aspect Oriented Programming）意为：面向切面编程， 通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。 AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容， 是函数式编程的一种衍生范型。利用AOP业务逻辑的各个部分进行隔离， 从而使得各部分逻辑之间的耦合度降低，提高程序的可重用性，同时提高了开发效率\n11.2、AOP在Spring中的作用 提供声明事务，允许用户自定义切面\n理解： 切面：包含要切入的具体方法的类\n通知：切面中的某个具体方法\n切入点：具体在哪个类哪个方法进行切入\n11.3、使用Spring实现AOP 导包\n\u0026lt;dependencies\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;1.9.4\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 方式一：使用Spring的接口 前置通知和后置通知\npublic class BeforeLog implements MethodBeforeAdvice {  /** * 方法执行前操作 * @param method 要执行的目标对象的方法 * @param objects 方法参数 * @param o 目标对象 * @throws Throwable */  @Override  public void before(Method method, Object[] objects, Object o) throws Throwable {  System.out.println(o.getClass().getName() + \u0026#34;的\u0026#34; + method.getName() + \u0026#34;被执行\u0026#34;);  } } public class AfterLog implements AfterReturningAdvice {  /** * 方法执行后操作 * @param o 返回值 * @param method 要执行的目标对象方法 * @param objects 方法参数 * @param o1 目标对象 * @throws Throwable */  @Override  public void afterReturning(Object o, Method method, Object[] objects, Object o1) throws Throwable {  System.out.println(\u0026#34;执行了\u0026#34; + method.getName() + \u0026#34;方法，返回结果为\u0026#34; + o);  } } 配置文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34;  xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;  xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34;  xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt;   \u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;com.wzc.service.UserServiceImpl\u0026#34;/\u0026gt;  \u0026lt;bean id=\u0026#34;beforeLog\u0026#34; class=\u0026#34;com.wzc.log.BeforeLog\u0026#34;/\u0026gt;  \u0026lt;bean id=\u0026#34;afterLog\u0026#34; class=\u0026#34;com.wzc.log.AfterLog\u0026#34;/\u0026gt;   \u0026lt;!--方式一：使用原生接口配置AOP--\u0026gt;  \u0026lt;aop:config\u0026gt;  \u0026lt;!--切入点：expression：表达式，execution(要执行的位置 包名.类名.方法名)--\u0026gt;  \u0026lt;aop:pointcut id=\u0026#34;pointcut\u0026#34; expression=\u0026#34;execution(* com.wzc.service.UserServiceImpl.*(..))\u0026#34;/\u0026gt;   \u0026lt;!--执行环绕增强--\u0026gt;  \u0026lt;aop:advisor advice-ref=\u0026#34;beforeLog\u0026#34; pointcut-ref=\u0026#34;pointcut\u0026#34;/\u0026gt;  \u0026lt;aop:advisor advice-ref=\u0026#34;afterLog\u0026#34; pointcut-ref=\u0026#34;pointcut\u0026#34;/\u0026gt;  \u0026lt;/aop:config\u0026gt;  \u0026lt;/beans\u0026gt; 方式二：自定义类来实现AOP 自定义类\npublic class CustomPointCut {  public void beforeMethod() {  System.out.println(\u0026#34;方法执行前\u0026#34;);  }   public void afterMethod() {  System.out.println(\u0026#34;方法执行后\u0026#34;);  } } 配置\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34;  xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;  xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34;  xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt;   \u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;com.wzc.service.UserServiceImpl\u0026#34;/\u0026gt;   \u0026lt;!--方式二：自定义类--\u0026gt;  \u0026lt;bean id=\u0026#34;customPointCut\u0026#34; class=\u0026#34;com.wzc.custom.CustomPointCut\u0026#34;/\u0026gt;   \u0026lt;aop:config\u0026gt;  \u0026lt;!--自定义切面--\u0026gt;  \u0026lt;aop:aspect ref=\u0026#34;customPointCut\u0026#34;\u0026gt;  \u0026lt;!--切入点--\u0026gt;  \u0026lt;aop:pointcut id=\u0026#34;pointcut\u0026#34; expression=\u0026#34;execution(* com.wzc.service.UserServiceImpl.*(..))\u0026#34;/\u0026gt;  \u0026lt;!--通知--\u0026gt;  \u0026lt;aop:before method=\u0026#34;beforeMethod\u0026#34; pointcut-ref=\u0026#34;pointcut\u0026#34;/\u0026gt;  \u0026lt;aop:after-returning method=\u0026#34;afterMethod\u0026#34; pointcut-ref=\u0026#34;pointcut\u0026#34;/\u0026gt;  \u0026lt;/aop:aspect\u0026gt;  \u0026lt;/aop:config\u0026gt;  \u0026lt;/beans\u0026gt; 方式三：使用注解实现AOP 切面类\n/** * 通过注解实现AOP */ @Aspect //标注这个类为一个切面 public class AnnotationPointCut {  @Before(\u0026#34;execution(* com.wzc.service.UserServiceImpl.*(..))\u0026#34;)  public void beforeMethod() {  System.out.println(\u0026#34;方法执行前\u0026#34;);  }   @AfterReturning(\u0026#34;execution(* com.wzc.service.UserServiceImpl.*(..))\u0026#34;)  public void afterMethod() {  System.out.println(\u0026#34;方法执行后\u0026#34;);  }   /** * 环绕增强中，可以通过ProceedingJoinPoint来获取处理切入的点 */  @Around(\u0026#34;execution(* com.wzc.service.UserServiceImpl.*(..))\u0026#34;)  public void aroundMethod(ProceedingJoinPoint joinPoint) throws Throwable {  System.out.println(\u0026#34;环绕前\u0026#34;);  System.out.println(\u0026#34;signature：\u0026#34; + joinPoint.getSignature()); //获得签名(方法名全称)  joinPoint.proceed(); //执行方法  System.out.println(\u0026#34;环绕后\u0026#34;);  } } 配置\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34;  xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;  xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34;  xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34;  xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt;   \u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;com.wzc.service.UserServiceImpl\u0026#34;/\u0026gt;   \u0026lt;!--方式三：注解实现AOP--\u0026gt;  \u0026lt;bean id=\u0026#34;annotationPointCut\u0026#34; class=\u0026#34;com.wzc.custom.AnnotationPointCut\u0026#34;/\u0026gt;  \u0026lt;!--开启注解支持--\u0026gt;  \u0026lt;aop:aspectj-autoproxy/\u0026gt;  \u0026lt;/beans\u0026gt; 12、整合Mybatis 步骤：\n 导入相关jar包  junit mybatis mysql spring相关 aop织入 mybatis-spring【new】   编写配置文件 测试  12.1、回忆Mybatis  编写实体类  @Data public class User {  private int id;  private String name;  private String pwd; } 编写核心配置文件  mybatis-config.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt;  \u0026lt;configuration\u0026gt;  \u0026lt;typeAliases\u0026gt;  \u0026lt;package name=\u0026#34;com.wzc.pojo\u0026#34;/\u0026gt;  \u0026lt;/typeAliases\u0026gt;   \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt;  \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt;  \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;\u0026gt;\u0026lt;/transactionManager\u0026gt;  \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt;  \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.jdbc.Driver\u0026#34;/\u0026gt;  \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mybatis?useUnicode=true\u0026amp;amp;characterEncoding=utf8\u0026amp;amp;useSSL=true\u0026amp;amp;serverTimezone=Asia/Shanghai\u0026#34;/\u0026gt;  \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt;  \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;123456\u0026#34;/\u0026gt;  \u0026lt;/dataSource\u0026gt;  \u0026lt;/environment\u0026gt;  \u0026lt;/environments\u0026gt;   \u0026lt;mappers\u0026gt;  \u0026lt;mapper class=\u0026#34;com.wzc.mapper.UserMapper\u0026#34;/\u0026gt;  \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt; pom.xml\n\u0026lt;build\u0026gt;  \u0026lt;resources\u0026gt;  \u0026lt;resource\u0026gt;  \u0026lt;directory\u0026gt;src/main/java\u0026lt;/directory\u0026gt;  \u0026lt;includes\u0026gt;  \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt;  \u0026lt;/includes\u0026gt;  \u0026lt;filtering\u0026gt;true\u0026lt;/filtering\u0026gt;  \u0026lt;/resource\u0026gt;  \u0026lt;/resources\u0026gt;  \u0026lt;/build\u0026gt; 编写接口  public interface UserMapper {  List\u0026lt;User\u0026gt; selectUser(); } 编写Mapper.xml  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt;  \u0026lt;mapper namespace=\u0026#34;com.wzc.mapper.UserMapper\u0026#34;\u0026gt;  \u0026lt;select id=\u0026#34;selectUser\u0026#34; resultType=\u0026#34;com.wzc.pojo.User\u0026#34;\u0026gt;  select * from mybatis.user;  \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 测试  public class UserTest {  @Test  public void test1() throws IOException {  String resources = \u0026#34;mybatis-config.xml\u0026#34;;  InputStream in = Resources.getResourceAsStream(resources);   SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(in);  SqlSession sqlSession = sessionFactory.openSession(true);   UserMapper mapper = sqlSession.getMapper(UserMapper.class);  List\u0026lt;User\u0026gt; userList = mapper.selectUser();  for (User user : userList) {  System.out.println(user);  }  } } 12.2、整合Mybatis  编写数据源配置  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34;  xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;  xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt;   \u0026lt;!--DataSource:使用Spring的数据源替换Mybatis的配置 c30p dbcp druid--\u0026gt;  \u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DriverManagerDataSource\u0026#34;\u0026gt;  \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;com.mysql.jdbc.Driver\u0026#34;/\u0026gt;  \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mybatis?useUnicode=true\u0026amp;amp;characterEncoding=utf8\u0026amp;amp;useSSL=true\u0026amp;amp;serverTimezone=Asia/Shanghai\u0026#34;/\u0026gt;  \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt;  \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;123456\u0026#34;/\u0026gt;  \u0026lt;/bean\u0026gt;   \u0026lt;!--sqlSessionFactory--\u0026gt;  \u0026lt;bean id=\u0026#34;sqlSessionFactory\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionFactoryBean\u0026#34;\u0026gt;  \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34;/\u0026gt;  \u0026lt;!--绑定Mybatis配置文件--\u0026gt;  \u0026lt;property name=\u0026#34;configLocation\u0026#34; value=\u0026#34;classpath:mybatis-config.xml\u0026#34;/\u0026gt;  \u0026lt;!--\u0026lt;property name=\u0026#34;typeAliases\u0026#34; value=\u0026#34;com.wzc.pojo.User\u0026#34;/\u0026gt;--\u0026gt;  \u0026lt;property name=\u0026#34;mapperLocations\u0026#34; value=\u0026#34;classpath:com/wzc/mapper/*.xml\u0026#34;/\u0026gt;  \u0026lt;/bean\u0026gt;   \u0026lt;!--sqlSession--\u0026gt;  \u0026lt;bean id=\u0026#34;sqlSession\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionTemplate\u0026#34;\u0026gt;  \u0026lt;!--只能用构造器注入，因为没有set方法--\u0026gt;  \u0026lt;constructor-arg name=\u0026#34;sqlSessionFactory\u0026#34; ref=\u0026#34;sqlSessionFactory\u0026#34;/\u0026gt;  \u0026lt;/bean\u0026gt;  \u0026lt;/beans\u0026gt; sqlSessionFactory  \u0026lt;!--sqlSessionFactory--\u0026gt; \u0026lt;bean id=\u0026#34;sqlSessionFactory\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionFactoryBean\u0026#34;\u0026gt;  \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34;/\u0026gt;  \u0026lt;!--绑定Mybatis配置文件--\u0026gt;  \u0026lt;property name=\u0026#34;configLocation\u0026#34; value=\u0026#34;classpath:mybatis-config.xml\u0026#34;/\u0026gt;  \u0026lt;!--\u0026lt;property name=\u0026#34;typeAliases\u0026#34; value=\u0026#34;com.wzc.pojo.User\u0026#34;/\u0026gt;--\u0026gt;  \u0026lt;property name=\u0026#34;mapperLocations\u0026#34; value=\u0026#34;classpath:com/wzc/mapper/*.xml\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; sqlSessionTemplate  \u0026lt;!--sqlSession--\u0026gt; \u0026lt;bean id=\u0026#34;sqlSession\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionTemplate\u0026#34;\u0026gt;  \u0026lt;!--只能用构造器注入，因为没有set方法--\u0026gt;  \u0026lt;constructor-arg name=\u0026#34;sqlSessionFactory\u0026#34; ref=\u0026#34;sqlSessionFactory\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 实现类，注入Spring  public class UserMapperImpl implements UserMapper {   //原来所有操作都使用sqlSession来执行，现在使用sqlSessionTemplate  private SqlSessionTemplate sqlSession;   public void setSqlSession(SqlSessionTemplate sqlSession) {  this.sqlSession = sqlSession;  }   @Override  public List\u0026lt;User\u0026gt; selectUser() {  return sqlSession.getMapper(UserMapper.class).selectUser();  } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34;  xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;  xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt;   \u0026lt;import resource=\u0026#34;spring-dao.xml\u0026#34;/\u0026gt;   \u0026lt;bean id=\u0026#34;userMapper\u0026#34; class=\u0026#34;com.wzc.mapper.UserMapperImpl\u0026#34;\u0026gt;  \u0026lt;property name=\u0026#34;sqlSession\u0026#34; ref=\u0026#34;sqlSession\u0026#34;/\u0026gt;  \u0026lt;/bean\u0026gt;  \u0026lt;/beans\u0026gt; 测试  public class UserTest {  @Test  public void test2() throws IOException {  ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;);  UserMapperImpl userMapper = context.getBean(\u0026#34;userMapper\u0026#34;, UserMapperImpl.class);  List\u0026lt;User\u0026gt; userList = userMapper.selectUser();  for (User user : userList) {  System.out.println(user);  }  } } 13、声明式事务 13.1、回顾事务  把一组业务当成一个业务来做，要么都成功，要么都失败 事务在开发中十分重要，涉及到数据的一致性问题  事务的ACID原则：\n 原子性 一致性 隔离性  多个业务可能操作同一个资源，防止数据损坏   持久性  事务一旦提交，无论系统发生什么问题，结果都不会再被影响，被持久化的写到存储器中    13.2、Spring中的事务管理  声明式事务：AOP 编程式事务：需要在代码中进行事务的管理  mapper\npublic class UserMapperImpl implements UserMapper {   //原来所有操作都使用sqlSession来执行，现在使用sqlSessionTemplate  private SqlSessionTemplate sqlSession;   public void setSqlSession(SqlSessionTemplate sqlSession) {  this.sqlSession = sqlSession;  }   @Override  public List\u0026lt;User\u0026gt; transaction() {  sqlSession.getMapper(UserMapper.class).insertUser(new User(2, \u0026#34;admin\u0026#34;, \u0026#34;admin123\u0026#34;));  sqlSession.getMapper(UserMapper.class).deleteUser(2);  return sqlSession.getMapper(UserMapper.class).selectUser();  }   @Override  public List\u0026lt;User\u0026gt; selectUser() {  return sqlSession.getMapper(UserMapper.class).selectUser();  }   @Override  public int insertUser(User user) {  return sqlSession.getMapper(UserMapper.class).insertUser(user);  }   @Override  public int deleteUser(int id) {  return sqlSession.getMapper(UserMapper.class).deleteUser(id);  } } 配置\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34;  xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;  xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34;  xmlns:tx=\u0026#34;http://www.springframework.org/schema/tx\u0026#34;  xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd\u0026#34;\u0026gt;   \u0026lt;!--DataSource:使用Spring的数据源替换Mybatis的配置 c30p dbcp druid--\u0026gt;  \u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DriverManagerDataSource\u0026#34;\u0026gt;  \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;com.mysql.jdbc.Driver\u0026#34;/\u0026gt;  \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mybatis?useUnicode=true\u0026amp;amp;characterEncoding=utf8\u0026amp;amp;useSSL=true\u0026amp;amp;serverTimezone=Asia/Shanghai\u0026#34;/\u0026gt;  \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt;  \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;123456\u0026#34;/\u0026gt;  \u0026lt;/bean\u0026gt;   \u0026lt;!--sqlSessionFactory--\u0026gt;  \u0026lt;bean id=\u0026#34;sqlSessionFactory\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionFactoryBean\u0026#34;\u0026gt;  \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34;/\u0026gt;  \u0026lt;!--mapper文件位置--\u0026gt;  \u0026lt;property name=\u0026#34;mapperLocations\u0026#34; value=\u0026#34;classpath:com/wzc/mapper/*.xml\u0026#34;/\u0026gt;  \u0026lt;/bean\u0026gt;   \u0026lt;!--sqlSession--\u0026gt;  \u0026lt;bean id=\u0026#34;sqlSession\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionTemplate\u0026#34;\u0026gt;  \u0026lt;!--只能用构造器注入，因为没有set方法--\u0026gt;  \u0026lt;constructor-arg name=\u0026#34;sqlSessionFactory\u0026#34; ref=\u0026#34;sqlSessionFactory\u0026#34;/\u0026gt;  \u0026lt;/bean\u0026gt;   \u0026lt;!--配置声明式事务--\u0026gt;  \u0026lt;bean id=\u0026#34;transactionManager\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DataSourceTransactionManager\u0026#34;\u0026gt;  \u0026lt;constructor-arg ref=\u0026#34;dataSource\u0026#34;/\u0026gt;  \u0026lt;/bean\u0026gt;   \u0026lt;!--结合AOP实现事务的织入--\u0026gt;  \u0026lt;!--配置事务通知--\u0026gt;  \u0026lt;tx:advice id=\u0026#34;txAdvice\u0026#34; transaction-manager=\u0026#34;transactionManager\u0026#34;\u0026gt;  \u0026lt;!--name: 给哪些方法配置事务，propagation: 配置事务的传播特性【new】--\u0026gt;  \u0026lt;tx:attributes\u0026gt;  \u0026lt;tx:method name=\u0026#34;selectUser\u0026#34; read-only=\u0026#34;true\u0026#34;/\u0026gt;  \u0026lt;tx:method name=\u0026#34;insertUser\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt;  \u0026lt;tx:method name=\u0026#34;updateUser\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt;  \u0026lt;tx:method name=\u0026#34;deleteUser\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt;  \u0026lt;tx:method name=\u0026#34;*\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt;  \u0026lt;/tx:attributes\u0026gt;  \u0026lt;/tx:advice\u0026gt;   \u0026lt;!--配置事务切入--\u0026gt;  \u0026lt;aop:config\u0026gt;  \u0026lt;aop:pointcut id=\u0026#34;txPrintCut\u0026#34; expression=\u0026#34;execution(* com.wzc.mapper.*.*(..))\u0026#34;/\u0026gt;  \u0026lt;aop:advisor advice-ref=\u0026#34;txAdvice\u0026#34; pointcut-ref=\u0026#34;txPrintCut\u0026#34;/\u0026gt;  \u0026lt;/aop:config\u0026gt;  \u0026lt;/beans\u0026gt; 测试\npublic class UserTest {  @Test  public void test1() {  ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;);  UserMapper userMapper = context.getBean(\u0026#34;userMapper\u0026#34;, UserMapper.class);  List\u0026lt;User\u0026gt; userList = userMapper.transaction();  for (User user : userList) {  System.out.println(user);  }  } } ",
    "ref": "/post/springnote/"
  },{
    "title": "Mybatis笔记",
    "date": "",
    "description": "",
    "body": "Mybatis 1、第一个Mybatis程序 1.1、搭建环境 搭建数据库：\nCREATE DATABASE `mybatis`;  USE `mybatis`;  CREATE TABLE `user` (  `id` INT(20) NOT NULL PRIMARY KEY,  `name` VARCHAR(30) DEFAULT NULL,  `pwd` VARCHAR(30) DEFAULT NULL )ENGINE = INNODB DEFAULT CHARSET = utf8; 新建项目：\n 新建一个maven项目 删除src目录 导入maven依赖  \u0026lt;dependencies\u0026gt;  \u0026lt;!--mysql驱动--\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;8.0.25\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;!--mybatis--\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;3.5.6\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;4.13\u0026lt;/version\u0026gt;  \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;1.18.22\u0026lt;/version\u0026gt;  \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt;  \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 1.2、创建一个模块  编写mybatis的核心配置文件  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;!--核心配置文件--\u0026gt; \u0026lt;configuration\u0026gt;  \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt;  \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt;  \u0026lt;!--事务管理--\u0026gt;  \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;\u0026gt;\u0026lt;/transactionManager\u0026gt;  \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt;  \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.jdbc.Driver\u0026#34;/\u0026gt;  \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mybatis?userSSL=true\u0026amp;amp;useUnicode=true\u0026amp;amp;characterEncoding=utf-8\u0026amp;amp;serverTimezone=GMT%2B8\u0026#34;/\u0026gt;  \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt;  \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;123456\u0026#34;/\u0026gt;  \u0026lt;/dataSource\u0026gt;  \u0026lt;/environment\u0026gt;  \u0026lt;/environments\u0026gt;   \u0026lt;!--每一个mapper.xml都需要在mybatis配置文件中注册--\u0026gt;  \u0026lt;mappers\u0026gt;  \u0026lt;mapper resource=\u0026#34;com/wzc/dao/UserMapper.xml\u0026#34;/\u0026gt;  \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt;  编写mybatis的工具类  //sqlSessionFactory --\u0026gt; sqlSession public class MybatisUtils {   private static SqlSessionFactory sqlSessionFactory;   static {  try {  //使用Mybatis获取sqlSessionFactory对象  String resource = \u0026#34;mybatis-config.xml\u0026#34;;  InputStream inputStream = Resources.getResourceAsStream(resource);  sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);  } catch (IOException e) {  e.printStackTrace();  }  }   public static SqlSession getSqlSession() {  return sqlSessionFactory.openSession();  }  } 1.3、编写代码  实体类  @Data @AllArgsConstructor @NoArgsConstructor public class User {  private int id;  private String name;  private String pwd; }  Dao接口  public interface UserDao {  List\u0026lt;User\u0026gt; userList(); }  mapper.xml  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt;  \u0026lt;mapper namespace=\u0026#34;com.wzc.dao.UserDao\u0026#34;\u0026gt;  \u0026lt;select id=\u0026#34;userList\u0026#34; resultType=\u0026#34;com.wzc.pojo.User\u0026#34;\u0026gt;  select * from user;  \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 1.4、测试 public class UserDaoTest {  @Test  public void test1() {  //获取sqlSession对象  SqlSession sqlSession = MybatisUtils.getSqlSession();   try {   //方法一：getMapper，推荐（不需要强转以及写错字符串）  UserDao mapper = sqlSession.getMapper(UserDao.class);  List\u0026lt;User\u0026gt; userList = mapper.userList();   //方法二：不推荐使用  //List\u0026lt;User\u0026gt; userList = sqlSession.selectList(\u0026#34;com.wzc.dao.UserDao.userList\u0026#34;);   for (User user : userList) {  System.out.println(user);  }   } finally {  //关闭sqlSession  sqlSession.close();  }  } } 2、CRUD 2.1 namespace namespace中的包名要和mapper接口的包名一致\n2.2、select 查询语句\n id：对应接口中的方法名 resultType：sql语句的返回值 parameterType：参数类型  \u0026lt;select id=\u0026#34;getUserById\u0026#34; parameterType=\u0026#34;int\u0026#34; resultType=\u0026#34;com.wzc.pojo.User\u0026#34;\u0026gt;  select * from user where id = #{id}; \u0026lt;/select\u0026gt; public class UserDaoTest {  @Test  public void userListTest() {  try (SqlSession sqlSession = MybatisUtils.getSqlSession()) {  UserDao mapper = sqlSession.getMapper(UserDao.class);  List\u0026lt;User\u0026gt; userList = mapper.userList();  for (User user : userList) {  System.out.println(user);  }  }  } } 2.3、insert \u0026lt;insert id=\u0026#34;addUser\u0026#34; parameterType=\u0026#34;com.wzc.pojo.User\u0026#34;\u0026gt;  insert into user (id, name, pwd) values (#{id}, #{name}, #{pwd}); \u0026lt;/insert\u0026gt; 2.4、update \u0026lt;update id=\u0026#34;updateUserById\u0026#34; parameterType=\u0026#34;com.wzc.pojo.User\u0026#34;\u0026gt;  update user set name = #{name}, pwd = #{pwd} where id = #{id}; \u0026lt;/update\u0026gt; 2.5、delete \u0026lt;delete id=\u0026#34;deleteUserById\u0026#34; parameterType=\u0026#34;int\u0026#34;\u0026gt;  delete from user where id = #{id}; \u0026lt;/delete\u0026gt; 注意点：\n 增删改操作都需要提交事务：sqlSession.commit();  3、万能Map 当实体类中字段过多时，应当考虑使用Map\npublic interface UserDao {  int addUserMap(Map\u0026lt;String, Object\u0026gt; user); } Map传递参数直接在sql中取出key即可\n4、模糊查询  传递带通配符的参数  public class UserDaoTest {  List\u0026lt;User\u0026gt; userList = mapper.getUserLikeName(\u0026#34;%i%\u0026#34;); } 在sql中拼接通配符  \u0026lt;select id=\u0026#34;getUserLikeName\u0026#34; resultType=\u0026#34;com.wzc.pojo.User\u0026#34;\u0026gt;  select * from user where name like concat(\u0026#39;%\u0026#39;, #{name}, \u0026#39;%\u0026#39;); \u0026lt;/select\u0026gt; 5、配置解析 5.1、核心配置文件  mybatis-config.xml  configuration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） 5.2、环境配置（environments） Mybatis可以配置成适应多种环境，但是尽管可以配置多种环境，每个SqlSessionFactory实例只能选择一种环境\nMybatis默认的事务管理器就是JDBC\n5.3、属性（properties） 属性可以外部配置和动态替换，既可以在java属性文件中配置，也可以使用properties子元素指定\n编写配置文件db.properties\ndriver=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/mybatis?userSSL=true\u0026amp;useUnicode=true\u0026amp;characterEncoding=utf-8\u0026amp;serverTimezone=GMT%2B8 #username=root #password=123456 在核心配置文件中引入\n\u0026lt;configuration\u0026gt;  \u0026lt;!--引入外部配置文件--\u0026gt;  \u0026lt;properties resource=\u0026#34;db.properties\u0026#34;\u0026gt;  \u0026lt;!--优先读取property属性指定的配置，然后才读取外部配置文件覆盖同名属性--\u0026gt;  \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt;  \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;123456\u0026#34;/\u0026gt;  \u0026lt;/properties\u0026gt; \u0026lt;/configuration\u0026gt; 优先读取property标签中的属性，然后读取外部配置文件中的属性并覆盖同名的属性\n5.4、类型别名（typeAliases）  类型别名是为java类型设置一个短的名字 存在的意义仅在于用来减少类完全限定名的冗余  \u0026lt;typeAliases\u0026gt;  \u0026lt;typeAlias type=\u0026#34;com.wzc.pojo.User\u0026#34; alias=\u0026#34;User\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; 也可以指定一个包名，Mybatis会在包名下面搜索需要的java bean，默认的别名为类名\n\u0026lt;typeAliases\u0026gt;  \u0026lt;!--\u0026lt;typeAlias type=\u0026#34;com.wzc.pojo.User\u0026#34; alias=\u0026#34;User\u0026#34;/\u0026gt;--\u0026gt;  \u0026lt;package name=\u0026#34;com.wzc.pojo\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; 5.5、设置（settings）  logImpl：指定Mybatis所用日志 cacheEnabled：全局开启或关闭缓存 lazyLoadingEnabled：全局懒加载开关  6、其他配置  typeHandler（类型处理器） objectFactory（类型工厂） plugins（插件）  mybatis-generator-core mybatis-plus 通用mapper    7、映射器（mappers） MapperRegistry：注册绑定Mapper文件\n方法一：【推荐使用】\n\u0026lt;!--每一个mapper.xml都需要在mybatis配置文件中注册--\u0026gt; \u0026lt;mappers\u0026gt;  \u0026lt;mapper resource=\u0026#34;com/wzc/mapper/UserMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; 方法二：使用class文件绑定注册\n\u0026lt;mappers\u0026gt;  \u0026lt;mapper class=\u0026#34;com.wzc.mapper.UserMapper\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; 注意点：\n 接口和Mapper配置文件必须同名 接口和Mapper配置文件必须在同一个包下  方法三：使用扫描包进行注入\n注意点和方法二一样\n\u0026lt;mappers\u0026gt;  \u0026lt;package name=\u0026#34;com.wzc.mapper\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; 8、生命周期和作用域 生命周期和作用域是重要的，因为错误的使用会导致严重的并发问题\nSqlSessionFactoryBuilder：\n 一旦创建了SqlSessionFactory，就不再需要SqlSessionFactoryBuilder 局部变量  SqlSessionFactory：\n 可以理解为数据库连接池 一旦创建就应该在程序运行期间一直存在， 没有理由丢弃或重新创建一个实例（单例模式或静态单例模式实现） SqlSessionFactory的最佳作用域是应用作用域  SqlSession：\n 可以理解为连接池的一个请求 SqlSession实例不是线程安全的，所以不能被共享，最佳作用域是请求或方法作用域 用完之后需要关闭，释放资源  9、resultMap 结果集映射，解决数据库字段名与实体类属性名称不一致的问题\n\u0026lt;resultMap id=\u0026#34;UserMap\u0026#34; type=\u0026#34;User\u0026#34;\u0026gt;  \u0026lt;!--column：数据库中的字段，property：实体类中的属性--\u0026gt;  \u0026lt;result column=\u0026#34;id\u0026#34; property=\u0026#34;id\u0026#34;/\u0026gt;  \u0026lt;result column=\u0026#34;name\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt;  \u0026lt;result column=\u0026#34;pwd\u0026#34; property=\u0026#34;password\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; 10、日志 10.1、日志工厂 Mybatis的settings中提供了日志配置的设置logImpl 支持的选项有：\n SLF4J LOG4J【掌握】 LOG4J2 JDK_LOGGING COMMONS_LOGGING STDOUT_LOGGING【掌握】 NO_LOGGING  STDOUT_LOGGING标准日志输出：\n\u0026lt;settings\u0026gt;  \u0026lt;setting name=\u0026#34;logImpl\u0026#34; value=\u0026#34;STDOUT_LOGGING\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt; 6.2、Log4j  先导入log4j的包  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;org.apache.logging.log4j\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;log4j-core\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;2.17.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; log4j.properties  # 将等级为DEBUG的日志输出到console和file这两个目的地 log4j.rootLogger=DEBUG,console # ,file # 控制台输出相关设置 log4j.appender.console=org.apache.log4j.ConsoleAppender log4j.appender.console.Target=System.out log4j.appender.console.Threshold=DEBUG log4j.appender.console.layout=org.apache.log4j.PatternLayout log4j.appender.console.layout.ConversionPattern=[%c]-%m%n # 文件输出相关设置 # log4j.appender.file=org.apache.log4j.RollingFileAppender # log4j.appender.file.File=输出文件路径 # log4j.appender.file.MaxFileSize=最大文件大小 # log4j.appender.file.Threshold=DEBUG # log4j.appender.console.layout=org.apache.log4j.PatternLayout # log4j.appender.console.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n # 日志输出级别 log4j.logger.org.mybatis=DEBUG log4j.logger.java.sql=DEBUG log4j.logger.java.sql.Statement=DEBUG log4j.logger.java.sql.ResultSet=DEBUG log4j.logger.java.sql.PreparedStatement=DEBUG 配置log4j日志实现  \u0026lt;settings\u0026gt;  \u0026lt;setting name=\u0026#34;logImpl\u0026#34; value=\u0026#34;LOG4J\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt; 简单使用\n 导入org.apache.log4j.Logger 获取日志对象  static Logger logger = Logger.getLogger(UserMapperTest.class); 日志级别  logger.info(\u0026#34;info: 进入了test2\u0026#34;); logger.debug(\u0026#34;debug: 进入了test2\u0026#34;); logger.error(\u0026#34;error: 进入了test2\u0026#34;); 7、分页 7.1、使用limit分页 select * from user limit startIndex, pageSize; 使用Mybatis实现分页，核心为sql\n 接口  List\u0026lt;User\u0026gt; userPage(Map\u0026lt;String, Integer\u0026gt; condition); Mapper.xml  \u0026lt;select id=\u0026#34;userPage\u0026#34; parameterType=\u0026#34;map\u0026#34; resultMap=\u0026#34;UserMap\u0026#34;\u0026gt;  select * from user limit #{startIndex}, #{pageSize}; \u0026lt;/select\u0026gt; 测试  @Test public void userPageTest() {  try (SqlSession sqlSession = MybatisUtil.getSqlSession()) {  UserMapper mapper = sqlSession.getMapper(UserMapper.class);  Map\u0026lt;String, Integer\u0026gt; condition = new HashMap\u0026lt;\u0026gt;();  condition.put(\u0026#34;startIndex\u0026#34;, 1);  condition.put(\u0026#34;pageSize\u0026#34;, 2);  List\u0026lt;User\u0026gt; userList = mapper.userPage(condition);  for (User user : userList) {  System.out.println(user);  }  } } 7.2、RowBounds分页【不推荐使用】  接口  List\u0026lt;User\u0026gt; userRowBounds(); mapper.xml  \u0026lt;select id=\u0026#34;userRowBounds\u0026#34; resultMap=\u0026#34;UserMap\u0026#34;\u0026gt;  select * from user; \u0026lt;/select\u0026gt; 测试  @Test public void userRowBoundsTest() {  try (SqlSession sqlSession = MybatisUtil.getSqlSession()) {  List\u0026lt;User\u0026gt; userList = sqlSession.selectList(\u0026#34;com.wzc.mapper.UserMapper.userRowBounds\u0026#34;, null, new RowBounds(1, 2));  for (User user : userList) {  System.out.println(user);  }  } } 7.3、分页插件 pageHelper：https://pagehelper.github.io/docs/howtouse/\n8、使用注解开发  接口  public interface UserMapper {  @Select(\u0026#34;select * from user\u0026#34;)  List\u0026lt;User\u0026gt; userList(); } 配置文件中绑定接口  \u0026lt;mappers\u0026gt;  \u0026lt;mapper class=\u0026#34;com.wzc.mapper.UserMapper\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; Mybatis实现流程\n8.1、注解CRUD public interface UserMapper {  @Select(\u0026#34;select * from user\u0026#34;)  List\u0026lt;User\u0026gt; userList();   //方法存在多个参数时，所有参数前面必须加上@Param注解  @Select(\u0026#34;select id, name, pwd as password from user where id = #{id}\u0026#34;)  User getUserById(@Param(\u0026#34;id\u0026#34;) int id);   @Insert(\u0026#34;insert into user(id, name, pwd) values(#{id}, #{name}, #{password})\u0026#34;)  int addUser(User user);   @Update(\u0026#34;update user set name = #{name}, pwd = #{password} where id = #{id}\u0026#34;)  int updateUser(User user);   @Delete(\u0026#34;delete from user where id = #{id}\u0026#34;)  int deleteUser(@Param(\u0026#34;id\u0026#34;) int id); } 【注意：必须将接口绑定到配置文件中】\n关于@Param注解\n 基本类型或String类型需要添加@Param注解，引用类型不需要添加  9、Lombok  安装插件 导入jar包  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;1.18.22\u0026lt;/version\u0026gt;  \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 在实体类上加注解  10、多对一处理 CREATE TABLE `teacher`(  `id` INT(10) NOT NULL,  `name` VARCHAR(30) DEFAULT NULL,  PRIMARY KEY (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8;  INSERT INTO `teacher`(`id`, `name`) VALUES (1, \u0026#39;张老师\u0026#39;);  CREATE TABLE `student` (  `id` INT(10) NOT NULL,  `name` varchar(30) DEFAULT NULL,  `tid` INT(10) DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `fktid` (`tid`),  CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8;  INSERT INTO `student` (`id`, `name`, `tid`) VALUES (1, \u0026#39;小明\u0026#39;, 1); INSERT INTO `student` (`id`, `name`, `tid`) VALUES (2, \u0026#39;小李\u0026#39;, 1); INSERT INTO `student` (`id`, `name`, `tid`) VALUES (3, \u0026#39;小赵\u0026#39;, 1); INSERT INTO `student` (`id`, `name`, `tid`) VALUES (4, \u0026#39;小王\u0026#39;, 1); 10.1、按照查询嵌套处理（子查询） \u0026lt;mapper namespace=\u0026#34;com.wzc.mapper.StudentMapper\u0026#34;\u0026gt;  \u0026lt;resultMap id=\u0026#34;studentTeacher\u0026#34; type=\u0026#34;Student\u0026#34;\u0026gt;  \u0026lt;result property=\u0026#34;id\u0026#34; column=\u0026#34;id\u0026#34;/\u0026gt;  \u0026lt;result property=\u0026#34;name\u0026#34; column=\u0026#34;name\u0026#34;/\u0026gt;  \u0026lt;!--对象：association，集合：collection--\u0026gt;  \u0026lt;association property=\u0026#34;teacher\u0026#34; column=\u0026#34;tid\u0026#34; javaType=\u0026#34;Teacher\u0026#34; select=\u0026#34;selectTeacher\u0026#34;/\u0026gt;  \u0026lt;/resultMap\u0026gt;  \u0026lt;select id=\u0026#34;studentList\u0026#34; resultMap=\u0026#34;studentTeacher\u0026#34;\u0026gt;  select * from student  \u0026lt;/select\u0026gt;  \u0026lt;select id=\u0026#34;selectTeacher\u0026#34; resultType=\u0026#34;Teacher\u0026#34;\u0026gt;  select * from teacher where id = #{tid}  \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 10.2、按照结果嵌套处理（联表查询） \u0026lt;mapper\u0026gt;  \u0026lt;resultMap id=\u0026#34;studentTeacher\u0026#34; type=\u0026#34;Student\u0026#34;\u0026gt;  \u0026lt;result property=\u0026#34;id\u0026#34; column=\u0026#34;sid\u0026#34;/\u0026gt;  \u0026lt;result property=\u0026#34;name\u0026#34; column=\u0026#34;sname\u0026#34;/\u0026gt;  \u0026lt;association property=\u0026#34;teacher\u0026#34; javaType=\u0026#34;Teacher\u0026#34;\u0026gt;  \u0026lt;result property=\u0026#34;id\u0026#34; column=\u0026#34;tid\u0026#34;/\u0026gt;  \u0026lt;result property=\u0026#34;name\u0026#34; column=\u0026#34;tname\u0026#34;/\u0026gt;  \u0026lt;/association\u0026gt;  \u0026lt;/resultMap\u0026gt;  \u0026lt;select id=\u0026#34;studentList\u0026#34; resultMap=\u0026#34;studentTeacher\u0026#34;\u0026gt;  select s.id sid, s.name sname, t.id tid, t.name tname from student s left join teacher t on t.id = s.tid  \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 11、一对多处理 一个老师教多个学生\n11.1、按结果嵌套（联表查询） \u0026lt;mapper namespace=\u0026#34;com.wzc.mapper.TeacherMapper\u0026#34;\u0026gt;  \u0026lt;!--按结果嵌套--\u0026gt;  \u0026lt;resultMap id=\u0026#34;teacherStudent\u0026#34; type=\u0026#34;Teacher\u0026#34;\u0026gt;  \u0026lt;result property=\u0026#34;id\u0026#34; column=\u0026#34;tid\u0026#34;/\u0026gt;  \u0026lt;result property=\u0026#34;name\u0026#34; column=\u0026#34;tname\u0026#34;/\u0026gt;  \u0026lt;collection property=\u0026#34;students\u0026#34; ofType=\u0026#34;Student\u0026#34;\u0026gt;  \u0026lt;result property=\u0026#34;id\u0026#34; column=\u0026#34;sid\u0026#34;/\u0026gt;  \u0026lt;result property=\u0026#34;name\u0026#34; column=\u0026#34;sname\u0026#34;/\u0026gt;  \u0026lt;result property=\u0026#34;tid\u0026#34; column=\u0026#34;stid\u0026#34;/\u0026gt;  \u0026lt;/collection\u0026gt;  \u0026lt;/resultMap\u0026gt;  \u0026lt;select id=\u0026#34;getTeacher\u0026#34; resultMap=\u0026#34;teacherStudent\u0026#34;\u0026gt;  select t.id tid, t.name tname, s.id sid, s.name sname, s.tid stid from teacher t left join student s on t.id = s.tid where t.id = #{id}  \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 11.2、按查询嵌套 \u0026lt;mapper\u0026gt;  \u0026lt;resultMap id=\u0026#34;teacherStudent\u0026#34; type=\u0026#34;Teacher\u0026#34;\u0026gt;  \u0026lt;result property=\u0026#34;id\u0026#34; column=\u0026#34;id\u0026#34;/\u0026gt;  \u0026lt;result property=\u0026#34;name\u0026#34; column=\u0026#34;name\u0026#34;/\u0026gt;  \u0026lt;collection property=\u0026#34;students\u0026#34; column=\u0026#34;id\u0026#34; javaType=\u0026#34;ArrayList\u0026#34; ofType=\u0026#34;Student\u0026#34; select=\u0026#34;studentList\u0026#34;/\u0026gt;  \u0026lt;/resultMap\u0026gt;  \u0026lt;select id=\u0026#34;getTeacher\u0026#34; resultMap=\u0026#34;teacherStudent\u0026#34;\u0026gt;  select * from teacher where id = #{id}  \u0026lt;/select\u0026gt;  \u0026lt;select id=\u0026#34;studentList\u0026#34; resultType=\u0026#34;Student\u0026#34;\u0026gt;  select * from student where tid = #{id}  \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 11.3、小结  关联-association【多对一】 集合-collection【一对多】 javaType：用来指定实体类中属性的类型 ofType：用来指定泛型的类型 注意点：  保证sql的可读性 多对一和一对多中，属性名和字段的问题    12、动态SQL 动态SQL就是根据不同的条件生成不同的SQL语句\nCREATE TABLE `blog` (  `id` bigint NOT NULL COMMENT \u0026#39;博客id\u0026#39;,  `title` varchar(100) NOT NULL COMMENT \u0026#39;博客标题\u0026#39;,  `author` varchar(30) NOT NULL COMMENT \u0026#39;博客作者\u0026#39;,  `create_time` datetime NOT NULL COMMENT \u0026#39;创建时间\u0026#39;,  `views` int NOT NULL COMMENT \u0026#39;浏览量\u0026#39; ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 实体类\n@Data public class Blog {  private int id;  private String title;  private String author;  private Date createTime;  private int views; } 12.1、IF标签 \u0026lt;select id=\u0026#34;blogListByIf\u0026#34; parameterType=\u0026#34;Map\u0026#34; resultType=\u0026#34;Blog\u0026#34;\u0026gt;  select * from blog  \u0026lt;where\u0026gt;  \u0026lt;if test=\u0026#34;title != null\u0026#34;\u0026gt;  and title like concat(\u0026#34;%\u0026#34;, #{title}, \u0026#34;%\u0026#34;)  \u0026lt;/if\u0026gt;  \u0026lt;if test=\u0026#34;author != null\u0026#34;\u0026gt;  /*从第二个if开始必须要加and*/  and author like concat(\u0026#34;%\u0026#34;, #{author}, \u0026#34;%\u0026#34;)  \u0026lt;/if\u0026gt;  \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; 12.2、choose（when, otherwise） 类似switch-case\n\u0026lt;select id=\u0026#34;blogListByChoose\u0026#34; parameterType=\u0026#34;Map\u0026#34; resultType=\u0026#34;Blog\u0026#34;\u0026gt;  select * from blog  \u0026lt;where\u0026gt;  \u0026lt;choose\u0026gt;  \u0026lt;when test=\u0026#34;title != null\u0026#34;\u0026gt;  /*当一个choose前还有choose标签的时候第一个条件也要加and*/  and title like concat(\u0026#34;%\u0026#34;, #{title}, \u0026#34;%\u0026#34;)  \u0026lt;/when\u0026gt;  \u0026lt;when test=\u0026#34;author != null\u0026#34;\u0026gt;  and author like concat(\u0026#34;%\u0026#34;, #{author}, \u0026#34;%\u0026#34;)  \u0026lt;/when\u0026gt;  \u0026lt;otherwise\u0026gt;  /*前面都不执行时会执行otherwise*/  and views \u0026gt;= 1000  \u0026lt;/otherwise\u0026gt;  \u0026lt;/choose\u0026gt;  \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; 12.3、trim（where, set） \u0026lt;update id=\u0026#34;updateBlog\u0026#34; parameterType=\u0026#34;Blog\u0026#34;\u0026gt;  update blog  \u0026lt;set\u0026gt;  \u0026lt;if test=\u0026#34;title != null\u0026#34;\u0026gt;  title = #{title},  \u0026lt;/if\u0026gt;  \u0026lt;if test=\u0026#34;author != null\u0026#34;\u0026gt;  author = #{author},  \u0026lt;/if\u0026gt;  \u0026lt;/set\u0026gt;  where id = #{id} \u0026lt;/update\u0026gt; SQL片段\n 使用sql标签抽取公共的sql  \u0026lt;sql id=\u0026#34;ifSql\u0026#34;\u0026gt;  \u0026lt;if test=\u0026#34;title != null\u0026#34;\u0026gt;  and title like concat(\u0026#34;%\u0026#34;, #{title}, \u0026#34;%\u0026#34;)  \u0026lt;/if\u0026gt;  \u0026lt;if test=\u0026#34;author != null\u0026#34;\u0026gt;  /*从第二个if开始必须要加and*/  and author like concat(\u0026#34;%\u0026#34;, #{author}, \u0026#34;%\u0026#34;)  \u0026lt;/if\u0026gt; \u0026lt;/sql\u0026gt; 在需要的地方使用include引用  \u0026lt;select id=\u0026#34;blogListByIf\u0026#34; parameterType=\u0026#34;Map\u0026#34; resultType=\u0026#34;Blog\u0026#34;\u0026gt;  select * from blog  \u0026lt;where\u0026gt;  \u0026lt;include refid=\u0026#34;ifSql\u0026#34;\u0026gt;\u0026lt;/include\u0026gt;  \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; 注意点：\n 最好基于单表定义sql片段 不要存在where标签  12.4、foreach collection：要遍历集合的参数名 item：遍历项 open：起始追加 close：结尾追加 separate：分隔符\n\u0026lt;select id=\u0026#34;blogListByForeach\u0026#34; parameterType=\u0026#34;List\u0026#34; resultType=\u0026#34;Blog\u0026#34;\u0026gt;  select * from blog where  \u0026lt;foreach collection=\u0026#34;ids\u0026#34; item=\u0026#34;id\u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34; separator=\u0026#34;or\u0026#34;\u0026gt;  id = #{id}  \u0026lt;/foreach\u0026gt; \u0026lt;/select\u0026gt; 13、Mybatis缓存  Mybatis系统中定义了两级缓存：一级和二级缓存 默认情况下，只有一级缓存开启（sqlSession级别的缓存，也称为本地缓存） 二级缓存需要配置开启，也可以通过实现Cache接口实现（namespace级别的缓存，也称为全局缓存）  13.1、一级缓存 public class UserMapperTest {  @Test  public void test1() {  try (SqlSession sqlSession = MybatisUtil.getSqlSession()) {  /*一级缓存：sqlSession级别，第二次查询时从缓存中取结果，两次查询的结果相同*/  UserMapper mapper = sqlSession.getMapper(UserMapper.class);  User user1 = mapper.getUserById(1);  User user2 = mapper.getUserById(1);  System.out.println(user1);  System.out.println(user2);  System.out.println(user1 == user2);  }  } } 缓存失效情况：\n 增删改操作，可能会改变数据，所以会刷新缓存 查询不同的sql 查询不同的mapper 手动清除缓存（sqlSession.clearCache()）  小结：一级缓存是默认开启的，只在一次sqlSession中有效\n13.2、二级缓存 二级缓存工作机制：\n 当一次会话关闭后，一级缓存中的数据会被保存到二级缓存中，新会话从二级缓存中获取数据 不同的mapper对应不同的二级缓存  使用步骤：\n 开启二级缓存（默认就是开启的）  \u0026lt;!--开启二级缓存--\u0026gt; \u0026lt;setting name=\u0026#34;cacheEnabled\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; mapper.xml中添加cache标签  \u0026lt;!--在当前mapper中使用二级缓存，FIFO策略，每60秒刷新缓存，缓存空间大小512，只读--\u0026gt; \u0026lt;cache eviction=\u0026#34;FIFO\u0026#34; flushInterval=\u0026#34;60000\u0026#34; size=\u0026#34;512\u0026#34; readOnly=\u0026#34;true\u0026#34;/\u0026gt; 测试  public class UserMapperTest {  @Test  public void test2() {  try (SqlSession sqlSession1 = MybatisUtil.getSqlSession();  SqlSession sqlSession2 = MybatisUtil.getSqlSession()) {  UserMapper mapper1 = sqlSession1.getMapper(UserMapper.class);  UserMapper mapper2 = sqlSession2.getMapper(UserMapper.class);  User user1 = mapper1.getUserById(1);  System.out.println(user1);  sqlSession1.close();  /*一级缓存关闭后，其中的数据会保存到二级缓存，再次查询从二级缓存中获取数据*/  User user2 = mapper2.getUserById(1);  System.out.println(user2);  System.out.println(user1 == user2);  }  } } 注意： 实体类需要实现Serializable接口序列化，否则会报NotSerializableException\n13.3、缓存原理  先看二级缓存中有没有 再看一级缓存中有没有 查询数据库   13.6、自定义缓存ehcache Ehcache是一种广泛使用的开源java分布式缓存，主要面向通用缓存\n 导包  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;org.mybatis.caches\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;mybatis-ehcache\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;1.2.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 配置文件指定使用ehcache  \u0026lt;cache type=\u0026#34;org.mybatis.caches.ehcache.EhcacheCache\u0026#34;/\u0026gt; 编写ehcache的配置文件  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;ehcache xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;  xsi:noNamespaceSchemaLocation=\u0026#34;http://ehcache.org/ehcache.xsd\u0026#34;  updateCheck=\u0026#34;false\u0026#34;\u0026gt;  \u0026lt;diskStore path=\u0026#34;./tmpdir/Tmp_EhCache\u0026#34;/\u0026gt;   \u0026lt;defaultCache  eternal=\u0026#34;false\u0026#34;  maxElementsInMemory=\u0026#34;10000\u0026#34;  overflowToDisk=\u0026#34;false\u0026#34;  diskPersistent=\u0026#34;false\u0026#34;  timeToIdleSeconds=\u0026#34;1800\u0026#34;  timeToLiveSeconds=\u0026#34;259200\u0026#34;  memoryStoreEvictionPolicy=\u0026#34;LRU\u0026#34;/\u0026gt;   \u0026lt;cache  name=\u0026#34;cloud_user\u0026#34;  eternal=\u0026#34;false\u0026#34;  maxElementsInMemory=\u0026#34;5000\u0026#34;  overflowToDisk=\u0026#34;false\u0026#34;  diskPersistent=\u0026#34;false\u0026#34;  timeToIdleSeconds=\u0026#34;1800\u0026#34;  timeToLiveSeconds=\u0026#34;1800\u0026#34;  memoryStoreEvictionPolicy=\u0026#34;LRU\u0026#34;/\u0026gt; \u0026lt;/ehcache\u0026gt; ",
    "ref": "/post/mybatisnote/"
  },{
    "title": "我的第一篇博客",
    "date": "",
    "description": "",
    "body": "我的第一篇博客\n",
    "ref": "/post/myfirstblog/"
  }]
