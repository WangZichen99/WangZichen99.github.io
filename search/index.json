[{"content":"《小狗钱钱》读书笔记 前言  并非困难使我们放弃，而是因为我们放弃，才显得困难。\n 第一章 白色的拉布拉多犬  你自己必须真的有‘想要变得富有’这个愿望，所以你必须找到10个‘想要变得富有’的理由。\n 明确目标，找到支持你继续下去的动力。否则你可能过几天新鲜感消失之后，又会回到以前的生活轨迹上。\n第二章 梦想储蓄罐和梦想相册  第一，我建议你拿一本相册作为你的梦想相册。\n如果你只是抱着试试看的心态，那么你只会以失败告终，你会一事无成。‘尝试’纯粹是一种借口，你还没有做，就已经给自己想好了退路。不能试验，你只有两个选择——做或者不做。\n第二件你可以做的事，就是每天看几遍相册。成功的人之所以成功，就是因为他们一直梦想着自己成功的那一天，不停地想象着自己实现了理想时的情形。\n第三件事就是准备一个梦想储蓄罐，定期往里面放一些钱，直到足够完成梦想。\n 如果你有一个梦想，你需要时常关注你的梦想，给自己鼓励，并坚持为梦想努力付出直到梦想实现，这就是梦想储蓄罐和梦想相册的作用。太多人知道了做法之后没有实际行动，就像上面说的：你只有两个选择——做或者不做。\n第三章 达瑞，一个很会挣钱的男孩  你的自信程度决定了你是否相信自己的能力，是否相信你自己。假如你根本不相信你能做到的话，那么你就根本不会动手去做，而假如你不开始去做，那么你就什么也得不到。\n准备一个本子，给它取名叫‘成功日记’，然后把所有做成功的事情记录进去。你最好每天都做这件事，每次都写至少5条你的个人成果，任何小事都可以。开始的时候也许你觉得不太容易，可能会问自己，这件或那件事情是否真的可以算作成果。在这种情况下，你的回答应该是肯定的。\n第一，为别人解决一个难题，那么你就能赚到许多钱；第二，把精力集中在你知道的、能做的和拥有的东西上。\n 有些人不去做是因为没有足够的自信，他们问自己：我能行吗？我能做到吗？然后给自己否定的答案。\n增强自信的方法是记录成功日记，过一段时间就会发现，其实我们并没有自己想的那么糟糕，我们其实还不错，对吧！\n在美国，送报员将报纸放在花园的信箱里，冬天人们需要离开温暖的房屋到花园里拿报纸。每天将信箱中的报纸送上门就解决了这个问题，并且能够获取一些报酬。\n当你知道这个例子后，你应该想的是我周围有哪些可以解决的问题，而不是像\u0026quot;我们这没法送报纸\u0026quot;这种你根本无法做到的事情。\n将目光放眼于你能够做的事情上，你才能开始。\n第四章 堂兄的挣钱之道  你最好想清楚你喜欢做什么，然后再考虑你怎么用它来挣钱。我就是这样想出派送面包这项服务的。我喜欢骑自行车，而现在我可以边骑车边挣钱，这种感觉太美妙了。我每天都要敲几户人家的门，问他们要不要我送面包上门。\n 认真寻找机会，把注意力放在你喜欢做的事情上会更容易些。一个好的挣钱之道是建立在快乐和兴趣之上的，如果你的工作无法让你感觉到任何快乐，那上班的时间对于你来说一定是难过的。\n 无论在什么时候都不能把希望只寄托在一份工作上，它持续的时间不会像你设想的那么长，所以你要立即寻找另一份替代的工作。\n Linkedln和PayPal的创始人Reid Hoffman有一个非常著名的职业规划理论：ABZ理论。一个人在任何情况下和任何时候都应该有3个计划：ABZ计划。\nA计划，是你正在从事的工作，也是能长期从事下去的工作，值得你持续投入，并可以获得安全感，并且这份工作，你个人还很满意。\nB计划是你业余时间给自己其他能力的培训，或者兴趣爱好或梦想。B计划是除了A以外，你愿意长期投入精力的一项属于自己的小事业，必要的时候，它可以升级为A。\nZ计划，即个人资产，是你的保障，也是你的退路。假设有一天你的A、B计划全部落空，你的Z计划，可以保证你在未来某一段时间内继续保持现有的生活品质，能给你一次从头再来的机会。\n这表明在任何时候你需要明白任何东西都不可能是一成不变的，你需要应对未知的风险，因此Plan B也是非常重要的。\n第五章 钱钱以前的主人  首先，在遇到困难的时候，仍然要坚持自己的想法。一切正常的时候，每个人都能做到这一点。只有当真正的困难出现时才能见分晓。只有少数人能坚定不移地贯彻自己的计划。那些非常成功的人，甚至有能力在他们最困难的时候作出最杰出的表现。\n 在熊市到来时你是否能坚持自己原来的计划继续买入，还是急于将手里的仓位卖掉及时止损。为什么有的人能够在困难到来时继续坚持，而有的人就被困难吓倒，所有人都想赚钱，但你只能赚到自己认知范围以内的钱，赚认知范围之外的钱就是在赌，即便你真的赚到了，在未来的某个时间你还会全部亏回去，所以更重要的一点就是去学习财务知识，提高财商，提高你的认知范围。\n 其次，困难总是在不断地出现。尽管如此，你每天还是要不间断地去做对你的未来意义重大的事情。你为此花费的时间不会超过10分钟，但是就是这10分钟会让一切变得不同。大多数人总是在现有的水平上停滞不前，就是因为他们没有拿出这10分钟。他们总是期望情况能向有利于自己的方向转变，但是他们忽视了一点，那就是他们首先必须改变自己。\n当你决定做一件事情的时候，你必须在72小时之内完成，否则你很可能永远不会再做了。\n 还是在说行动力的问题，当你了解了一个不错的建议以后， 是否开始按照它去执行是成败的关键，做与不做完全是两个不同的结果。\n也许你每天只需花很少的时间就能有所改变，但是很多人总是只看到眼前的情况，他们在坚持几天之后感觉没什么效果，便扔到一边再也不管，过了一段时间之后，和你一起开始的人获得了效果，刺激了你，这时你开始后悔、嫉妒，凭什么他就能成功了。足够的量变才能产生质变，量变是一点一点积累起来的，差距也是一点一点被拉开的。\n第六章 爸爸妈妈犯下的错误 书中对陷入负债危机的人的几点建议：\n 第一，欠债的人应当毁掉所有的信用卡。\n第二，在许可范围内按最低的分期付款数目标准支付。虽然按期还更多的贷款会减少需要偿还的利息，但同时也会让你手忙脚乱，不堪重负，你的收入来源经不起一点风险，因为只要你的收入减少或是没有收入，就会还不上贷款。\n第三，将扣除生活费后剩下的钱的一半存起来，剩下的一半用于支付消费贷款。最好根本不申请消费贷款。\n第四，减少支出。\n 这里面我想说一下第四点，也就是减少支出。\n看似是一个很简单的建议，但在双十一、商场促销打折时有些人还是会不自觉的买一些\u0026quot;垃圾\u0026quot;回家，这些垃圾被放到家中的某个角落，然后就再也没有使用过。\n富人和穷人的区别是富人最后购买奢侈品，而穷人总是先购买，并且富人使用现金流购买，而穷人使用基本收入购买。有的人中了彩票，但在很短时间内把钱挥霍一空，甚至背上负债。\n如果你在不那么富有的时候不懂得节制消费，过一种低欲望的生活，那么你永远不可能真的富有。\n第七章 在金先生家  从前有一个年轻的农夫，他每天的愿望就是从鹅笼里捡一个鹅蛋当早饭。有一天，他竟然在鹅笼里发现了一只金蛋。当然，一开始他不相信这是真的。他想，也许是有人在捉弄他。为了谨慎起见，他把金蛋拿去让金匠看，可是金匠向他保证说，这只蛋完完全全是纯金铸成的。于是，农夫就卖了这只金蛋，然后举行了一个盛大的庆祝会。第二天清晨，他起了一个大早，赶到鹅笼处一看，那里果真又放着一个金蛋。这样的情况延续了好几天。可是这个农夫是一个贪婪的人，他对自己的鹅非常不满意，因为鹅没法向他解释是怎么下出金蛋的，否则也许他自己就可以制造金蛋了。他还气呼呼地想，这只懒惰的鹅每天至少应该下两只金蛋，现在这样的速度太慢了。他的怒火越来越大，最后，他终于怒不可遏地把鹅揪出鹅笼，劈成了两半。从那以后，他再也得不到金蛋了。\n 永远不要杀死你的鹅，当你的鹅足够肥美，你的鹅下的金蛋就足够你花费了，但前提是你先要有一只鹅，这只鹅就是你的存款。\n你需要定期将收入存起来，然后养大你的鹅。书中写了一种分配方式，将50%的收入存起来变成鹅，40%放进梦想储蓄罐，10%用于日常开销。这种分配方式不可能适合所有人，只是一个例子，如果你暂时无法确定自己如何分配收入，那就多读书去找到适合自己的分配方式吧！\n注意存起来的钱是你的鹅，如果你动用了这笔钱就意味着你杀掉了自己养的鹅。\n第十二章 陶穆太太归来  金钱是中性的，既不好，也不坏。只有当钱属于某一个人的时候，它才会对这个人产生好的影响或者坏的影响。钱可以被用于好的用途，也可以被用于坏的用途。一个幸福的人有了钱会更幸福；而一个悲观忧虑的人，钱越多，烦恼就越多。\n金钱就像一个放大镜，它帮你更充分地展现出你本来的样子。好人可以用钱做很多好事。而如果你是盗贼，那你很可能会把钱挥霍在一些蠢事上。\n 第十三章 巨大的危机  每当你觉得有些事情不好办的时候，你可以做一件事，只要翻一翻成功日记，你就会从过去的事情中找到证据，相信自己未来也有能力完成任何事情。\n 第十四章 投资俱乐部 投资时需要注意几点：\n 1．应该把钱投资在安全的地方。\n2．我的钱应该下很多“金蛋”。\n3．我们的投资应该简单明了，而且易于操作。\n 第十六章 俱乐部的投资行动  挑选基金时的注意事项：\n  基金应该至少有10年历史。假如它在这么长时间内一直有丰厚的利润，那我们可以认为，未来它也会运作良好。\n  应该选择大型的跨国股票基金。这种基金在世界各地购买股票，以此分散风险，所以十分安全。\n  对基金的走势图进行比较。我们应该观察在过去10年间哪些基金的年终利润最好。\n   第十七章 爷爷奶奶害怕风险 72公式：\n72 / 年收益率 = 收益翻倍的时间 (年)\n72 / 通货膨胀率 = 金钱贬值一半的时间 (年)\n十年前的100块和现在的100块的价值是不等的，因为存在着通货膨胀，如果银行的利率低于通货膨胀率，那就意味着你存到银行的钱，其实是在贬值的。所以保留未来3~5年需要花费的钱放在银行，其余的钱应该做一些投资，让金钱为你工作赚钱。\n十八章 大冒险的结局  不要为失去的东西而忧伤，而要对拥有它的时光心存感激。\n 自力更生——写给成年人的后记  我们推崇一种聪明的、简朴的生活方式。也就是说，宁愿购买一件一流产品，也不要不停地买许多的二流产品。\n而且，不要仅仅因为一件产品的外观不再时髦而新产品正在流行，就不断追逐新鲜的东西。\n 《小狗钱钱2》读书笔记 如果说《小狗钱钱》是在讲如何赚钱、理财，那么《小狗钱钱2》更侧重于如何做人，这两者是分不开的。\n第二章 白色石头  3条准则：\n  你应该更自制、更谦虚，特别是要更加成熟一点儿，这首先就表现在说话不要总是冒冒失失的。\n不友善一直就是缺乏教养和内心脆弱的标志，而且也显得很愚蠢。尊重他人和对人有礼貌是成功的重要因素。如果有人不喜欢你，很大程度上是因为你表现得不够友好。这会损害一个人的声誉，所以你不能那么做。另外，彬彬有礼也可以让以前并不信任你的人接纳你。\n  不能总是抱怨命运的不公。\n在我们的生活中不是所有的事情都是公平的，不公平的情况很常见。但这并不意味着你就应该放弃，因为成功并不取决于你是否受到了公平的对待。\n  永远不要在背后说别人的坏话。\n嘲笑他人是一件令人遗憾的事情。当你把目光都集中在别人的错误和缺点上时，就自然会忽略他们身上闪光的一面。而一个人只有具备了审视美好事物的能力，世界对他来说才会变得更加美好。\n    “如果甜甜圈外面的圆圈象征着金钱及一切可以用来消费的东西，那么它中间的那个圆孔又代表着什么意思呢？”\n“甜甜圈中间的圆孔代表着人类的内心，可是这内心本身却是无形的。许多人并不关心自己的内心，就是因为看不到它。对于他们来说，只有看得见的成功才是重要的。但你如果想要变得幸福，就不能只重视物质上的成功，还必须培养自己具有优秀的内心。”\n“优秀的内心就是那些人们不能用金钱买到的东西，但缺少了它们人们就无法获得幸福。这个内心就是你的品格，谦虚、感恩、尊敬老人及同情弱者都属于一个人的优秀品格。培养优秀品格的前提是，你应该认识到自己并不是孤零零地生活着，而是与他人同在。因此，你应该助人为乐，要通过自己的努力使得世界在他人眼中变得更加美好。”\n“没有圆孔的甜甜圈也就不再是甜甜圈了。同样的道理，缺少优秀品格的人其本质也是空虚的。只考虑金钱的人是不会真正幸福的。”\n“人们必须懂得每个人都要担负对这个世界的职责。如果不那样做的话就只会是一事无成。只有当你意识到并且履行了那份职责，你才能找到属于你自己的那块白色石头。那块石头上写有你新的名字，而这名字就是一个全新的幸福生活的标志。”\n 第四章 论文  “失败者总是无法成功，那是因为他们习惯于放弃；胜利者最终总是成功，则是因为他们永不放弃。”\n 第六章 寄宿学校  “你是一个美国人，这没错，但它只是你的一个归属。除此之外你还应该是一个世界公民，这就是你的第二归属。如果我们认为自己只有维护一个国家的义务，很有可能会引发相互间的争执甚至战争。但如果我们把自己看作是一个世界公民的话，就能够更好地理解与支持对方。”\n 第十章 7条准则  友好亲和\n 我有一个强烈的愿望，希望其他人能够像我一样生活美好而幸福。 我不会伤害任何人。我克制自己，不介入任何争端。 我谦虚有礼，尊重他人。我并不是永远正确。  “如果有人想给你一些东西，但是你并不接收，那这个东西就还属于那个给予者。在遇到愤怒和仇恨时，如果我们不接受，它们就还是属于原来的人所有。“\n勇于承担\n 遇事我能自我抉择。我能自行判断对某种情况应该作何反应。 我不受不公平之事的影响，而是将注意力集中在我能做的事情、我知道的知识和我拥有的东西之上。 我把责任推托给别人的同时，也把相应的权利转交给了对方。  “一个橘子，不管你是用手捏还是用脚踩还是用榨汁机，它给予你的都是橘子汁“\n善待他人\n 我只称赞他人。如果确实无法称赞他人，那就最好什么都不说。 我尽量不批评他人。如果不得不批评，也要用非常礼貌和友善的方式。 我将注意力集中在他人的优点和闪光点上。  “当你只看到光明的时候，你就会成为光明；而当你只看到垃圾的时候，你就会成为垃圾。”\n帮助给予\n 我祝愿自己遇到过的所有人都能一切顺利。 我送给某人礼物，因为我想表达自己对他的好感。 最美好的事情莫过于帮助他人。我总是在想自己能够帮助谁，没有什么比这更令人快乐。  “当我心情不好的时候，我会去想一想此时能够帮助谁或者可以给谁带去欢乐。要是这样的话，自己也会感觉好一些。”\n感恩之心\n 我总是心怀感恩，哪怕是对看似寻常的事情。 即便遇到了困难，我还是会关注值得感激的事物。 我对身边的人都充满感激之情，并非常享受和他们共度的美好时光。  “幸福之人的秘密就是有能力辨别出奇迹发生的时刻并对此抱有感激之情。”\n勤学不辍\n 如果我骄傲自满，那无异于说自己不必再学任何东西了。因此我应该保持谦恭好学的态度。 我不仅要阅读好的书籍、写成功日记和知识笔记，还要尽可能多地向他人学习。 我不拿自己和别人比较，而是尽我所能做到最好。  “我总是不断地学习，这是因为我要成为我有能力成为的那种人。”\n”如果有一天你不再进步，从此以后你演奏的就只是同一首乐曲。”\n值得信赖\n 我能否成功总是取决于自身培养出的习惯。 如果我是一个非常自律的人，我就能比那些虽有天赋但却懒惰散漫的人获得更多的成功。 我总是很守时。我信守为他人作出的承诺。  “在我们的头脑中有两个人：其中一个侏儒想引诱我们打破原先的计划，而另一个巨人则要求我们信守对自己作出的承诺。”\n ","date":"2022-10-16T10:22:34+08:00","image":"https://WangZichen99.github.io/img/2022/10/autumn_forest.jpg","permalink":"https://WangZichen99.github.io/p/puppymoney/","title":"小狗钱钱读书笔记"},{"content":"富爸爸穷爸爸读书笔记 第一章 富人不为钱工作  你做出决定的速度越快，抓住机会的可能性就越大——当然是在别人做决定之前。\n实践或模拟，才能学得最好。\n从尝试和错误中学习变得越来越重要，而书籍学习在现实世界中越来越没价值，大学教育不再能保证一份工作。\n生活中的很多事情是我们无法控制的。我学会了专注于我所能控制的：我自己。如果事情必须改变，首先要改变的就是我自己。\n购买或创造提供现金流的资产能使你的钱为你工作。高薪工作只意味着两件事：你在为钱工作，你所支付的税收可能会增加。\n人们的生活永远被这两种感觉所控制：恐惧和贪婪。\n 第二章 为什么要教授财务知识  富人得到资产而穷人和中产阶级得到负债。\n资产是能把钱放进我口袋里的东西，不管我工作与否；负债是把钱从我口袋取走的东西。\n一个受过高等教育且事业有成的人，同时也可能是财务上的文盲。\n财富就是支撑一个人生存多长时间的能力，或者说，如果我今天停止工作，我还能活多久？\n只要我把支出控制在资产项能够产生的现金之下，我就会越来越富有，也会有越来越多的非劳动收入。\n打牢地基，地基就是财务知识，你需要学习足够的财务知识，然后靠这些知识来买入资产，如果你想不学习任何财务知识就可以致富，那件造出来的就是一座斜塔。\n 第三章 关注自己的事业  关注自己的事业而不是工作，事业能够让你在失去工作后依然保持稳定的收入。\n开始关注你自己的事业，在继续工作的同时购买一些房地产，不要买负债。\n为了财务安全，人们需要关注自己的事业。富人关心的焦点是资产而其他人关心的是收入。存在财务问题的人经常耗费一生为别人工作，其中许多人在他们不能工作时就变得一无所有。净资产并不是一个确定的东西，这主要是因为在你开始出售资产时，你还要为获得的收入缴税。一旦把1美元投入了资产项，就不要让它出来。你应该这么想：1美元进入了你的资产项，就成为了你的雇员。关于钱，最妙的就是让它可以一天24小时不间断工作，还能为你的子孙后代服务。一个重要的区别就是：富人最后才买奢侈品，而穷人和中产阶级会先买奢侈品。穷人和中产阶级用他们的血汗钱和本应该留给子孙的遗产来购买奢侈品。\n 第四章 税收的历史和公司的力量  如果你愿意投资，税法将有利于你。如果你只想花钱及购买债务，税法就不会给你任何空隙——你可能会缴纳尽可能多的税款。换句话说就是需要交税的东西都不是资产，你需要避开它。\n财商是由4个方面的专业知识构成的：\n  会计\n会计就是财务知识或解读数字的能力。如果你想建立一个自己的商业帝国，财务知识是非常重要的。你管理的钱越多就要越精确，否则这幢大楼就会倒塌。这需要左脑来处理，是细节的部分。财务知识能帮助你读懂财务报表，还能让你辨别一项生意的优势和劣势。\n  投资\n投资是钱生钱的科学。投资涉及策略和方案，这需要右脑来做，是属于创造的部分。\n  了解市场\n了解市场是供给与需求的科学。这要求了解受感情驱动的市场的\u0026quot;技术面\u0026quot;。市场的另一个因素是\u0026quot;基本面\u0026quot;，或者说是一项投资的经济意义。一项投资究竟有无意义最终取决于当前的市场状况。\n  法律\n法律利用一个具有会计、投资和市场运营的企业会使你的财富实现爆炸性的增长。了解减税优惠政策和公司法的人会比雇员和小业主更快致富。这就像一个人在走，而另一个人在飞，久而久之这种差距就大了。\n   第五章 富人的投资 即便在学校获得了优秀的成绩，那并不代表你赚钱的能力，也不代表你的财商，因为学校从不教你如何赚钱。学习财务知识才是重要的。\n 一般有两种类型的投资者：(1) 进行一揽子投资的人（比如财务计划师）；(2) 自己创造投资机会的人（职业投资者）。\n如果你想成为第二种投资者，你就必须提升3种主要技能：\n 第一，如何找到别人错失的机会； 第二，如何筹集资金； 第三，如何把精明的人组织起来并雇佣他们为你工作。  风险无处不在，要学会驾驭风险，别总想回避风险。\n 第六章 学会不为钱工作 工人付出最大努力以免于被解雇，而雇主提供最低工资以防止工人辞职。\n追逐能使自己学到知识的工作，尽管工资可能会降低，而不是看起来前景很好很安稳的工作。\n不断学习专业之外的技能，比如销售。专业化会使你的职业选择降低，如果找不到专业相关的工作，你将无法获得收入。\n在获得收入之前需要学会付出。付出，然后获得。\n第七章 克服困难 没有百发百中的世界冠军，也没有永远赚钱的投资人。失败是激励你的东西，不要被失败击倒。\n不让谣言和杞人忧天的怀疑加剧我们的恐惧和疑虑。在做出决定的时候，周围总有一些声音让你对自己的决定产生怀疑，当你顺从了这些声音，机会就从你手中溜走了。在遇到问题时想当然，就会被心里的忧虑所干扰，导致你一无所获，而是应该付出行动解决心中的疑虑；比如在购买房地产时，很多人不想自己修理房子的问题，那么就应该找到一个靠谱的物业来帮你管理你的房产；在股票市场你不想亏钱，那就应该为了盈利而投资，而不是为了避免损失而投资。\n克服懒惰，不要被花钱的负罪感所绑架，你应该多问自己如何才能支付起你想要的东西。\n先支付给自己，后支付给债务。\n时刻保持谦虚，be humble！\n第八章 开始行动  找一个超现实的理由——精神的力量：你需要明白自己为什么想要变得有钱，自己想要什么，不想要什么，这将在你无助的时候给你力量，使你坚持下去，渡过难关 每天作出选择——选择的力量：在确定目标后，你是选择虚心的学习投资知识，提高自己的财商，还是选择继续以自我感觉良好的方式去任劳任怨的工作，每个人都有选择的权利，不同的是选择的结果 慎重的选择朋友——关系的力量：如果你想变得富有，你需要结交有钱的朋友，从他们身上学到你应该做什么，同时富人掌握着普通人没有的信息。从你穷困潦倒的朋友身上你能够知道自己不应该做什么，他们过着小鸡式的生活，杞人忧天似的告诉你这样做有多么大的风险，如果你听从了他们的话，你也会变成小鸡式的人。在市场中，群众的感知是极其缓慢的，当大部分人开始看到赚钱的机会之后，富人早就已经赚到足够多的钱去寻找新的风口了，所以盲目跟随是最愚蠢的投资方式！！！ 掌握一种模式，然后再学习一种新的模式——快速学习的力量：学习不同领域的知识，学习不同的投资方法 首先支付自己——自律的力量：首先支付自己的意思是，首先将你的收入支付到你的投资中去，支付到你的资产中去，而不是首先支付你的负债或是买一些无关紧要的奢饰品。降低你的支出，才是积累财富最关键的地方，保持低欲望的生活。 给你的经纪人以优厚的报酬——好建议的力量：经纪人是专业性很高的职业，一个好的经纪人能让你的投资事半功倍，在选择经纪人时，你需要知道他究竟有多少资产，有的经纪人把自己吹的天花乱坠，但实际上他们根本没有什么资产。一个好的经纪人不仅能够帮你赚钱，同时还愿意教你，他们是你最大的资产，学会慷慨的对待你的经纪人，学会如何管理你的经纪人 做一个印第安给予者——无私的力量：当看到一个白人很冷时，印第安人会给他一条毯子，但是白人以为这是一个礼物，当印第安人要回毯子时，白人感到愤怒，印第安人感到失望。在投资中要清楚何时能够收回本钱，当你收回本钱后，就无需担心亏损 用资产来购买奢侈品——专注的力量：前面已经讲过，大部分穷人贫穷的根本原因是他们不懂得节制花钱，这就是为什么通常中了大奖的人会在很短时间内将这笔钱挥霍的一分不剩，穷人先购买奢侈品，而富人选择最后购买奢侈品。当你有欲望得到某些东西时，创造足够的资产去支付它，而不是直接去购买，成为金钱的主人，让金钱为你工作 对英雄的崇拜——神话的力量：榜样的力量是强大的，将什么样的人作为榜样，你就会成为什么样的人 先予后取——给予的力量：先付出，后回报  第九章：还想要更多吗？这里有一些要做的事情  停下你手里的活儿：在学习到新的财务知识后，你需要不断反思自己的投资方式，哪些是有效的，哪些是无效的 寻找新的思想：学习不同思想的书，并付出行动 找一些做过你想做的事情的人：请他们一起共进午餐，请教一些问题 参加辅导班、阅读和研讨会：还是不断学习，各种方式学习 提出多份报价：作为买家，大多数时候给出的报价都要远远高于商品的实际价格，学会报价还价、谈判拒绝是极其重要的 每月在某一地区慢跑、散步或驾车10分钟左右：这样做是为了发现周围的变化，发现投资的机会。一项交易想要盈利必须包括两个条件：廉价和变化 购买特价商品：交易盈利的第一点是廉价，只有买入廉价的资产才有赚钱的空间 关注适当的地方：还是说你应该学习 首先寻找要买进的人，然后才去找想卖出的人：先有需求，后有供给，这样你才能在交易中赚钱 考虑大生意：小规模的投资是开始，如果你想完成你财富自由目标，那就要寻找大规模的生意，特别是对于零售来说，大规模的生意利润更大 学习前人经验 行动的人总会击败不行动的人  ","date":"2022-10-15T15:48:50+08:00","image":"https://WangZichen99.github.io/img/2022/10/autumn_forest_mountain.jpg","permalink":"https://WangZichen99.github.io/p/richfatherpoorfather/","title":"富爸爸穷爸爸读书笔记"},{"content":"Redis 笔记 概述 Redis能干嘛  内存存储、持久化 高速缓存 发布订阅系统 地图信息分析 计时器、计数器（浏览量） \u0026hellip;  Windows安装Redis  下载地址：https://github.com/tporadowski/redis/releases 下载解压后打开redis-server.exe和redis-cli.exe  ​\t​\t输入ping测试连接，set设置key value，get获取  Linux安装Redis   下载安装包https://redis.io/download/\n  tar -zxvf redis-7.0.4.tar.gz 解压\n  yum install gcc-c++安装环境\n  进入redis解压目录make \u0026amp;\u0026amp; make install\n  redis默认安装目录：/usr/local/bin\n  redis默认不是后台启动，修改配置daemonize为yes\n启动redis服务：进入/usr/local/bin/，执行redis-server ../src/redis-7.0.4/redis.conf 客户端连接redis：redis-cli -p 6379 查看redis进程：ps -ef|grep redis 关闭redis服务：shutdown，exit    ​\t性能测试 redis-benchmark是一个压力测试工具\n 测试100个并发连接，100000个请求  redis-benchmark -h localhost -p 6379 -c 100 -n 100000    基础知识  默认16个数据库，默认使用第0个  1 2 3 4 5 6 7 8 9  select \u0026lt;dbid\u0026gt; #切换数据库 dbsize #查看数据库大小 keys * #查看数据库中所有key flushdb #清空当前数据库 flushall #清空所有数据库   Redis是单线程的  官方表示Redis是基于内存操作，CPU不是Redis的性能瓶颈，Redis的瓶颈是根据机器的内存和网路带宽，既然可以用单线程实现，就使用了单线程 单线程为什么还这么快？  误区1：高性能的服务器一定是多线程的 误区2：多线程一定比单线程效率高 对于Redis来说，所有数据全部放在内存中，对于内存系统来说不需要上下文切换，所以单线程比多线程效率更高      五大数据类型 Redis-Key 1 2 3 4 5 6 7 8 9  exists {key} #当前数据库是否存在某个key move {key} {db} #将key移动到数据库db中 expire {key} {seconds} #设置key的过期时间为seconds秒 ttl {key} #查看key的剩余过期时间 type {key} #查看key的类型   String (字符串) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  set {key} {value} get {key} {value} append {key} {value} #在key值中追加value，如果key不存在就相当于set key strlen {key} #查看key的长度 incr {key} #key值自增1 decr {key} #key值自减1 incrby {key} {increment} #key值自增increment decrby {key} {increment} #key值自减increment getrange {key} {start} {end} #截取key值的start到end setrange {key} {start} {value} #start开始替换key值为value setex {key} {seconds} {value} #设置key值为value，seconds秒后过期，setex (set with expire) setnx {key} {value} #如果key不存在，设置key值为value，setnx (set if not expire) mset {key1} {value1} {key2} {value2} #批量设置 mget {key1} {key2} #批量获取 msetnx {key1} {value1} {key2} {value2} #如果所有key都不存在，批量设置 mset {object}:{id}:{field} #key命名方式 getset {key} {value} #先获取key值，再设置key   List (列表) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  lpush {key} {value} #左插入value rpush {key} {value} #右插入value lrange {key} {start} {end} #获取从start到end的值 lpop {key} #移除list左侧的值 rpop {key} #移除list右侧的值 lindex {key} {index} #获取下标为index的值 llen {key} #获取list长度 lrem {key} {count} {value} #移除key中count个值为value的元素 ltrim {key} {start} {end} #从start到end截取list rpoplpush {source} {destination} #移除source中的右侧值插入destination中左侧 lset {key} {index} {item} #将list中下标为index的元素替换为item linsert {key} [before|after] {pivot} {element} #在第一个值为pivot的元素前或后面插入element   Set (集合)  集合中的元素不能重复  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  sadd {key} {members...} #向集合中添加元素 smembers {key} #查看集合中的元素 sismember {key} {member} #查看元素是否存在集合中 scard {key} #查看集合中的元素个数 srem {key} {member} #移除集合中的元素 srandmember {key} (count) #随机输出集合中的count个元素 spop {key} (count) #随机弹出集合中的count个元素 smove {source} {destination} {member} #将一个集合中的元素移动到另一个集合 sdiff {key} {key...} #查看多个集合与第一个集合的差集 sinter {key} {key...} #查看多个集合的交集 sunion {key} {key...} #查看多个集合的并集   Hash (哈希) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  hset {key} {field} {value} #设置键和值 hget {key} {field} #获取键的值 hmset {key} {field value...} #设置hash的多个键和值 hmget {key} {field...} #获取hash的多个键的值 hgetall {key} #获取hash的所有键和值 hdel {key} {field...} #删除键 hlen {key} #获取hash长度 hexists {key} {field} #判断hash的键是否存在 hkeys {key} #获取hash的所有键 hvals {key} #获取hash的所有值 hincrby {key} {field} {increment} #hash的键自增increment hsetnx {key} {field} {value} #如果hash中没有这个键就创建   Zset (有序集合)  一般用来做排行榜  1 2 3 4 5 6 7 8 9 10 11 12 13  zadd {key} {score} {value} #添加value zrange {key} {start} {end} #获取zset中的值 zrangebyscore {key} {min} {max} [withscores] #升序排列zset中score在min到max之间的元素，withscores表示打印份数 zrevrange {key} {start} {end} [withscores] #根据score降序排列zset中下标为start到end的元素 zrem {key} {member...} #移除zset中的某个元素 zcard {key} #获取集合中的个数 zcount {key} {min} {max} #获取分数在min到max之间的元素个数   三种特殊数据类型 Geospatial (地理位置)  一般用来进行附近好友的展示  1 2 3 4 5 6 7 8 9 10 11  geoadd {key} {longitude} {latitude} {member} #添加地理位置 geopos {key} {member...} #获取指定成员的位置信息 geodist {key} {member1} {member2} [m|km|mi|ft] #获取两个成员之间的绝对距离，单位：m（米）、km（千米）、mi（英里）、ft（英尺） georadius {key} {longitude} {latitude} {radius} [m|km|mi|ft] [withcoord|withdist] [count num] #获取圆形区域内的所有成员 withcoord返回成员经纬度，withdist返回距离圆心的直线距离 georadiusbymember {key} {member} {radius} [m|km|mi|ft] [withcoord|withdist] [count num] #获取圆形区域内的所有成员 geohash {key} {member...} #返回成员的hash值   Hyperloglog (基数统计)  一般用来进行用户访问统计。如果容错，可以使用hyperloglog，如果不容错，则使用set集合来存储用户id进行统计  1 2 3 4 5  pfadd {key} {element...} #添加元素 pfcount {key} #返回去重后的元素数量 pfmerge {distkey} {sourcekey...} #合并所有sourcekey并去重得到distkey   Bitmaps (位图)  统计用户信息（是否活跃、是否登录），365天打卡信息等  1 2 3 4 5  setbit {key} {offset} {value} #设置第offset位的值value getbit {key} {offset} #获取第offset位的值 bitcount {key} [start] [end] #从start到end计数   Redis事务  redis单条命令是原子性的，但是事务是不保证原子性的 redis事务没有隔离级别的概念  1  ------ 队列 命令1 命令2 命令3 执行 ------    所有命令在事务中没有直接被执行，只有发起执行命令的时候才会被执行  1 2 3 4 5 6 7  multi #开启事务 ... #命令入队 exec #执行事务 discard #放弃事务    编译型异常（代码有问题，命令有错），事务中所有命令都不会被执行\n运行时异常（1 / 0），错误命令抛出异常，其他命令正常执行\n Redis实现悲观锁乐观锁 悲观锁：\n 很悲观，认为什么时候都会出问题，做什么事情都要加锁  乐观锁：\n 很乐观，认为什么时候都不会出问题，所以不会上锁，更新数据的时候判断一下，是否有人修改过这个数据   获取version 更新的时候比较version  1 2 3  watch {key} #加乐观锁监视key，如果监视key的值和事务执行前key的值不一致就报错，无法执行事务 unwatch #解除监视 (解锁)，事务执行后会自动解锁   Jedis   导入依赖：\n1 2 3 4 5  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;redis.clients\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jedis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.3.0-m2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;     测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  public class JedisTest { @Test public void test() { Jedis jedis = new Jedis(\u0026#34;127.0.0.1\u0026#34;, 6379); jedis.flushDB(); // String相关命令测试  stringTest(jedis); // 事务测试  multiTest(jedis); } private void multiTest(Jedis jedis) { jedis.set(\u0026#34;hello\u0026#34;, \u0026#34;init\u0026#34;); jedis.watch(\u0026#34;hello\u0026#34;); //监视hello，如果值发生变化，事务不执行  jedis.set(\u0026#34;hello\u0026#34;, \u0026#34;before\u0026#34;); Transaction transaction = jedis.multi(); try { transaction.set(\u0026#34;multi\u0026#34;, \u0026#34;test\u0026#34;); // int i = 1 / 0; //运行时异常，错误命令抛出异常，其他命令正常执行  transaction.exec(); } catch (Exception e) { e.printStackTrace(); transaction.discard(); } finally { System.out.println(jedis.get(\u0026#34;multi\u0026#34;)); jedis.close(); } } private void stringTest(Jedis jedis) { System.out.println(jedis.ping()); System.out.println(jedis.set(\u0026#34;name\u0026#34;, \u0026#34;wzc\u0026#34;)); System.out.println(jedis.get(\u0026#34;name\u0026#34;)); System.out.println(jedis.exists(\u0026#34;name\u0026#34;)); System.out.println(jedis.keys(\u0026#34;*\u0026#34;)); System.out.println(jedis.append(\u0026#34;age\u0026#34;, \u0026#34;22\u0026#34;)); System.out.println(jedis.incrBy(\u0026#34;age\u0026#34;, 2)); System.out.println(jedis.strlen(\u0026#34;name\u0026#34;)); System.out.println(jedis.getrange(\u0026#34;name\u0026#34;, 0, -1)); System.out.println(jedis.setrange(\u0026#34;name\u0026#34;, 0, \u0026#34;robin\u0026#34;)); System.out.println(jedis.get(\u0026#34;name\u0026#34;)); System.out.println(jedis.mset(\u0026#34;play\u0026#34;, \u0026#34;game\u0026#34;, \u0026#34;climb\u0026#34;, \u0026#34;mountain\u0026#34;)); System.out.println(jedis.mget(\u0026#34;play\u0026#34;, \u0026#34;climb\u0026#34;)); } }     SpringBoot整合Redis  说明：在Spring2.X之后，原来使用的Jedis被替换为了Lettuce\nJedis采用直连，多线程操作不安全，解决方法是使用Jedis Pool连接池，BIO模式\nLettuce采用Netty，实例可以在多个线程中共享，不存在线程不安全的情况，NIO模式\n 源码分析：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  public class RedisAutoConfiguration { public RedisAutoConfiguration() { } @Bean @ConditionalOnMissingBean(name = {\u0026#34;redisTemplate\u0026#34;}) @ConditionalOnSingleCandidate(RedisConnectionFactory.class) //默认的RedisTemplate没有过多的设置，由于泛型不是\u0026lt;String, Object\u0026gt;，可以自己定义redisTemplate替换默认的  public RedisTemplate\u0026lt;Object, Object\u0026gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) { RedisTemplate\u0026lt;Object, Object\u0026gt; template = new RedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; } @Bean @ConditionalOnMissingBean @ConditionalOnSingleCandidate(RedisConnectionFactory.class) //由于String是Redis中最常使用的类型，所以单独提出来了一个template  public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) { StringRedisTemplate template = new StringRedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; } }     导入依赖\n1 2 3 4  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;     配置连接\n1 2 3 4  spring:redis:host:127.0.0.1port:6379    Redis.conf详解 配置文件位置：/usr/local/src/redis-7.0.4/redis.conf\n 配置文件中units对大小写不敏感  redis配置文件可以引用一些外部配置   绑定ip和端口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132  ################################## NETWORK ##################################### # By default, if no \u0026#34;bind\u0026#34; configuration directive is specified, Redis listens # for connections from all available network interfaces on the host machine. # It is possible to listen to just one or multiple selected interfaces using # the \u0026#34;bind\u0026#34; configuration directive, followed by one or more IP addresses. # Each address can be prefixed by \u0026#34;-\u0026#34;, which means that redis will not fail to # start if the address is not available. Being not available only refers to # addresses that does not correspond to any network interface. Addresses that # are already in use will always fail, and unsupported protocols will always BE # silently skipped. # # Examples: # # bind 192.168.1.100 10.0.0.1 # listens on two specific IPv4 addresses # bind 127.0.0.1 ::1 # listens on loopback IPv4 and IPv6 # bind * -::* # like the default, all available interfaces # # ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the # internet, binding to all the interfaces is dangerous and will expose the # instance to everybody on the internet. So by default we uncomment the # following bind directive, that will force Redis to listen only on the # IPv4 and IPv6 (if available) loopback interface addresses (this means Redis # will only be able to accept client connections from the same host that it is # running on). # # IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES # COMMENT OUT THE FOLLOWING LINE. # # You will also need to set a password unless you explicitly disable protected # mode. # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ bind 127.0.0.1 -::1 #绑定本地的IPV4和IPV6连接，::1代表IPV6地址 # By default, outgoing connections (from replica to master, from Sentinel to # instances, cluster bus, etc.) are not bound to a specific local address. In # most cases, this means the operating system will handle that based on routing # and the interface through which the connection goes out. # # Using bind-source-addr it is possible to configure a specific address to bind # to, which may also affect how the connection gets routed. # # Example: # # bind-source-addr 10.0.0.1 # Protected mode is a layer of security protection, in order to avoid that # Redis instances left open on the internet are accessed and exploited. # # When protected mode is on and the default user has no password, the server # only accepts local connections from the IPv4 address (127.0.0.1), IPv6 address # (::1) or Unix domain sockets. # # By default protected mode is enabled. You should disable it only if # you are sure you want clients from other hosts to connect to Redis # even if no authentication is configured. protected-mode yes #保护模式，默认开启 # Redis uses default hardened security configuration directives to reduce the # attack surface on innocent users. Therefore, several sensitive configuration # directives are immutable, and some potentially-dangerous commands are blocked. # # Configuration directives that control files that Redis writes to (e.g., \u0026#39;dir\u0026#39; # and \u0026#39;dbfilename\u0026#39;) and that aren\u0026#39;t usually modified during runtime # are protected by making them immutable. # # Commands that can increase the attack surface of Redis and that aren\u0026#39;t usually # called by users are blocked by default. # # These can be exposed to either all connections or just local ones by setting # each of the configs listed below to either of these values: # # no - Block for any connection (remain immutable) # yes - Allow for any connection (no protection) # local - Allow only for local connections. Ones originating from the # IPv4 address (127.0.0.1), IPv6 address (::1) or Unix domain sockets. # # enable-protected-configs no # enable-debug-command no # enable-module-command no # Accept connections on the specified port, default is 6379 (IANA #815344). # If port 0 is specified Redis will not listen on a TCP socket. port 6379 #端口设置 # TCP listen() backlog. # # In high requests-per-second environments you need a high backlog in order # to avoid slow clients connection issues. Note that the Linux kernel # will silently truncate it to the value of /proc/sys/net/core/somaxconn so # make sure to raise both the value of somaxconn and tcp_max_syn_backlog # in order to get the desired effect. tcp-backlog 511 # Unix socket. # # Specify the path for the Unix socket that will be used to listen for # incoming connections. There is no default, so Redis will not listen # on a unix socket when not specified. # # unixsocket /run/redis.sock # unixsocketperm 700 # Close the connection after a client is idle for N seconds (0 to disable) timeout 0 # TCP keepalive. # # If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence # of communication. This is useful for two reasons: # # 1) Detect dead peers. # 2) Force network equipment in the middle to consider the connection to be # alive. # # On Linux, the specified value (in seconds) is the period used to send ACKs. # Note that to close the connection the double of the time is needed. # On other kernels the period depends on the kernel configuration. # # A reasonable value for this option is 300 seconds, which is the new # Redis default starting with Redis 3.2.1. tcp-keepalive 300 # Apply OS-specific mechanism to mark the listening socket with the specified # ID, to support advanced routing and filtering capabilities. # # On Linux, the ID represents a connection mark. # On FreeBSD, the ID represents a socket cookie ID. # On OpenBSD, the ID represents a route table ID. # # The default value is 0, which implies no marking is required. # socket-mark-id 0     通用配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107  ################################# GENERAL ##################################### # By default Redis does not run as a daemon. Use \u0026#39;yes\u0026#39; if you need it. # Note that Redis will write a pid file in /var/run/redis.pid when daemonized. # When Redis is supervised by upstart or systemd, this parameter has no impact. daemonize yes #默认以守护进程方式运行 # If you run Redis from upstart or systemd, Redis can interact with your # supervision tree. Options: # supervised no - no supervision interaction # supervised upstart - signal upstart by putting Redis into SIGSTOP mode # requires \u0026#34;expect stop\u0026#34; in your upstart job config # supervised systemd - signal systemd by writing READY=1 to $NOTIFY_SOCKET # on startup, and updating Redis status on a regular # basis. # supervised auto - detect upstart or systemd method based on # UPSTART_JOB or NOTIFY_SOCKET environment variables # Note: these supervision methods only signal \u0026#34;process is ready.\u0026#34; # They do not enable continuous pings back to your supervisor. # # The default is \u0026#34;no\u0026#34;. To run under upstart/systemd, you can simply uncomment # the line below: # # supervised auto # If a pid file is specified, Redis writes it where specified at startup # and removes it at exit. # # When the server runs non daemonized, no pid file is created if none is # specified in the configuration. When the server is daemonized, the pid file # is used even if not specified, defaulting to \u0026#34;/var/run/redis.pid\u0026#34;. # # Creating a pid file is best effort: if Redis is not able to create it # nothing bad happens, the server will start and run normally. # # Note that on modern Linux systems \u0026#34;/run/redis.pid\u0026#34; is more conforming # and should be used instead. pidfile /var/run/redis_6379.pid #如果以守护进程方式运行，需要指定一个pid进程文件 # Specify the server verbosity level. # This can be one of: # debug (a lot of information, useful for development/testing) # verbose (many rarely useful info, but not a mess like the debug level) # notice (moderately verbose, what you want in production probably) # warning (only very important / critical messages are logged) loglevel notice #日志级别 # Specify the log file name. Also the empty string can be used to force # Redis to log on the standard output. Note that if you use standard # output for logging but daemonize, logs will be sent to /dev/null logfile \u0026#34;\u0026#34; #日志的文件名 # To enable logging to the system logger, just set \u0026#39;syslog-enabled\u0026#39; to yes, # and optionally update the other syslog parameters to suit your needs. # syslog-enabled no # Specify the syslog identity. # syslog-ident redis # Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7. # syslog-facility local0 # To disable the built in crash log, which will possibly produce cleaner core # dumps when they are needed, uncomment the following: # # crash-log-enabled no # To disable the fast memory check that\u0026#39;s run as part of the crash log, which # will possibly let redis terminate sooner, uncomment the following: # # crash-memcheck-enabled no # Set the number of databases. The default database is DB 0, you can select # a different one on a per-connection basis using SELECT \u0026lt;dbid\u0026gt; where # dbid is a number between 0 and \u0026#39;databases\u0026#39;-1 databases 16 #默认数据库数量 # By default Redis shows an ASCII art logo only when started to log to the # standard output and if the standard output is a TTY and syslog logging is # disabled. Basically this means that normally a logo is displayed only in # interactive sessions. # # However it is possible to force the pre-4.0 behavior and always show a # ASCII art logo in startup logs by setting the following option to yes. always-show-logo no #是否总是显示logo # By default, Redis modifies the process title (as seen in \u0026#39;top\u0026#39; and \u0026#39;ps\u0026#39;) to # provide some runtime information. It is possible to disable this and leave # the process name as executed by setting the following to no. set-proc-title yes # When changing the process title, Redis uses the following template to construct # the modified title. # # Template variables are specified in curly brackets. The following variables are # supported: # # {title} Name of process as executed if parent, or type of child process. # {listen-addr} Bind address or \u0026#39;*\u0026#39; followed by TCP or TLS port listening on, or # Unix socket if only that\u0026#39;s available. # {server-mode} Special mode, i.e. \u0026#34;[sentinel]\u0026#34; or \u0026#34;[cluster]\u0026#34;. # {port} TCP port listening on, or 0. # {tls-port} TLS port listening on, or 0. # {unixsocket} Unix domain socket listening on, or \u0026#34;\u0026#34;. # {config-file} Name of configuration file used. # proc-title-template \u0026#34;{title} {listen-addr} {server-mode}\u0026#34;     快照 (SNAPSHOTTING)\n与持久化相关，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94  ################################ SNAPSHOTTING ################################ # Save the DB to disk. # # save \u0026lt;seconds\u0026gt; \u0026lt;changes\u0026gt; [\u0026lt;seconds\u0026gt; \u0026lt;changes\u0026gt; ...] # # Redis will save the DB if the given number of seconds elapsed and it # surpassed the given number of write operations against the DB. # # Snapshotting can be completely disabled with a single empty string argument # as in following example: # # save \u0026#34;\u0026#34; # # Unless specified otherwise, by default Redis will save the DB: # * After 3600 seconds (an hour) if at least 1 change was performed # * After 300 seconds (5 minutes) if at least 100 changes were performed # * After 60 seconds if at least 10000 changes were performed # # You can set these explicitly by uncommenting the following line. # # save 3600 1 300 100 60 10000 # 如果一小时内至少有一次修改、五分钟内至少100次修改、一分钟内至少10000次修改则进行rdb持久化 # By default Redis will stop accepting writes if RDB snapshots are enabled # (at least one save point) and the latest background save failed. # This will make the user aware (in a hard way) that data is not persisting # on disk properly, otherwise chances are that no one will notice and some # disaster will happen. # # If the background saving process will start working again Redis will # automatically allow writes again. # # However if you have setup your proper monitoring of the Redis server # and persistence, you may want to disable this feature so that Redis will # continue to work as usual even if there are problems with disk, # permissions, and so forth. stop-writes-on-bgsave-error yes #如果持久化出错，是否继续工作 # Compress string objects using LZF when dump .rdb databases? # By default compression is enabled as it\u0026#39;s almost always a win. # If you want to save some CPU in the saving child set it to \u0026#39;no\u0026#39; but # the dataset will likely be bigger if you have compressible values or keys. rdbcompression yes #是否压缩rdb文件，需要消耗一些cpu资源 # Since version 5 of RDB a CRC64 checksum is placed at the end of the file. # This makes the format more resistant to corruption but there is a performance # hit to pay (around 10%) when saving and loading RDB files, so you can disable it # for maximum performances. # # RDB files created with checksum disabled have a checksum of zero that will # tell the loading code to skip the check. rdbchecksum yes #保存rdb文件时是否进行校验 # Enables or disables full sanitization checks for ziplist and listpack etc when # loading an RDB or RESTORE payload. This reduces the chances of a assertion or # crash later on while processing commands. # Options: # no - Never perform full sanitization # yes - Always perform full sanitization # clients - Perform full sanitization only for user connections. # Excludes: RDB files, RESTORE commands received from the master # connection, and client connections which have the # skip-sanitize-payload ACL flag. # The default should be \u0026#39;clients\u0026#39; but since it currently affects cluster # resharding via MIGRATE, it is temporarily set to \u0026#39;no\u0026#39; by default. # # sanitize-dump-payload no # The filename where to dump the DB dbfilename dump.rdb #rdb文件名 # Remove RDB files used by replication in instances without persistence # enabled. By default this option is disabled, however there are environments # where for regulations or other security concerns, RDB files persisted on # disk by masters in order to feed replicas, or stored on disk by replicas # in order to load them for the initial synchronization, should be deleted # ASAP. Note that this option ONLY WORKS in instances that have both AOF # and RDB persistence disabled, otherwise is completely ignored. # # An alternative (and sometimes better) way to obtain the same effect is # to use diskless replication on both master and replicas instances. However # in the case of replicas, diskless is not always an option. rdb-del-sync-files no #rdb文件是否删除同步锁 # The working directory. # # The DB will be written inside this directory, with the filename specified # above using the \u0026#39;dbfilename\u0026#39; configuration directive. # # The Append Only File will also be created inside this directory. # # Note that you must specify a directory here, not a file name. dir ./ #rdb文件保存目录     主从复制 (REPLICATION)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120  ################################# REPLICATION ################################# # Master-Replica replication. Use replicaof to make a Redis instance a copy of # another Redis server. A few things to understand ASAP about Redis replication. # # +------------------+ +---------------+ # | Master | ---\u0026gt; | Replica | # | (receive writes) | | (exact copy) | # +------------------+ +---------------+ # # 1) Redis replication is asynchronous, but you can configure a master to # stop accepting writes if it appears to be not connected with at least # a given number of replicas. # 2) Redis replicas are able to perform a partial resynchronization with the # master if the replication link is lost for a relatively small amount of # time. You may want to configure the replication backlog size (see the next # sections of this file) with a sensible value depending on your needs. # 3) Replication is automatic and does not need user intervention. After a # network partition replicas automatically try to reconnect to masters # and resynchronize with them. # # replicaof \u0026lt;masterip\u0026gt; \u0026lt;masterport\u0026gt; #配置主机的ip和端口 # If the master is password protected (using the \u0026#34;requirepass\u0026#34; configuration # directive below) it is possible to tell the replica to authenticate before # starting the replication synchronization process, otherwise the master will # refuse the replica request. # # masterauth \u0026lt;master-password\u0026gt; #配置主机的密码 # # However this is not enough if you are using Redis ACLs (for Redis version # 6 or greater), and the default user is not capable of running the PSYNC # command and/or other commands needed for replication. In this case it\u0026#39;s # better to configure a special user to use with replication, and specify the # masteruser configuration as such: # # masteruser \u0026lt;username\u0026gt; #配置主机的用户名 # # When masteruser is specified, the replica will authenticate against its # master using the new AUTH form: AUTH \u0026lt;username\u0026gt; \u0026lt;password\u0026gt;. # When a replica loses its connection with the master, or when the replication # is still in progress, the replica can act in two different ways: # # 1) if replica-serve-stale-data is set to \u0026#39;yes\u0026#39; (the default) the replica will # still reply to client requests, possibly with out of date data, or the # data set may just be empty if this is the first synchronization. # # 2) If replica-serve-stale-data is set to \u0026#39;no\u0026#39; the replica will reply with error # \u0026#34;MASTERDOWN Link with MASTER is down and replica-serve-stale-data is set to \u0026#39;no\u0026#39;\u0026#34; # to all data access commands, excluding commands such as: # INFO, REPLICAOF, AUTH, SHUTDOWN, REPLCONF, ROLE, CONFIG, SUBSCRIBE, # UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH, PUBSUB, COMMAND, POST, # HOST and LATENCY. # replica-serve-stale-data yes #当主机和从机之前断开连接后，从机是否继续向客户端提供查询服务；yes表示继续提供，no表示除了不涉及查询的命令可以执行，其他命令均返回提示信息 # You can configure a replica instance to accept writes or not. Writing against # a replica instance may be useful to store some ephemeral data (because data # written on a replica will be easily deleted after resync with the master) but # may also cause problems if clients are writing to it because of a # misconfiguration. # # Since Redis 2.6 by default replicas are read-only. # # Note: read only replicas are not designed to be exposed to untrusted clients # on the internet. It\u0026#39;s just a protection layer against misuse of the instance. # Still a read only replica exports by default all the administrative commands # such as CONFIG, DEBUG, and so forth. To a limited extent you can improve # security of read only replicas using \u0026#39;rename-command\u0026#39; to shadow all the # administrative / dangerous commands. replica-read-only yes #设置从节点只读命令 # Replication SYNC strategy: disk or socket. # # New replicas and reconnecting replicas that are not able to continue the # replication process just receiving differences, need to do what is called a # \u0026#34;full synchronization\u0026#34;. An RDB file is transmitted from the master to the # replicas. # # The transmission can happen in two different ways: # # 1) Disk-backed: The Redis master creates a new process that writes the RDB # file on disk. Later the file is transferred by the parent # process to the replicas incrementally. # 2) Diskless: The Redis master creates a new process that directly writes the # RDB file to replica sockets, without touching the disk at all. # # With disk-backed replication, while the RDB file is generated, more replicas # can be queued and served with the RDB file as soon as the current child # producing the RDB file finishes its work. With diskless replication instead # once the transfer starts, new replicas arriving will be queued and a new # transfer will start when the current one terminates. # # When diskless replication is used, the master waits a configurable amount of # time (in seconds) before starting the transfer in the hope that multiple # replicas will arrive and the transfer can be parallelized. # # With slow disks and fast (large bandwidth) networks, diskless replication # works better. repl-diskless-sync yes # When diskless replication is enabled, it is possible to configure the delay # the server waits in order to spawn the child that transfers the RDB via socket # to the replicas. # # This is important since once the transfer starts, it is not possible to serve # new replicas arriving, that will be queued for the next RDB transfer, so the # server waits a delay in order to let more replicas arrive. # # The delay is specified in seconds, and by default is 5 seconds. To disable # it entirely just set it to 0 seconds and the transfer will start ASAP. repl-diskless-sync-delay 5 # When diskless replication is enabled with a delay, it is possible to let # the replication start before the maximum delay is reached if the maximum # number of replicas expected have connected. Default of 0 means that the # maximum is not defined and Redis will wait the full delay. repl-diskless-sync-max-replicas 0 ...     安全 (SECURITY)\n1 2 3 4 5  config get requirepass #查看密码设置 config set requirepass 123456 #设置密码 auth 123456 #使用密码登录     客户端限制\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80  ################################### CLIENTS #################################### # Set the max number of connected clients at the same time. By default # this limit is set to 10000 clients, however if the Redis server is not # able to configure the process file limit to allow for the specified limit # the max number of allowed clients is set to the current file limit # minus 32 (as Redis reserves a few file descriptors for internal uses). # # Once the limit is reached Redis will close all the new connections sending # an error \u0026#39;max number of clients reached\u0026#39;. # # IMPORTANT: When Redis Cluster is used, the max number of connections is also # shared with the cluster bus: every node in the cluster will use two # connections, one incoming and another outgoing. It is important to size the # limit accordingly in case of very large clusters. # # maxclients 10000 #设置最大客户端数量 ############################## MEMORY MANAGEMENT ################################ # Set a memory usage limit to the specified amount of bytes. # When the memory limit is reached Redis will try to remove keys # according to the eviction policy selected (see maxmemory-policy). # # If Redis can\u0026#39;t remove keys according to the policy, or if the policy is # set to \u0026#39;noeviction\u0026#39;, Redis will start to reply with errors to commands # that would use more memory, like SET, LPUSH, and so on, and will continue # to reply to read-only commands like GET. # # This option is usually useful when using Redis as an LRU or LFU cache, or to # set a hard memory limit for an instance (using the \u0026#39;noeviction\u0026#39; policy). # # WARNING: If you have replicas attached to an instance with maxmemory on, # the size of the output buffers needed to feed the replicas are subtracted # from the used memory count, so that network problems / resyncs will # not trigger a loop where keys are evicted, and in turn the output # buffer of replicas is full with DELs of keys evicted triggering the deletion # of more keys, and so forth until the database is completely emptied. # # In short... if you have replicas attached it is suggested that you set a lower # limit for maxmemory so that there is some free RAM on the system for replica # output buffers (but this is not needed if the policy is \u0026#39;noeviction\u0026#39;). # # maxmemory \u0026lt;bytes\u0026gt; #最大内存设置 # MAXMEMORY POLICY: how Redis will select what to remove when maxmemory # is reached. You can select one from the following behaviors: # # volatile-lru -\u0026gt; Evict using approximated LRU, only keys with an expire set. # allkeys-lru -\u0026gt; Evict any key using approximated LRU. # volatile-lfu -\u0026gt; Evict using approximated LFU, only keys with an expire set. # allkeys-lfu -\u0026gt; Evict any key using approximated LFU. # volatile-random -\u0026gt; Remove a random key having an expire set. # allkeys-random -\u0026gt; Remove a random key, any key. # volatile-ttl -\u0026gt; Remove the key with the nearest expire time (minor TTL) # noeviction -\u0026gt; Don\u0026#39;t evict anything, just return an error on write operations. # # LRU means Least Recently Used # LFU means Least Frequently Used # # Both LRU, LFU and volatile-ttl are implemented using approximated # randomized algorithms. # # Note: with any of the above policies, when there are no suitable keys for # eviction, Redis will return an error on write operations that require # more memory. These are usually commands that create new keys, add data or # modify existing keys. A few examples are: SET, INCR, HSET, LPUSH, SUNIONSTORE, # SORT (due to the STORE argument), and EXEC (if the transaction includes any # command that requires memory). # # The default is: # # maxmemory-policy noeviction #内存到达上限之后的处理策略 # # 1.volatile-lru: 只对设置了过期时间的key进行LRU # 2.allkeys-lru: 删除lru算法的key # 3.volatile-random: 随机删除即将过期的key # 4.allkeys-random: 随机删除 # 5.volatile-ttl: 删除即将过期的 # 6.noeviction: 永不过期, 返回错误     AOF配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81  ############################## APPEND ONLY MODE ############################### # By default Redis asynchronously dumps the dataset on disk. This mode is # good enough in many applications, but an issue with the Redis process or # a power outage may result into a few minutes of writes lost (depending on # the configured save points). # # The Append Only File is an alternative persistence mode that provides # much better durability. For instance using the default data fsync policy # (see later in the config file) Redis can lose just one second of writes in a # dramatic event like a server power outage, or a single write if something # wrong with the Redis process itself happens, but the operating system is # still running correctly. # # AOF and RDB persistence can be enabled at the same time without problems. # If the AOF is enabled on startup Redis will load the AOF, that is the file # with the better durability guarantees. # # Please check https://redis.io/topics/persistence for more information. appendonly no #默认不开启aof模式，使用rdb方式持久化，大多数情况下rdb完全够用 # The base name of the append only file. # # Redis 7 and newer use a set of append-only files to persist the dataset # and changes applied to it. There are two basic types of files in use: # # - Base files, which are a snapshot representing the complete state of the # dataset at the time the file was created. Base files can be either in # the form of RDB (binary serialized) or AOF (textual commands). # - Incremental files, which contain additional commands that were applied # to the dataset following the previous file. # # In addition, manifest files are used to track the files and the order in # which they were created and should be applied. # # Append-only file names are created by Redis following a specific pattern. # The file name\u0026#39;s prefix is based on the \u0026#39;appendfilename\u0026#39; configuration # parameter, followed by additional information about the sequence and type. # # For example, if appendfilename is set to appendonly.aof, the following file # names could be derived: # # - appendonly.aof.1.base.rdb as a base file. # - appendonly.aof.1.incr.aof, appendonly.aof.2.incr.aof as incremental files. # - appendonly.aof.manifest as a manifest file. appendfilename \u0026#34;appendonly.aof\u0026#34; #aof文件名设置 # For convenience, Redis stores all persistent append-only files in a dedicated # directory. The name of the directory is determined by the appenddirname # configuration parameter. appenddirname \u0026#34;appendonlydir\u0026#34; #aof文件目录设置 # The fsync() call tells the Operating System to actually write data on disk # instead of waiting for more data in the output buffer. Some OS will really flush # data on disk, some other OS will just try to do it ASAP. # # Redis supports three different modes: # # no: don\u0026#39;t fsync, just let the OS flush the data when it wants. Faster. # always: fsync after every write to the append only log. Slow, Safest. # everysec: fsync only one time every second. Compromise. # # The default is \u0026#34;everysec\u0026#34;, as that\u0026#39;s usually the right compromise between # speed and data safety. It\u0026#39;s up to you to understand if you can relax this to # \u0026#34;no\u0026#34; that will let the operating system flush the output buffer when # it wants, for better performances (but if you can live with the idea of # some data loss consider the default persistence mode that\u0026#39;s snapshotting), # or on the contrary, use \u0026#34;always\u0026#34; that\u0026#39;s very slow but a bit safer than # everysec. # # More details please check the following article: # http://antirez.com/post/redis-persistence-demystified.html # # If unsure, use \u0026#34;everysec\u0026#34;. # appendfsync always #每次修改都同步，消耗性能 appendfsync everysec #每秒执行一次同步数据，如果服务器宕机可能会丢失数据 # appendfsync no #不同步     Redis持久化 Redis是内存数据库，为了防止断电易失。Redis默认采用RDB持久化方式。\nRDB 在指定的时间间隔内将内存中的数据集快照写入磁盘，恢复时直接将快照读入内存中。\n 步骤解读：\n Redis会单独创建(fork)一个子进程来进行持久化 子进程将内存中的数据写入临时的rdb文件(dump.rdb) 父进程则继续处理Redis客户端发送的指令 临时rdb生成完成后，将新的rdb文件替换之前持久化生成的文件，子进程结束  整个过程主进程不会进行任何IO操作，所以保证了性能，但缺点是最后一次持久化后的数据可能会丢失。\n RDB持久化触发情景：\n 满足配置文件中设置的save配置时 redis客户端发送save命令 退出redis服务(shutdown命令)时 执行flushall命令时  只要将rdb文件放在redis启动目录下，redis启动时会自动检查并读取rdb文件进行数据恢复\n查看redis启动目录：config get dir\n优点\n 适合大规模的数据恢复 对数据完成性要求不高，如果redis服务器在还不满足save配置的时候宕机，就会发生数据丢失  缺点\n 需要满足save配置的时间间隔才会触发rdb持久化 如果服务器宕机，最后一次持久化后修改的数据会丢失  AOF (Append Only File) 将所有命令记录下来（历史记录），恢复的时候就是把这个文件重新执行一遍。\n以日志的形式记录每个写命令，追加到日志结尾。\nredis启动后会读取该文件重新构建数据，也就是重新执行一遍日志中记录的所有写操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156  ############################## APPEND ONLY MODE ############################### # By default Redis asynchronously dumps the dataset on disk. This mode is # good enough in many applications, but an issue with the Redis process or # a power outage may result into a few minutes of writes lost (depending on # the configured save points). # # The Append Only File is an alternative persistence mode that provides # much better durability. For instance using the default data fsync policy # (see later in the config file) Redis can lose just one second of writes in a # dramatic event like a server power outage, or a single write if something # wrong with the Redis process itself happens, but the operating system is # still running correctly. # # AOF and RDB persistence can be enabled at the same time without problems. # If the AOF is enabled on startup Redis will load the AOF, that is the file # with the better durability guarantees. # # Please check https://redis.io/topics/persistence for more information. appendonly no #默认是不开启的，设置成yes为开启 # The base name of the append only file. # # Redis 7 and newer use a set of append-only files to persist the dataset # and changes applied to it. There are two basic types of files in use: # # - Base files, which are a snapshot representing the complete state of the # dataset at the time the file was created. Base files can be either in # the form of RDB (binary serialized) or AOF (textual commands). # - Incremental files, which contain additional commands that were applied # to the dataset following the previous file. # # In addition, manifest files are used to track the files and the order in # which they were created and should be applied. # # Append-only file names are created by Redis following a specific pattern. # The file name\u0026#39;s prefix is based on the \u0026#39;appendfilename\u0026#39; configuration # parameter, followed by additional information about the sequence and type. # # For example, if appendfilename is set to appendonly.aof, the following file # names could be derived: # # - appendonly.aof.1.base.rdb as a base file. # - appendonly.aof.1.incr.aof, appendonly.aof.2.incr.aof as incremental files. # - appendonly.aof.manifest as a manifest file. appendfilename \u0026#34;appendonly.aof\u0026#34; # For convenience, Redis stores all persistent append-only files in a dedicated # directory. The name of the directory is determined by the appenddirname # configuration parameter. appenddirname \u0026#34;appendonlydir\u0026#34; # The fsync() call tells the Operating System to actually write data on disk # instead of waiting for more data in the output buffer. Some OS will really flush # data on disk, some other OS will just try to do it ASAP. # # Redis supports three different modes: # # no: don\u0026#39;t fsync, just let the OS flush the data when it wants. Faster. # always: fsync after every write to the append only log. Slow, Safest. # everysec: fsync only one time every second. Compromise. # # The default is \u0026#34;everysec\u0026#34;, as that\u0026#39;s usually the right compromise between # speed and data safety. It\u0026#39;s up to you to understand if you can relax this to # \u0026#34;no\u0026#34; that will let the operating system flush the output buffer when # it wants, for better performances (but if you can live with the idea of # some data loss consider the default persistence mode that\u0026#39;s snapshotting), # or on the contrary, use \u0026#34;always\u0026#34; that\u0026#39;s very slow but a bit safer than # everysec. # # More details please check the following article: # http://antirez.com/post/redis-persistence-demystified.html # # If unsure, use \u0026#34;everysec\u0026#34;. # appendfsync always #每次修改追加一次，并同步到磁盘 appendfsync everysec #aof持久化策略，每秒钟追加一次，并同步到磁盘中 # appendfsync no #只追加到aof文件，不写入磁盘，交给操作系统去决定什么时候要写到磁盘 # When the AOF fsync policy is set to always or everysec, and a background # saving process (a background save or AOF log background rewriting) is # performing a lot of I/O against the disk, in some Linux configurations # Redis may block too long on the fsync() call. Note that there is no fix for # this currently, as even performing fsync in a different thread will block # our synchronous write(2) call. # # In order to mitigate this problem it\u0026#39;s possible to use the following option # that will prevent fsync() from being called in the main process while a # BGSAVE or BGREWRITEAOF is in progress. # # This means that while another child is saving, the durability of Redis is # the same as \u0026#34;appendfsync no\u0026#34;. In practical terms, this means that it is # possible to lose up to 30 seconds of log in the worst scenario (with the # default Linux settings). # # If you have latency problems turn this to \u0026#34;yes\u0026#34;. Otherwise leave it as # \u0026#34;no\u0026#34; that is the safest pick from the point of view of durability. no-appendfsync-on-rewrite no #当写入磁盘时由于大量IO操作，可能会阻塞主进程。如果设置为yes那么就不再写入磁盘中，而是交给操作系统决定何时写入磁盘，减少了IO操作，也就不会阻塞，但是数据可能丢失，因为没有及时写入磁盘中。默认为no，这样是安全的。 # Automatic rewrite of the append only file. # Redis is able to automatically rewrite the log file implicitly calling # BGREWRITEAOF when the AOF log size grows by the specified percentage. # # This is how it works: Redis remembers the size of the AOF file after the # latest rewrite (if no rewrite has happened since the restart, the size of # the AOF at startup is used). # # This base size is compared to the current size. If the current size is # bigger than the specified percentage, the rewrite is triggered. Also # you need to specify a minimal size for the AOF file to be rewritten, this # is useful to avoid rewriting the AOF file even if the percentage increase # is reached but it is still pretty small. # # Specify a percentage of zero in order to disable the automatic AOF # rewrite feature. auto-aof-rewrite-percentage 100 #当aof文件大小超过上一次重写的aof文件的百分之多少进行重写 auto-aof-rewrite-min-size 64mb #设置允许重写的最小文件大小。防止超过百分比后文件依然很小，这时如果没超过最小文件大小就不重写 # An AOF file may be found to be truncated at the end during the Redis # startup process, when the AOF data gets loaded back into memory. # This may happen when the system where Redis is running # crashes, especially when an ext4 filesystem is mounted without the # data=ordered option (however this can\u0026#39;t happen when Redis itself # crashes or aborts but the operating system still works correctly). # # Redis can either exit with an error when this happens, or load as much # data as possible (the default now) and start if the AOF file is found # to be truncated at the end. The following option controls this behavior. # # If aof-load-truncated is set to yes, a truncated AOF file is loaded and # the Redis server starts emitting a log to inform the user of the event. # Otherwise if the option is set to no, the server aborts with an error # and refuses to start. When the option is set to no, the user requires # to fix the AOF file using the \u0026#34;redis-check-aof\u0026#34; utility before to restart # the server. # # Note that if the AOF file will be found to be corrupted in the middle # the server will still exit with an error. This option only applies when # Redis will try to read more data from the AOF file but not enough bytes # will be found. aof-load-truncated yes # Redis can create append-only base files in either RDB or AOF formats. Using # the RDB format is always faster and more efficient, and disabling it is only # supported for backward compatibility purposes. aof-use-rdb-preamble yes # Redis supports recording timestamp annotations in the AOF to support restoring # the data from a specific point-in-time. However, using this capability changes # the AOF format in a way that may not be compatible with existing AOF parsers. aof-timestamp-enabled no   如果aof文件有错误，那么无法启动redis客户端，可以用redis-check-aof来修复aof文件，但是数据会有所缺失\n1  redis-check-aof --fix appendonly.aof   优点\n 每一次修改都追加，文件完整性好，但是性能消耗高 每秒同步一次，可能会丢失一秒的数据 从不同步，效率最高  缺点\n 相对于数据文件来说，aof文件要远远大于rdb文件，修复的速度也比rdb慢 因为aof本质上是追加写文件，是IO操作，所以aof运行效率也比rdb慢，所以redis默认就是rdb持久化  扩展\n 如果两种持久化同时开启，redis重启时会优先载入aof文件来恢复数据\n一般rdb用于备份redis数据，只在从服务器上进行备份，15分钟备份一次，也就是save 900 1\n Redis发布订阅 redis发布订阅是一种消息模式，发送者发送消息，订阅者接收消息\nredis客户端可以订阅任意数量的频道\n1 2 3 4 5 6 7 8 9 10 11  psubscribe pattern... #订阅一个或多个符合给定模式的频道 pubsub subcommand argument... #查看订阅与发布系统状态 publish channel message #将信息发送到指定频道 subscribe channel... #订阅一个或多个频道 punsubscribe pattern... #退订所有给定模式的频道 unsubscribe channel... #退订给定的频道   底层实现\n每个频道是一个字典，字典的键用来标识频道，字典的值是一个链表，链表中是该频道的所有订阅者\n使用场景\n 实时消息系统 实时聊天室 订阅公众号等  Redis主从复制 概念 主从复制是指将一台Redis服务器的数据复制到从节点的服务器上，其中主节点负责写数据，从节点负责读取数据。主从复制是单向的，有主节点到从节点。主节点可以有任意个从节点，而从节点只能有一个主节点。\n作用  数据备份：主从复制实现了数据的热备份 故障修复：当主节点出现问题可以使用从节点 负载均衡：主从复制加读写分离，写数据时请求主服务器，读数据时请求从服务器，可以分担服务器的访问压力 高可用基石：主从复制是哨兵模式和集群实施的基础  一般redis需要配置两从一主，只配置一台redis服务器有两个弊端：\n 从结构上来说，单个服务器可能宕机，并且所有请求访问一台服务器，压力太大 从容量上来说，单个服务器容量有限，一般单台redis服务器的最大内存使用量应该不超过20G  搭建环境 1 2 3 4 5 6 7 8 9 10 11 12 13 14  info replication #查看主从复制信息 # Replication role:master #角色 connected_slaves:0 #连接的从节点个数 master_failover_state:no-failover master_replid:9a9ee312a4acaeb3ec299c0a9082833d116fe92d master_replid2:0000000000000000000000000000000000000000 master_repl_offset:0 second_repl_offset:-1 repl_backlog_active:0 repl_backlog_size:1048576 repl_backlog_first_byte_offset:0 repl_backlog_histlen:0   在一台服务器上启动3个redis服务进程来模拟一主两从\n 复制出3个配置文件，并修改端口号、日志文件名称、dump文件名称、pid名称 使用不同的配置文件启动redis服务   配置从机\n1  slaveof host port #配置以host:port为主机     在主机上可以查看到从机的信息\n  除了通过命令配置主从之外还可以修改配置文件进行配置，这样是永久配置。具体看conf详解\n测试 当主机断开连接后，两台从机依然是从机的角色，主机重新连接后，依然可以写数据。\n当从机断开连接后再次重新连接，如果从机的角色为主机 (通过命令配置从机的方式重启后角色变为主机) ，则无法同步主机的数据，只要重新配置为从机就可以同步到主机上的所有数据；如果从机的角色还是从机 (修改配置文件的方式重启后依然为从机) ，则能够同步到宕机期间主机写入的数据。\n只要从机连接到主机，从机就会向主机发送sync同步命令，主机将数据文件传送给从机，进行一次全量同步。全量同步之后主机上的写操作都是增量同步给从机。\n第二种主从复制方法 如果主机宕机后，需要手动执行slaveof no one命令将一个从机设置为主机。当原来的主机重新连接后就会出现两个主机，还需要用slaveof ip porrt手动改为从机。\n哨兵模式 Redis2.8之后开始提供哨兵模式，当主服务器宕机后能够自动将一台从机切换为主机\n原理 哨兵是一个独立的进程，通过不断向所有redis服务器发送命令来判断各个redis服务器是否宕机\n当哨兵检测到主服务器宕机后，会自动将一台从服务器切换为主服务器，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让从服务器切换主机\n但是如果只有一个哨兵，哨兵进程也可能死掉，所以多哨兵模式就是防止一个哨兵挂掉\n如果主服务器宕机，哨兵1检测到之后不会马上重新选择主服务器，只是认为主服务器现在不可用，这个现象称为主观下线，如果还有其他哨兵也检测到主服务器不可用，达到一定数量之后，所有哨兵会投票选出一个从服务器来暂时充当主服务器，由某个哨兵发布消息通知服务器切换自己的主服务器。\n配置哨兵模式 哨兵配置文件为sentinel.conf\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370  # Example sentinel.conf # By default protected mode is disabled in sentinel mode. Sentinel is reachable # from interfaces different than localhost. Make sure the sentinel instance is # protected from the outside world via firewalling or other means. protected-mode no #被保护模式，默认关闭 # port \u0026lt;sentinel-port\u0026gt; # The port that this sentinel instance will run on port 26379 #哨兵运行端口 # By default Redis Sentinel does not run as a daemon. Use \u0026#39;yes\u0026#39; if you need it. # Note that Redis will write a pid file in /var/run/redis-sentinel.pid when # daemonized. daemonize no #守护进程默认关闭 # When running daemonized, Redis Sentinel writes a pid file in # /var/run/redis-sentinel.pid by default. You can specify a custom pid file # location here. pidfile /var/run/redis-sentinel.pid #开启守护进程后哨兵进程的pid文件 # Specify the log file name. Also the empty string can be used to force # Sentinel to log on the standard output. Note that if you use standard # output for logging but daemonize, logs will be sent to /dev/null logfile \u0026#34;\u0026#34; #日志文件 # sentinel announce-ip \u0026lt;ip\u0026gt; # sentinel announce-port \u0026lt;port\u0026gt; # # The above two configuration directives are useful in environments where, # because of NAT, Sentinel is reachable from outside via a non-local address. # # When announce-ip is provided, the Sentinel will claim the specified IP address # in HELLO messages used to gossip its presence, instead of auto-detecting the # local address as it usually does. # # Similarly when announce-port is provided and is valid and non-zero, Sentinel # will announce the specified TCP port. # # The two options don\u0026#39;t need to be used together, if only announce-ip is # provided, the Sentinel will announce the specified IP and the server port # as specified by the \u0026#34;port\u0026#34; option. If only announce-port is provided, the # Sentinel will announce the auto-detected local IP and the specified port. # # Example: # # sentinel announce-ip 1.2.3.4 # dir \u0026lt;working-directory\u0026gt; # Every long running process should have a well-defined working directory. # For Redis Sentinel to chdir to /tmp at startup is the simplest thing # for the process to don\u0026#39;t interfere with administrative tasks such as # unmounting filesystems. dir /tmp #哨兵sentinel的工作目录 # sentinel monitor \u0026lt;master-name\u0026gt; \u0026lt;ip\u0026gt; \u0026lt;redis-port\u0026gt; \u0026lt;quorum\u0026gt; # # Tells Sentinel to monitor this master, and to consider it in O_DOWN # (Objectively Down) state only if at least \u0026lt;quorum\u0026gt; sentinels agree. # # Note that whatever is the ODOWN quorum, a Sentinel will require to # be elected by the majority of the known Sentinels in order to # start a failover, so no failover can be performed in minority. # # Replicas are auto-discovered, so you don\u0026#39;t need to specify replicas in # any way. Sentinel itself will rewrite this configuration file adding # the replicas using additional configuration options. # Also note that the configuration file is rewritten when a # replica is promoted to master. # # Note: master name should not include special characters or spaces. # The valid charset is A-z 0-9 and the three characters \u0026#34;.-_\u0026#34;. sentinel monitor mymaster 127.0.0.1 6379 2 #quorum表示当多少个哨兵检测到主服务器宕机之后开始重新选择 # sentinel auth-pass \u0026lt;master-name\u0026gt; \u0026lt;password\u0026gt; # # Set the password to use to authenticate with the master and replicas. # Useful if there is a password set in the Redis instances to monitor. # # Note that the master password is also used for replicas, so it is not # possible to set a different password in masters and replicas instances # if you want to be able to monitor these instances with Sentinel. # # However you can have Redis instances without the authentication enabled # mixed with Redis instances requiring the authentication (as long as the # password set is the same for all the instances requiring the password) as # the AUTH command will have no effect in Redis instances with authentication # switched off. # # Example: # # sentinel auth-pass mymaster MySUPER--secret-0123passw0rd #哨兵连接主从的密码 # sentinel auth-user \u0026lt;master-name\u0026gt; \u0026lt;username\u0026gt; # # This is useful in order to authenticate to instances having ACL capabilities, # that is, running Redis 6.0 or greater. When just auth-pass is provided the # Sentinel instance will authenticate to Redis using the old \u0026#34;AUTH \u0026lt;pass\u0026gt;\u0026#34; # method. When also an username is provided, it will use \u0026#34;AUTH \u0026lt;user\u0026gt; \u0026lt;pass\u0026gt;\u0026#34;. # In the Redis servers side, the ACL to provide just minimal access to # Sentinel instances, should be configured along the following lines: # # user sentinel-user \u0026gt;somepassword +client +subscribe +publish \\ # +ping +info +multi +slaveof +config +client +exec on # sentinel down-after-milliseconds \u0026lt;master-name\u0026gt; \u0026lt;milliseconds\u0026gt; # # Number of milliseconds the master (or any attached replica or sentinel) should # be unreachable (as in, not acceptable reply to PING, continuously, for the # specified period) in order to consider it in S_DOWN state (Subjectively # Down). # # Default is 30 seconds. sentinel down-after-milliseconds mymaster 30000 #指定多少毫秒之后，如果主节点没有应答，哨兵就认为主节点下线，默认30秒 # IMPORTANT NOTE: starting with Redis 6.2 ACL capability is supported for # Sentinel mode, please refer to the Redis website https://redis.io/topics/acl # for more details. # Sentinel\u0026#39;s ACL users are defined in the following format: # # user \u0026lt;username\u0026gt; ... acl rules ... # # For example: # # user worker +@admin +@connection ~* on \u0026gt;ffa9203c493aa99 # # For more information about ACL configuration please refer to the Redis # website at https://redis.io/topics/acl and redis server configuration  # template redis.conf. # ACL LOG # # The ACL Log tracks failed commands and authentication events associated # with ACLs. The ACL Log is useful to troubleshoot failed commands blocked  # by ACLs. The ACL Log is stored in memory. You can reclaim memory with  # ACL LOG RESET. Define the maximum entry length of the ACL Log below. acllog-max-len 128 # Using an external ACL file # # Instead of configuring users here in this file, it is possible to use # a stand-alone file just listing users. The two methods cannot be mixed: # if you configure users here and at the same time you activate the external # ACL file, the server will refuse to start. # # The format of the external ACL user file is exactly the same as the # format that is used inside redis.conf to describe users. # # aclfile /etc/redis/sentinel-users.acl # requirepass \u0026lt;password\u0026gt; # # You can configure Sentinel itself to require a password, however when doing # so Sentinel will try to authenticate with the same password to all the # other Sentinels. So you need to configure all your Sentinels in a given # group with the same \u0026#34;requirepass\u0026#34; password. Check the following documentation # for more info: https://redis.io/topics/sentinel # # IMPORTANT NOTE: starting with Redis 6.2 \u0026#34;requirepass\u0026#34; is a compatibility # layer on top of the ACL system. The option effect will be just setting # the password for the default user. Clients will still authenticate using # AUTH \u0026lt;password\u0026gt; as usually, or more explicitly with AUTH default \u0026lt;password\u0026gt; # if they follow the new protocol: both will work. # # New config files are advised to use separate authentication control for # incoming connections (via ACL), and for outgoing connections (via # sentinel-user and sentinel-pass)  # # The requirepass is not compatible with aclfile option and the ACL LOAD # command, these will cause requirepass to be ignored. # sentinel sentinel-user \u0026lt;username\u0026gt; # # You can configure Sentinel to authenticate with other Sentinels with specific # user name.  # sentinel sentinel-pass \u0026lt;password\u0026gt; # # The password for Sentinel to authenticate with other Sentinels. If sentinel-user # is not configured, Sentinel will use \u0026#39;default\u0026#39; user with sentinel-pass to authenticate. # sentinel parallel-syncs \u0026lt;master-name\u0026gt; \u0026lt;numreplicas\u0026gt; # # How many replicas we can reconfigure to point to the new replica simultaneously # during the failover. Use a low number if you use the replicas to serve query # to avoid that all the replicas will be unreachable at about the same # time while performing the synchronization with the master. sentinel parallel-syncs mymaster 1 #这个配置项指定了在主备切换时最多可以有多少个slave同时对新的master进行同步，这个数字越小，完成主备切换的时间就越长。但是如果这个数字太大，就意味有多少个slave因为同步数据而不可用，一般应该保证每次只有一个slave处于不能处理命令请求的状态。 # sentinel failover-timeout \u0026lt;master-name\u0026gt; \u0026lt;milliseconds\u0026gt; # # Specifies the failover timeout in milliseconds. It is used in many ways: # # - The time needed to re-start a failover after a previous failover was # already tried against the same master by a given Sentinel, is two # times the failover timeout. # # - The time needed for a replica replicating to a wrong master according # to a Sentinel current configuration, to be forced to replicate # with the right master, is exactly the failover timeout (counting since # the moment a Sentinel detected the misconfiguration). # # - The time needed to cancel a failover that is already in progress but # did not produced any configuration change (SLAVEOF NO ONE yet not # acknowledged by the promoted replica). # # - The maximum time a failover in progress waits for all the replicas to be # reconfigured as replicas of the new master. However even after this time # the replicas will be reconfigured by the Sentinels anyway, but not with # the exact parallel-syncs progression as specified. # # Default is 3 minutes. # 故障转移的超时时间 failover-timeout 可以用在以下这些方面：  # 1. 同一个sentinel对同一个master两次failover之间的间隔时间。 # 2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。 # 3.当想要取消一个正在进行的failover所需要的时间。  # 4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向 master，但是就不按parallel-syncs所配置的规则来了 # 默认三分钟 # sentinel failover-timeout mymaster 180000 # SCRIPTS EXECUTION # # sentinel notification-script and sentinel reconfig-script are used in order # to configure scripts that are called to notify the system administrator # or to reconfigure clients after a failover. The scripts are executed # with the following rules for error handling: # # If script exits with \u0026#34;1\u0026#34; the execution is retried later (up to a maximum # number of times currently set to 10). # # If script exits with \u0026#34;2\u0026#34; (or an higher value) the script execution is # not retried. # # If script terminates because it receives a signal the behavior is the same # as exit code 1. # # A script has a maximum running time of 60 seconds. After this limit is # reached the script is terminated with a SIGKILL and the execution retried. # NOTIFICATION SCRIPT # # sentinel notification-script \u0026lt;master-name\u0026gt; \u0026lt;script-path\u0026gt; #  # Call the specified notification script for any sentinel event that is # generated in the WARNING level (for instance -sdown, -odown, and so forth). # This script should notify the system administrator via email, SMS, or any # other messaging system, that there is something wrong with the monitored # Redis systems. # # The script is called with just two arguments: the first is the event type # and the second the event description. # # The script must exist and be executable in order for sentinel to start if # this option is provided. # # Example: # # 配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。 # 对于脚本的运行结果有以下规则： # 若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10 # 若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。 # 如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。 # 一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。 # 通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本， # 这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件# 的类型，一个是事件的描述。 # 如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正 # 常启动成功。 # # sentinel notification-script mymaster /var/redis/notify.sh # CLIENTS RECONFIGURATION SCRIPT # # sentinel client-reconfig-script \u0026lt;master-name\u0026gt; \u0026lt;script-path\u0026gt; # # When the master changed because of a failover a script can be called in # order to perform application-specific tasks to notify the clients that the # configuration has changed and the master is at a different address. #  # The following arguments are passed to the script: # # \u0026lt;master-name\u0026gt; \u0026lt;role\u0026gt; \u0026lt;state\u0026gt; \u0026lt;from-ip\u0026gt; \u0026lt;from-port\u0026gt; \u0026lt;to-ip\u0026gt; \u0026lt;to-port\u0026gt; # # \u0026lt;state\u0026gt; is currently always \u0026#34;start\u0026#34; # \u0026lt;role\u0026gt; is either \u0026#34;leader\u0026#34; or \u0026#34;observer\u0026#34; #  # The arguments from-ip, from-port, to-ip, to-port are used to communicate # the old address of the master and the new address of the elected replica # (now a master). # # This script should be resistant to multiple invocations. # # Example: # # 客户端重新配置主节点参数脚本 # 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。 # 以下参数将会在调用脚本时传给脚本: # \u0026lt;master-name\u0026gt; \u0026lt;role\u0026gt; \u0026lt;state\u0026gt; \u0026lt;from-ip\u0026gt; \u0026lt;from-port\u0026gt; \u0026lt;to-ip\u0026gt; \u0026lt;to-port\u0026gt; # 目前\u0026lt;state\u0026gt;总是“failover”, # \u0026lt;role\u0026gt;是“leader”或者“observer”中的一个。  # 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的 # 这个脚本应该是通用的，能被多次调用，不是针对性的。 # # sentinel client-reconfig-script mymaster /var/redis/reconfig.sh # SECURITY # # By default SENTINEL SET will not be able to change the notification-script # and client-reconfig-script at runtime. This avoids a trivial security issue # where clients can set the script to anything and trigger a failover in order # to get the program executed. sentinel deny-scripts-reconfig yes # REDIS COMMANDS RENAMING (DEPRECATED) # # WARNING: avoid using this option if possible, instead use ACLs. # # Sometimes the Redis server has certain commands, that are needed for Sentinel # to work correctly, renamed to unguessable strings. This is often the case # of CONFIG and SLAVEOF in the context of providers that provide Redis as # a service, and don\u0026#39;t want the customers to reconfigure the instances outside # of the administration console. # # In such case it is possible to tell Sentinel to use different command names # instead of the normal ones. For example if the master \u0026#34;mymaster\u0026#34;, and the # associated replicas, have \u0026#34;CONFIG\u0026#34; all renamed to \u0026#34;GUESSME\u0026#34;, I could use: # # SENTINEL rename-command mymaster CONFIG GUESSME # # After such configuration is set, every time Sentinel would use CONFIG it will # use GUESSME instead. Note that there is no actual need to respect the command # case, so writing \u0026#34;config guessme\u0026#34; is the same in the example above. # # SENTINEL SET can also be used in order to perform this configuration at runtime. # # In order to set a command back to its original name (undo the renaming), it # is possible to just rename a command to itself: # # SENTINEL rename-command mymaster CONFIG CONFIG # HOSTNAMES SUPPORT # # Normally Sentinel uses only IP addresses and requires SENTINEL MONITOR # to specify an IP address. Also, it requires the Redis replica-announce-ip # keyword to specify only IP addresses. # # You may enable hostnames support by enabling resolve-hostnames. Note # that you must make sure your DNS is configured properly and that DNS # resolution does not introduce very long delays. # SENTINEL resolve-hostnames no # When resolve-hostnames is enabled, Sentinel still uses IP addresses # when exposing instances to users, configuration files, etc. If you want # to retain the hostnames when announced, enable announce-hostnames below. # SENTINEL announce-hostnames no # When master_reboot_down_after_period is set to 0, Sentinel does not fail over # when receiving a -LOADING response from a master. This was the only supported # behavior before version 7.0. # # Otherwise, Sentinel will use this value as the time (in ms) it is willing to # accept a -LOADING response after a master has been rebooted, before failing # over. SENTINEL master-reboot-down-after-period mymaster 0   启动哨兵redis-sentinel ./sentinel.conf\n如果主服务器宕机后重新连接，只能作为从服务器使用，因为主服务器已经选出\n优点\n 哨兵集群，基于主从复制，所以包含了主从复制的优点 主从可以自动切换，系统可用性更好 哨兵模式就是主从模式的升级，手动到自动，更加健壮  缺点\n redis不好在线扩容，集群容量一旦到达上限，在线扩容十分麻烦 实现哨兵模式的配置非常繁琐麻烦  Redis缓存穿透和雪崩 缓存穿透 概念 缓存穿透是指用户查询的数据在redis缓存中不存在，然后向数据库中查询也没有查到数据导致查询失败。这种现象发生很多次导致给数据库增加很大压力，这就是缓存穿透。比如在秒杀中，请求量剧增但是缓存没有命中导致服务器压力剧增。\n解决方案   布隆过滤器\n布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合就丢弃，避免了对底层数据库造成压力。\n  缓存空对象\n当数据库没有命中时，将空对象加到缓存中，同时设置一个过期时间，如果用户再查这个对象就会命中缓存，保护了底层数据库。\n但是这种方法会存在两个问题：\n 存储空值没有意义，并且会有越来越多没有意义的键 即使对空值设置了过期时间，如果原来没有值的对象被存到了数据库中就会导致一段时间缓存的值和数据库中的数据不一致的问题。  缓存击穿 概念 如果缓存中的某一个key非常热点，有大量的请求命中这个key，那么在这个key失效的瞬间，这些请求就会访问数据库，给数据库带来巨大的压力。\n解决方案   设置热点数据不过期\n不过期就会一直命中，但是可能会浪费空间\n  加互斥锁\n使用分布式锁，保证对于每个key同时只有一个线程去查询数据库，其他的线程没有获得分布式锁的权限，因此需要等待。这种方式将高并发的压力转移到了分布式锁上，对分布式锁的考验很大。\n  缓存雪崩 概念 缓存雪崩是指在某一个时间段缓存集中失效，或者是redis服务器宕机。原因是某些热点数据在同一时间被加入到缓存中并且过期时间也一致，这样就导致了在同一时间失效。服务器宕机带来的雪崩，其访问量是不可知的，所以有可能给数据库带来巨大的压力。\n解决方案   redis高可用\n增加redis服务器，搭建集群，高可用。\n  限流降级\n在缓存失效后，通过加锁或者队列来控制读数据库的线程数量，比如对同一个key只允许一个线程查询数据并写入缓存，其他线程只能等待。或者是将一些无关的服务停掉\n  数据预热\n在正式部署之前，将可能的热点数据全部访问一遍，使这些数据写入缓存。在即将发生大量并发请求前手动触发加载缓存，设置不同的过期时间，就能防止在某一时间同时失效的问题。\n    ","date":"2022-08-14T00:00:00Z","image":"https://WangZichen99.github.io/img/2022/11/autumn_forest.jpg","permalink":"https://WangZichen99.github.io/p/redisnote/","title":"Redis笔记"},{"content":"NginxNote 1、介绍   反向代理 （1）正向代理\n 在客户端配置代理服务器，通过代理服务器进行访问   （2）反向代理\n 客户端无需配置，将请求发送到反向代理服务器，反向代理服务器从真实服务器获取数据后返回到客户端。此时反向代理服务器和真实服务器被看做一个服务器，暴露的是反向代理服务器，隐藏了真实服务器的ip地址    负载均衡\n 将客户端的请求分发到不同服务器上     动静分离\n 使用不同的服务器解析动态页面和静态页面，加快解析速度，降低单个服务器的压力     2、安装Nginx  xshell连接linux操作系统  下载nginx 使用sudo -命令切换到root用户 安装编译工具及库文件yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel 安装PCRE 1 2  cd /usr/local/src wget http://downloads.sourceforge.net/project/pcre/pcre/8.45/pcre-8.45.tar.gz    解压tar -zxvf pcre-8.45.tar.gz 编译安装 1 2 3  cd pcre-8.45 ./configure make \u0026amp;\u0026amp; make install    查看版本pcre-config --version 上传nginx安装包并解压tar -zxvf nginx-1.22.0.tar.gz 编译安装  1 2 3  cd nginx-1.22.0 ./configure make \u0026amp;\u0026amp; make install   安装成功后，在/usr/local/nginx/sbin/下有nginx的启动脚本，启动nginx  1 2  cd /usr/local/nginx/sbin/ ./nginx   查看是否成功启动ps -ef|grep nginx  3、配置Nginx开放80端口 nginx配置文件位置在/usr/local/nginx/conf/nginx.conf中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  #开启防火墙 service firewalld start #重启防火墙 service firewalld restart #关闭防火墙 service firewalld stop #查看开放的端口号 firewall-cmd --list-all #设置添加http服务 firewall-cmd --add-service=http --permanent #设置开放的端口号, --permanent表示持久的 firewall-cmd --add-port=80/tcp --permanent #移除端口号 firewall-cmd --remove-port=80/tcp --permanent #重启防火墙 firewall-cmd --reload   在浏览器中输入linux的ip地址可以看到nginx的页面 4、Nginx常用命令  必须在/usr/local/nginx/sbin中执行命令   查看nginx版本号  1  ./nginx -v   启动nginx  1  ./nginx   安全退出nginx  1  ./nginx -s quit   关闭nginx  1  ./nginx -s stop   重新加载nginx  1  ./nginx -s reload   5、Nginx配置文件  nginx配置文件位置：/usr/local/nginx/conf/nginx.conf  5.1、配置文件组成部分 5.1.1、全局块  从配置文件开始到events块之前的内容，包含一些nginx服务器运行的配置命令，例如：用户组、worker process数、进程PID存放路径、日志路径等等  1  worker_process 1; 值越大，可支持的并发量越大，一般设置成CPU核心数或auto   5.1.2、events块  events块设置的是nginx服务器与用户的网络连接，例如：是否允许同时接收多个网络连接，每个worker_process支持的最大连接数等等，这部分配置对nginx的性能影响较大，在实际中应该灵活配置  1  worker_connections 1024; 每个worker process支持的最大连接数为1024   5.1.3、http块  配置最频繁的部分，例如：代理、缓存和日志等等，http块包括http全局块和server块   http全局块：包括文件引入、MIME-TYPE定义、日志定义、连接超时时间、单链接请求上限数等等 server块：和虚拟主机有密切关系，每个http块可以包含多个server块，每个server块就相当于一个虚拟主机，server块可以分为全局server块和location块，一个server块可以包含多个location块  全局server块：配置虚拟主机的监听配置和虚拟主机的名称及IP配置等等 location块：根据url对特定的请求做特定的处理，地址定向、数据缓存和应答控制等功能    6、Nginx反向代理   准备工作：安装tomcat\n  安装jdk\n1  yum install -y java-1.8.0-openjdk     查看是否安装成功\n1  java -version     查看jdk安装位置，默认路径为/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.332.b09-1.el7_9.x86_64/jre/bin/java\n1  find / -name \u0026#39;java\u0026#39;     创建文件夹\n1  mkdir /usr/local/tomcat     下载tomcat\n1  wget https://dlcdn.apache.org/tomcat/tomcat-9/v9.0.64/bin/apache-tomcat-9.0.64.tar.gz --no-check-certificate     解压\n1  tar -zxvf apache-tomcat-9.0.64.tar.gz     添加防火墙端口\n1  firewall-cmd --add-port=8080/tcp --permanent \u0026amp;\u0026amp; firewall-cmd --reload     启动tomcat\n1 2 3  cd apache-tomcat-9.0.64/bin/ ./startup.sh     访问8080端口查看\n    反向代理过程\n  nginx配置\n   注意：\n proxy_pass只是替换server_name:listen，location不会改变，所以如果proxy_pass上没有location，就会404 location ~ /user/ 表示使用正则匹配，并且区分大小写，如果url中包含user就响应 \u0026gt;    ~* 表示正则匹配，并且不区分大小写   - **=** 表示严格匹配，如果匹配成功则立即处理该请求\r  7、Nginx负载均衡  nginx配置    nginx负载均衡分配策略\n 轮询（默认）：每个请求按照时间顺序注意分配到不同服务器上，如果某一服务器挂掉，自动剔除改服务器 weight：权重默认为1，权重越高，分配到改服务器上的请求越多 ip_hash：每个请求按访问ip的hash结果分配，每个请求固定访问某一台服务器，可以解决session共享问题  fair（第三方）：按照后端响应时间分配，最短响应时间优先    8、Nginx动静分离   动静分离指将动态请求与静态请求分开，实现角度分为两种：\n 将静态文件放在单独的静态服务器上访问（主流方案） 2. 静态文件和动态文件放在同一个服务器上，通过location指定不同的后缀名实现静态文件的区分。通过expires参数设置浏览器缓存过期时间可以减少客户端与服务端之间的请求，过期时间由浏览器验证，到达过期时间后向服务端发送请求对比静态文件最后更新时间，如果有变化则从服务器获取最新静态文件，这种方法适合不经常变动的静态资源    nginx配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  location / { root /app/static/; autoindex on; } location /html/ { root /app/static/; index index.html index.htm; autoindex on; } location /img/ { root /app/static/; autoindex on; }     9、Nginx高可用  当反向代理服务器挂掉后会导致用户无法访问服务端，所以需要增加一台Nginx反向代理服务器来保证高可用    当主服务器挂掉后keepalived会检测到服务器状态，将虚拟ip映射到备用服务器上，保证客户端的正常访问\n  准备工作：\n  安装keepalived\n1 2 3 4 5  # yum安装keepalived yum install keepalived -y # 查看版本 keepalived -v     keepalived配置文件位置：/etc/keepalived/keepalived.conf\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  ! Configuration File for keepalived global_defs { #notification_email { # 通知邮件，一般不用 # acassen@firewall.loc # failover@firewall.loc # sysadmin@firewall.loc #} #notification_email_from Alexandre.Cassen@firewall.loc smtp_server 192.168.200.1 smtp_connect_timeout 30 router_id LVS_DEVEL # 标识本节点字符串 vrrp_skip_check_adv_addr vrrp_strict chk_http_port { # 检查主服务器状态执行脚本配置 script \u0026#34;/usr/local/src/nginx_check.sh\u0026#34; # 脚本位置 interval 2 # 执行脚本时间间隔 weight 2 } vrrp_garp_interval 0 vrrp_gna_interval 0 } vrrp_instance VI_1 { state MASTER # 主服务器为MASTER，备服务器为BACKUP interface ens33 # 网卡 virtual_router_id 51 # 主备服务器需要相同 priority 100 # 优先级，主服务器大于备服务器 advert_int 1 # MASTER和BACKUP节点之间的同步检查时间间隔，单位为秒 authentication { # 验证类型和验证密码 auth_type PASS auth_pass 1111 } virtual_ipaddress { # 虚拟IP地址池，可以多个IP 192.168.200.16 192.168.200.17 192.168.200.18 } }     nginx_check.sh\n1 2 3 4 5 6 7 8 9  #!/bin/bash  if [ `ps -C nginx --no-header |wc -l` -eq 0];then /usr/local/nginx/sbin/nginx sleep 2 if [ `ps -C nginx --no-header |wc -l` -eq 0];then killall keepalived # systemctl stop keepalived fi fi     启动keepalived\n1  systemctl start keepalived.service         通过ip a可以查看到虚拟ip\n  10、Nginx原理  nginx分为master进程和worker进程，其中worker进程可能有多个，当客户端发送请求后，master收到客户端的请求，所有的worker进程会争抢客户端的请求，然后进行发送到服务端处理 多个worker进程的好处：  在reload时，没有争抢请求的worker进程可以进行reload，有利于热部署 每个worker是独立的进程，如果某一个worker进程挂掉，其他worker还可以正常工作，worker进程的数量通常和服务器cpu数相等       worker发送请求占用了几个连接数？ \u0026gt; \u0026gt; 2个（静态请求）或4个（动态请求）\n  如果Nginx有一个master，四个worker，每个worker最大连接数为1024，那么最大并发数是多少？ \u0026gt; \u0026gt; 如果是静态请求，并发数为4（worker的数量） * 1024（worker最大连接数） / 2 \u0026gt; \u0026gt; 如果是动态请求，并发数为4 * 1024 / 4\n   ","date":"2022-07-24T00:00:00Z","image":"https://WangZichen99.github.io/img/2022/07/colorful_river.jpg","permalink":"https://WangZichen99.github.io/p/nginxnote/","title":"Nginx笔记"},{"content":"SpringBoot 1、原理初探 pom.xml\n spring-boot-dependencies：核心依赖，在父工程中 在引入springboot依赖时不需要指定版本就是因为有这个版本库  启动器\n  1 2 3 4  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;    启动器就是springboot的启动场景，会自动导入-web环境的所有依赖 springboot将所有的功能场景，都变成了一个个启动器 以后需要什么功能就直接添加启动器就可以了  主程序 @SpringBootApplication：标注这个类是一个springboot的应用\n@SpringBootConfiguration：@SpringBootConfiguration是springboot的配置，其底层还是@Configuration\n@EnableAutoConfiguration：自动配置注解（重要）\n@AutoConfigurationPackage：自动配置包\n@Import({Registrar.class})：导入自动配置包的注册类\n@Import({AutoConfigurationImportSelector.class})：导入了AutoConfigurationImportSelector选择器\n1 2 3 4  //获取自动配置的实体的方法 getAutoConfigurationEntry(AutoConfigurationMetadata, AnnotationMetadata) //方法中获取候选配置项 List\u0026lt;String\u0026gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);   1 2  //获取所有EnableAutoConfiguration注解的配置项返回 List\u0026lt;String\u0026gt; configurations = SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class, beanClassLoader);   1 2  //从META-INF/spring.factories\u0026#34;中获取项目资源和系统资源（遍历文件后封装成Properties） loadSpringFactories(ClassLoader)   spring-boot-autoconfigure.jar/META-INF/spring.factories文件中包含了所有springboot的自动配置\nspring.factories中的AutoConfiguration类都是容器中的一个组件，最后都加入到容器中 当满足了@ConditionalOnClass注解中的条件之后（就导入了对应的starter），自动配置才会生效 自动配置生效后，各个配置类就会向容器中添加各种组件，这些组件的属性值就是从对应的properties文件中 获取的，并且这些属性与yaml配置文件是绑定的。\n@ConfigurationProperties绑定配置文件中的配置\n自动配置就是springboot自动将spring.factories中的组件注入到容器中供用户直接使用\n 判断应用的类型是不是Web项目 查找并加载所有可用的初始化器，设置到initializers属性中 找出所有的应用程序监听器，设置到listener中 设置main方法的定义类，加载运行的主类  可以通过在配置文件中配置debug=true来查看哪些配置类生效了，哪些没有生效\n2、YMAL配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #键值对name:wzc#对象student:name:wzcage:22stu:{name: wzc, age:22}#行内写法#数组subject:- chinese- math- englishsub:[chinese, math, english]#行内写法  2.1、给属性赋值的几种方式  使用ymal  1 2 3 4 5 6 7 8 9 10 11 12 13 14  person:name:wzcage:22happy:truebirthday:1999/10/12map:hobby:playlist:- a- b- cdog:name:niuniuage:3  1 2 3 4 5 6 7 8 9 10 11 12  @Component @Data @ConfigurationProperties(prefix = \u0026#34;person\u0026#34;) public class Person { private String name; private Integer age; private Boolean happy; private Date birthday; private Map\u0026lt;String, Object\u0026gt; map; private List\u0026lt;Object\u0026gt; list; private Dog dog; }   @ConfigurationProperties注解会从配置文件中寻找和prefix同名的对象注入到容器中\n使用properties person.properties  1 2  name=wzc age=22   1 2 3 4 5 6 7 8 9 10 11 12 13 14  @Component @Data @PropertySource(\u0026#34;classpath:person.properties\u0026#34;) public class Person { @Value(\u0026#34;${name}\u0026#34;) private String name; @Value(\u0026#34;${age}\u0026#34;) private Integer age; private Boolean happy; private Date birthday; private Map\u0026lt;String, Object\u0026gt; map; private List\u0026lt;Object\u0026gt; list; private Dog dog; }   使用@PropertySource选择properties文件，然后使用spel表达式对属性进行赋值\n松散绑定\n在yml中的-后的字母默认是大写的，last-name对应着实体类中的lastName\nJSR303数据校验\n1 2 3  @Null @NotNull ...   2.2、多环境配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  spring:profiles:active:dev---spring:profiles:devserver:port:8080---spring:profiles:testserver:port:8081---spring:profiles:proserver:port:8082  3、web开发 3.1、静态资源 看源码：WebMvcAutoConfiguration.class\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  public class WebMvcAutoConfiguration { public void addResourceHandlers(ResourceHandlerRegistry registry) { /** * 第三种方式：自己配置spring.mvc.static-path-pattern */ if (!this.resourceProperties.isAddMappings()) { logger.debug(\u0026#34;Default resource handling disabled\u0026#34;); } else { Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl(); /** * 第一种方法：使用webjars引入静态资源，webjars会以maven的形式导入静态资源， * springboot会到maven包中的/META-INF/resources/webjars/目录下寻找静态资源 */ if (!registry.hasMappingForPattern(\u0026#34;/webjars/**\u0026#34;)) { this.customizeResourceHandlerRegistration(registry .addResourceHandler(new String[]{\u0026#34;/webjars/**\u0026#34;}) .addResourceLocations(new String[]{\u0026#34;classpath:/META-INF/resources/webjars/\u0026#34;}) .setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl)); } /** * 第二种方法：springboot会先从mvcProperties中获取staticPathPattern，默认值为/** * 然后会设置resourceLocations，默认值为\u0026#34;classpath:/META-INF/resources/\u0026#34;, * \u0026#34;classpath:/resources/\u0026#34;, \u0026#34;classpath:/static/\u0026#34;, \u0026#34;classpath:/public/\u0026#34; */ String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) { this.customizeResourceHandlerRegistration(registry .addResourceHandler(new String[]{staticPathPattern}) .addResourceLocations(WebMvcAutoConfiguration .getResourceLocations(this.resourceProperties.getStaticLocations())) .setCachePeriod(this.getSeconds(cachePeriod)) .setCacheControl(cacheControl)); } } } }   3.2 首页如何定制 看源码：WebMvcAutoConfiguration.class 3.3、Thymeleaf模板引擎  导入  1 2 3 4 5 6 7 8 9 10 11  \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.thymeleaf\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;thymeleaf-spring5\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.thymeleaf.extras\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;thymeleaf-extras-java8time\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;   将静态文件放在templates目录下  编写视图解析器  1 2 3 4 5 6 7  @Controller public class IndexController { @GetMapping(\u0026#34;/index\u0026#34;) public String index() { return \u0026#34;index\u0026#34;; } }   1 2 3 4  \u0026lt;!-- 所有的html元素都可以被thymeleaf接管，th:元素名 --\u0026gt; \u0026lt;p th:text=\u0026#34;${msg}\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;!-- 带转义的text --\u0026gt; \u0026lt;p th:utext=\u0026#34;${msg}\u0026#34;\u0026gt;\u0026lt;/p\u0026gt;   3.4、SpringMVC配置  自定义视图解析器  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  @Configuration public class MvcConfig implements WebMvcConfigurer { /** * 如果想自定义mvc的功能，实现mvc的组件，然后交给springboot会自动装配 * @return */ @Bean public ViewResolver getViewResolver() { return new ViewResolver(); } /** * 自动以视图解析器，实现ViewResolver接口 */ public static class ViewResolver implements org.springframework.web.servlet.ViewResolver { @Override public View resolveViewName(String s, Locale locale) throws Exception { return null; } } }   日期转换  默认yyyy/MM/dd\n视图跳转  如果需要扩展SpringMvc，官方建议在类上添加@Configuration注解，并实现WebMVCConfigurer接口，然后重写其中的方法\n3.5、员工管理系统 3.5.1、首页实现 使用视图跳转让thymeleaf接管\n1 2 3 4 5 6 7 8 9 10 11 12 13  @Configuration public class MvcConfig implements WebMvcConfigurer { /** * 视图跳转 */ @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\u0026#34;/\u0026#34;).setViewName(\u0026#34;index\u0026#34;); registry.addViewController(\u0026#34;/index\u0026#34;).setViewName(\u0026#34;index\u0026#34;); registry.addViewController(\u0026#34;/home\u0026#34;).setViewName(\u0026#34;index\u0026#34;); } }   在页面中url地址使用@{}\n3.5.2、国际化  建立三个properties文件分别配置页面上需要国际化的不同语言  修改html页面中对应的  中英文切换按钮，需要自定义LocaleResolver组件并注入到spring容器中  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public class LocalResolver implements LocaleResolver { /** * 解析请求 * @param request * @return */ @Override public Locale resolveLocale(HttpServletRequest request) { String language = request.getParameter(\u0026#34;lang\u0026#34;); if (!StringUtils.isEmpty(language)) { String[] split = language.split(\u0026#34;_\u0026#34;); return new Locale(split[0], split[1]); } return Locale.getDefault(); } @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) { } }   3.5.3、登录和登录拦截器 登录和退出接口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  @Controller public class LoginController { @PostMapping(\u0026#34;/login\u0026#34;) public String login(@RequestParam(\u0026#34;username\u0026#34;) String username, @RequestParam(\u0026#34;password\u0026#34;) String password, Model model, HttpSession httpSession) { if (StringUtils.isEmpty(username) || StringUtils.isEmpty(password)) { model.addAttribute(\u0026#34;msg\u0026#34;, \u0026#34;用户名或密码错误！\u0026#34;); return \u0026#34;index\u0026#34;; } httpSession.setAttribute(\u0026#34;loginUser\u0026#34;, username); return \u0026#34;redirect:/dashboard\u0026#34;; } @GetMapping(\u0026#34;/signOut\u0026#34;) public String signOut(HttpSession httpSession) { httpSession.removeAttribute(\u0026#34;loginUser\u0026#34;); return \u0026#34;index\u0026#34;; } }   用户可以直接访问dashboard页面，所以需要配置拦截器\n1 2 3 4 5 6 7 8 9 10 11  public class LoginInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { if (ObjectUtils.isEmpty(request.getSession().getAttribute(\u0026#34;loginUser\u0026#34;))) { request.setAttribute(\u0026#34;msg\u0026#34;, \u0026#34;没有权限，请先登录！\u0026#34;); request.getRequestDispatcher(\u0026#34;/index\u0026#34;).forward(request, response); return false; } return true; } }   MvcConfig中配置拦截器\n3.5.4、查询信息和CRUD 实际开发中通常将通用的前端代码提取出来。使用th:fragment\n在页面中替换代码片段th:replace\n循环遍历数据th:each\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  \u0026lt;table class=\u0026#34;table table-striped table-sm\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;id\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;lastName\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;email\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;gender\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;department\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;birthday\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;operation\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr th:each=\u0026#34;employee:${employees}\u0026#34;\u0026gt; \u0026lt;td th:text=\u0026#34;${employee.getId()}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td th:text=\u0026#34;${employee.getLastName()}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td th:text=\u0026#34;${employee.getEmail()}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td th:text=\u0026#34;${employee.getGender() == 0 ? \u0026#39;女\u0026#39; : \u0026#39;男\u0026#39;}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td th:text=\u0026#34;${employee.getDepartment()}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td th:text=\u0026#34;${#dates.format(employee.getBirthday(), \u0026#39;yyyy-MM-dd\u0026#39;)}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;button class=\u0026#34;btn btn-sm btn-primary\u0026#34;\u0026gt;edit\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;btn btn-sm btn-danger\u0026#34;\u0026gt;delete\u0026lt;/button\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt;   增删改\n新增表单\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  \u0026lt;form th:action=\u0026#34;@{/insertEmp}\u0026#34; th:method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;LastName\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; class=\u0026#34;form-control\u0026#34; name=\u0026#34;lastName\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Email\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;email\u0026#34; class=\u0026#34;form-control\u0026#34; name=\u0026#34;email\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Gender\u0026lt;/label\u0026gt; \u0026lt;div class=\u0026#34;form-check form-check-inline\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; class=\u0026#34;form-check-input\u0026#34; name=\u0026#34;gender\u0026#34; value=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;form-check-label\u0026#34;\u0026gt;man\u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-check form-check-inline\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; class=\u0026#34;form-check-input\u0026#34; name=\u0026#34;gender\u0026#34; value=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;form-check-label\u0026#34;\u0026gt;women\u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Department\u0026lt;/label\u0026gt; \u0026lt;select name=\u0026#34;department.id\u0026#34; id=\u0026#34;dept\u0026#34; class=\u0026#34;form-control\u0026#34;\u0026gt; \u0026lt;option th:each=\u0026#34;dept:${departments}\u0026#34; th:value=\u0026#34;${dept.getId()}\u0026#34;\u0026gt;[[${dept.getDepartName()}]]\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Birthday\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;date\u0026#34; class=\u0026#34;form-control\u0026#34; name=\u0026#34;birthday\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;btn btn-primary\u0026#34;\u0026gt;insert\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt;   修改表单\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  \u0026lt;form th:action=\u0026#34;@{/editEmp}\u0026#34; th:method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34; hidden\u0026gt; \u0026lt;label\u0026gt;Id\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; class=\u0026#34;form-control\u0026#34; name=\u0026#34;id\u0026#34; th:value=\u0026#34;${emp.getId()}\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;LastName\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; class=\u0026#34;form-control\u0026#34; name=\u0026#34;lastName\u0026#34; th:value=\u0026#34;${emp.getLastName()}\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Email\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;email\u0026#34; class=\u0026#34;form-control\u0026#34; name=\u0026#34;email\u0026#34; th:value=\u0026#34;${emp.getEmail()}\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Gender\u0026lt;/label\u0026gt; \u0026lt;div class=\u0026#34;form-check form-check-inline\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; class=\u0026#34;form-check-input\u0026#34; name=\u0026#34;gender\u0026#34; value=\u0026#34;1\u0026#34; th:checked=\u0026#34;${emp.getGender() == 1}\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;form-check-label\u0026#34;\u0026gt;man\u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-check form-check-inline\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; class=\u0026#34;form-check-input\u0026#34; name=\u0026#34;gender\u0026#34; value=\u0026#34;2\u0026#34; th:checked=\u0026#34;${emp.getGender() == 2}\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;form-check-label\u0026#34;\u0026gt;women\u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Department\u0026lt;/label\u0026gt; \u0026lt;select name=\u0026#34;department.id\u0026#34; id=\u0026#34;dept\u0026#34; class=\u0026#34;form-control\u0026#34;\u0026gt; \u0026lt;option th:each=\u0026#34;dept:${departments}\u0026#34; th:value=\u0026#34;${dept.getId()}\u0026#34; th:selected=\u0026#34;${emp.getDepartment() != null ? emp.getDepartment().getId() == dept.getId() : false}\u0026#34;\u0026gt;[[${dept.getDepartName()}]]\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Birthday\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;date\u0026#34; class=\u0026#34;form-control\u0026#34; name=\u0026#34;birthday\u0026#34; th:value=\u0026#34;${#dates.format(emp.getBirthday(), \u0026#39;yyyy-MM-dd\u0026#39;)}\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;btn btn-primary\u0026#34;\u0026gt;save\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt;   接口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  @Controller public class EmployeeController { @Autowired private EmployeeService employeeService; @Autowired private DepartmentDao departmentDao; @GetMapping(\u0026#34;/employees\u0026#34;) public String getEmployees(Model model) { model.addAttribute(\u0026#34;employees\u0026#34;, employeeService.getEmployees()); return \u0026#34;list\u0026#34;; } @GetMapping(\u0026#34;/insertPage\u0026#34;) public String insertPage(Model model) { model.addAttribute(\u0026#34;departments\u0026#34;, departmentDao.getDepartments()); return \u0026#34;add\u0026#34;; } @PostMapping(\u0026#34;/insertEmp\u0026#34;) public String insertEmployee(Employee employee) { employeeService.insertEmployee(employee); return \u0026#34;redirect:/employees\u0026#34;; } @GetMapping(\u0026#34;/editPage/{id}\u0026#34;) public String editPage(@PathVariable Integer id, Model model) { model.addAttribute(\u0026#34;departments\u0026#34;, departmentDao.getDepartments()); model.addAttribute(\u0026#34;emp\u0026#34;, employeeService.getEmployeeById(id)); return \u0026#34;edit\u0026#34;; } @PostMapping(\u0026#34;/editEmp\u0026#34;) public String editEmployee(Employee employee) { employeeService.editEmployee(employee); return \u0026#34;redirect:/employees\u0026#34;; } @GetMapping(\u0026#34;/deleteEmp/{id}\u0026#34;) public String deleteEmployee(@PathVariable Integer id) { employeeService.deleteEmployee(id); return \u0026#34;redirect:/employees\u0026#34;; } }   404页面处理\n4.1、JDBC 导包\n1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;   配置\n1 2 3 4 5 6  spring:datasource:username:rootpassword:123456url:jdbc:mysql://localhost:3306/mybatis?useUnicode=true\u0026amp;characterEncoding=utf-8\u0026amp;serverTimezone=Asia/Shanghaidriver-class-name:com.mysql.cj.jdbc.Driver  测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  @SpringBootTest class SpringbootStudyApplicationTests { @Autowired private DataSource dataSource; @Test void contextLoads() throws SQLException { System.out.println(dataSource.getClass()); Connection connection = dataSource.getConnection(); System.out.println(connection); connection.close(); } }   spring默认数据源：class com.zaxxer.hikari.HikariDataSource\nJdbcTemplate是spring已经配置好的模板，拿来即用\nCRUD\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  @RestController public class JdbcController { @Autowired private JdbcTemplate jdbcTemplate; @GetMapping(\u0026#34;/userList\u0026#34;) public List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; getUserList() { String sql = \u0026#34;select * from mybatis.user\u0026#34;; List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; mapList = jdbcTemplate.queryForList(sql); return mapList; } @GetMapping(\u0026#34;/addUser\u0026#34;) public String addUser() { String sql = \u0026#34;insert into mybatis.user(id, name, pwd) values (4, \u0026#39;小明\u0026#39;, \u0026#39;123456\u0026#39;)\u0026#34;; jdbcTemplate.update(sql); return \u0026#34;insert success\u0026#34;; } @GetMapping(\u0026#34;/updateUser/{id}\u0026#34;) public String updateUser(@PathVariable(\u0026#34;id\u0026#34;) String id) { String sql = \u0026#34;update mybatis.user set name = ?, pwd = ? where id = \u0026#34; + id; jdbcTemplate.update(sql, new Object[]{\u0026#34;小红\u0026#34;, \u0026#34;123456\u0026#34;}); return \u0026#34;update success\u0026#34;; } @GetMapping(\u0026#34;/deleteUser/{id}\u0026#34;) public String deleteUser(@PathVariable(\u0026#34;id\u0026#34;) String id) { String sql = \u0026#34;delete from mybatis.user where id = \u0026#34; + id; jdbcTemplate.update(sql); return \u0026#34;delete success\u0026#34;; } }   4.2、Druid 导包\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.23\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.17\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;   配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  datasource:username:rootpassword:123456url:jdbc:mysql://localhost:3306/mybatis?useUnicode=true\u0026amp;characterEncoding=utf-8\u0026amp;serverTimezone=Asia/Shanghaidriver-class-name:com.mysql.cj.jdbc.Drivertype:com.alibaba.druid.pool.DruidDataSource# 数据源配置initialSize:5minIdle:5maxActive:20maxWait:60000timeBetweenEvictionRunsMillis:60000minEvictableIdleTimeMillis:300000validationQuery:select 1 from dualtestWhileIdle:truetestOnBorrow:falsetestOnReturn:falsepoolPreparedStatements:true# 配置监控统计拦截的filters, stat: 监控统计, log4j: 日志记录, wall: 防御sql注入filters:stat, log4j, wallmaxPoolPreparedStatementPreConnectionSize:20userGLobalDataSourceStat:trueconnectionProperties:druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500  配置类注入bean及配置Druid监控页面\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  @Configuration public class DruidConfig { //注入bean  @ConfigurationProperties(prefix = \u0026#34;spring.datasource\u0026#34;) @Bean public DataSource druidDataSource() { return new DruidDataSource(); } //后台监控配置，相当于原来的web.xml  //因为SpringBoot内置了Servlet容器，所以没有web.xml，使用ServletRegistrationBean注入即可替代  @Bean public ServletRegistrationBean statViewServlet() { ServletRegistrationBean\u0026lt;StatViewServlet\u0026gt; bean = new ServletRegistrationBean(new StatViewServlet(), \u0026#34;/druid/*\u0026#34;); //配置账号密码  HashMap\u0026lt;String, String\u0026gt; initParam = new HashMap\u0026lt;\u0026gt;(); initParam.put(\u0026#34;loginUsername\u0026#34;, \u0026#34;admin\u0026#34;); initParam.put(\u0026#34;loginPassword\u0026#34;, \u0026#34;admin\u0026#34;); //允许访问用户  initParam.put(\u0026#34;allow\u0026#34;, \u0026#34;\u0026#34;); bean.setInitParameters(initParam); return bean; } }   4.2、整合Mybatis 导包\n1 2 3 4 5  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.spring.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   配置\n1 2 3  mybatis:type-aliases-package:com.wzc.springbootstudy.pojo#别名设置mapper-locations:classpath:mybatis/mapper/*.xml#mapper位置  xml、mapper、service、controller省略\n5、SpringSecurity AOP思想\nSpring Security是Spring Boot底层安全模块默认的技术选型，使用Spring Security只需要导入spring-boot-starter-security 并进行少量配置即可\n几个比较重要的类：\n WebSecurityConfigurerAdapter：自定义Security策略 AuthenticationManagerBuilder：自定义认证策略 @EnableWebSecurity：开启WebSecurity模式  SpringSecurity的两个主要目标是“认证（Authentication）”和“授权（Authorization）”\n导包\n1 2 3 4  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-security\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;   1 2 3 4 5  \u0026lt;!--thymeleaf整合spring security--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.thymeleaf.extras\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;thymeleaf-extras-springsecurity5\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;   自定义配置类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { /** * 授权 * @param http * @throws Exception */ @Override protected void configure(HttpSecurity http) throws Exception { //首页所有人都可以访问，特定的页面只有特定的角色才能访问  http.formLogin().loginPage(\u0026#34;/securityLogin\u0026#34;).loginProcessingUrl(\u0026#34;/login\u0026#34;).defaultSuccessUrl(\u0026#34;/security\u0026#34;).and()//没有权限访问自动进入登录页  .rememberMe().rememberMeParameter(\u0026#34;rememberMe\u0026#34;).and()//记住我功能，默认参数名为remember-me  .logout().logoutSuccessUrl(\u0026#34;/security\u0026#34;).and()//注销页面  .authorizeRequests() .antMatchers(\u0026#34;/security\u0026#34;).permitAll() .antMatchers(\u0026#34;/securityLevel1/**\u0026#34;).hasRole(\u0026#34;vip1\u0026#34;) .antMatchers(\u0026#34;/securityLevel2/**\u0026#34;).hasRole(\u0026#34;vip2\u0026#34;) .antMatchers(\u0026#34;/securityLevel3/**\u0026#34;).hasRole(\u0026#34;vip3\u0026#34;).and() .csrf().disable(); } /** * 认证 * @param auth * @throws Exception */ @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { //inMemoryAuthentication从内存中取数据，passwordEncoder密码编码规则，withUser添加用户  BCryptPasswordEncoder bCryptPasswordEncoder = new BCryptPasswordEncoder(); auth.inMemoryAuthentication().passwordEncoder(bCryptPasswordEncoder) .withUser(\u0026#34;wzc\u0026#34;).password(bCryptPasswordEncoder.encode(\u0026#34;123456\u0026#34;)).roles(\u0026#34;vip1\u0026#34;, \u0026#34;vip2\u0026#34;).and() .withUser(\u0026#34;admin\u0026#34;).password(bCryptPasswordEncoder.encode(\u0026#34;admin\u0026#34;)).roles(\u0026#34;vip1\u0026#34;, \u0026#34;vip2\u0026#34;, \u0026#34;vip3\u0026#34;).and() .withUser(\u0026#34;guest\u0026#34;).password(bCryptPasswordEncoder.encode(\u0026#34;123456\u0026#34;)).roles(\u0026#34;vip3\u0026#34;); } }   index.html\n1  xmlns:sec=\u0026#34;http://www.thymeleaf.org/extras/spring-security\u0026#34;   6、Shiro 6.1、快速开始 shiro架构中的几个对象：\n Subject：代表当前用户，与Subject的所有交互都会委托给SecurityManager SecurityManager：负责管理所有的Subject，是shiro的心脏，所有具体的交互都通过SecurityManager进行控制， 且负责进行认证、授权、会话、及缓存的管理 Authenticator：负责Subject认证逻辑 Authorizer：授权器，控制用户是否有权进行相应操作 Realm：安全试题数据源 SessionManager：管理Session生命周期 CacheManager：缓存控制器，管理用户、角色、权限等缓存 Cryptography：密码模块   导入依赖  1 2 3 4 5  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shiro\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shiro-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.6.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   添加配置文件ini  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  [users] # user \u0026#39;root\u0026#39; with password \u0026#39;secret\u0026#39; and the \u0026#39;admin\u0026#39; role root = secret, admin # user \u0026#39;guest\u0026#39; with the password \u0026#39;guest\u0026#39; and the \u0026#39;guest\u0026#39; role guest = guest, guest # user \u0026#39;presidentskroob\u0026#39; with password \u0026#39;12345\u0026#39; (\u0026#34;That\u0026#39;s the same combination on # my luggage!!!\u0026#34; ;)), and role \u0026#39;president\u0026#39; presidentskroob = 12345, president # user \u0026#39;darkhelmet\u0026#39; with password \u0026#39;ludicrousspeed\u0026#39; and roles \u0026#39;darklord\u0026#39; and \u0026#39;schwartz\u0026#39; darkhelmet = ludicrousspeed, darklord, schwartz # user \u0026#39;lonestarr\u0026#39; with password \u0026#39;vespa\u0026#39; and roles \u0026#39;goodguy\u0026#39; and \u0026#39;schwartz\u0026#39; lonestarr = vespa, goodguy, schwartz [roles] # \u0026#39;admin\u0026#39; role has all permissions, indicated by the wildcard \u0026#39;*\u0026#39; admin = * # The \u0026#39;schwartz\u0026#39; role can do anything (*) with any lightsaber: schwartz = lightsaber:* # The \u0026#39;goodguy\u0026#39; role is allowed to \u0026#39;drive\u0026#39; (action) the winnebago (type) with # license plate \u0026#39;eagle5\u0026#39; (instance specific id) goodguy = winnebago:drive:eagle5   quickstart.java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71  public class ShiroQuickStart { private static final transient Logger log = LoggerFactory.getLogger(ShiroQuickStart.class); public static void main(String[] args) { //通过ini配置文件获得SecurityManager实例  Factory\u0026lt;SecurityManager\u0026gt; factory = new IniSecurityManagerFactory(\u0026#34;classpath:shiro.ini\u0026#34;); SecurityManager securityManager = factory.getInstance(); SecurityUtils.setSecurityManager(securityManager); //获得当前用户对象  Subject currentUser = SecurityUtils.getSubject(); //Session使用  Session session = currentUser.getSession(); session.setAttribute(\u0026#34;someKey\u0026#34;, \u0026#34;aValue\u0026#34;); String value = (String) session.getAttribute(\u0026#34;someKey\u0026#34;); if (value.equals(\u0026#34;aValue\u0026#34;)) { log.info(\u0026#34;Retrieved the correct value! [\u0026#34; + value + \u0026#34;]\u0026#34;); } //用户登录  if (!currentUser.isAuthenticated()) { UsernamePasswordToken token = new UsernamePasswordToken(\u0026#34;lonestarr\u0026#34;, \u0026#34;vespa\u0026#34;); token.setRememberMe(true); try { currentUser.login(token); } catch (UnknownAccountException uae) { log.info(\u0026#34;There is no user with username of \u0026#34; + token.getPrincipal()); } catch (IncorrectCredentialsException ice) { log.info(\u0026#34;Password for account \u0026#34; + token.getPrincipal() + \u0026#34; was incorrect!\u0026#34;); } catch (LockedAccountException lae) { log.info(\u0026#34;The account for username \u0026#34; + token.getPrincipal() + \u0026#34; is locked. \u0026#34; + \u0026#34;Please contact your administrator to unlock it.\u0026#34;); } catch (AuthenticationException ae) { //unexpected condition? error?  } } //打印身份信息  log.info(\u0026#34;User [\u0026#34; + currentUser.getPrincipal() + \u0026#34;] logged in successfully.\u0026#34;); //校验角色  if (currentUser.hasRole(\u0026#34;schwartz\u0026#34;)) { log.info(\u0026#34;May the Schwartz be with you!\u0026#34;); } else { log.info(\u0026#34;Hello, mere mortal.\u0026#34;); } //校验权限  if (currentUser.isPermitted(\u0026#34;lightsaber:wield\u0026#34;)) { log.info(\u0026#34;You may use a lightsaber ring. Use it wisely.\u0026#34;); } else { log.info(\u0026#34;Sorry, lightsaber rings are for schwartz masters only.\u0026#34;); } if (currentUser.isPermitted(\u0026#34;winnebago:drive:eagle5\u0026#34;)) { log.info(\u0026#34;You are permitted to \u0026#39;drive\u0026#39; the winnebago with license plate (id) \u0026#39;eagle5\u0026#39;. \u0026#34; + \u0026#34;Here are the keys - have fun!\u0026#34;); } else { log.info(\u0026#34;Sorry, you aren\u0026#39;t allowed to drive the \u0026#39;eagle5\u0026#39; winnebago!\u0026#34;); } //注销  currentUser.logout(); System.exit(0); } }   6.1、Shiro登录拦截 编写配置类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  @Configuration public class ShiroConfig { /** * 创建自定义Realm对象 * @return */ @Bean public ShiroRealm shiroRealm() { return new ShiroRealm(); } /** * 创建SecurityManager对象 * @param shiroRealm * @return */ @Bean public DefaultWebSecurityManager defaultWebSecurityManager(ShiroRealm shiroRealm) { DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(shiroRealm); return securityManager; } /** * 创建ShiroFilterFactoryBean对象 * @param defaultWebSecurityManager * @return */ @Bean public ShiroFilterFactoryBean shiroFilterFactoryBean(DefaultWebSecurityManager defaultWebSecurityManager) { ShiroFilterFactoryBean factoryBean = new ShiroFilterFactoryBean(); factoryBean.setSecurityManager(defaultWebSecurityManager); /** * 添加shiro内置过滤器 * anon: 无需认证就可以访问 * authc: 必须认证了才能访问 * user: 必须拥有记住我才能访问 * perms: 拥有对某个资源的权限才能访问 * roles:拥有某个角色权限才能访问 */ Map\u0026lt;String, String\u0026gt; filterMap = new LinkedHashMap(); filterMap.put(\u0026#34;/shiro/add\u0026#34;, \u0026#34;authc\u0026#34;); factoryBean.setFilterChainDefinitionMap(filterMap);//设置内置过滤器  factoryBean.setLoginUrl(\u0026#34;/shiro/login\u0026#34;);//设置登录url  return factoryBean; } }   自定义Realm对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  public class ShiroRealm extends AuthorizingRealm { @Autowired UserService userService; /** * 授权 * @param principalCollection * @return */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) { System.out.println(\u0026#34;授权\u0026#34;); User user = (User) principalCollection.getPrimaryPrincipal(); //根据数据库中的权限进行授权  if (!StringUtils.isEmpty(user.getPerms())) { SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); info.addStringPermission(user.getPerms()); return info; } return null; } /** * 认证 * @param authenticationToken * @return */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException { System.out.println(\u0026#34;认证\u0026#34;); UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken; User user = userService.queryByUserName(token.getUsername()); if (ObjectUtils.isEmpty(user)) { throw new UnknownAccountException();//用户名不存在！  } //密码校验由shiro完成  return new SimpleAuthenticationInfo(user, user.getPwd(), user.getName());//第一个参数为授权方法中principalCollection.getPrimaryPrincipal()的值  } }   导入thymeleaf-extras-shiro\n1 2 3 4 5  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.theborakompanioni\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;thymeleaf-extras-shiro\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   配置Bean整合thymeleaf\n1 2 3 4 5 6 7 8 9 10 11  @Configuration public class ShiroConfig { /** * 创建ShiroDialect整合thymeleaf * @return */ @Bean public ShiroDialect shiroDialect() { return new ShiroDialect(); } }   1  \u0026lt;html xmlns:shiro=\u0026#34;http://www.pollix.at/thymeleaf/shiro\u0026#34;\u0026gt;   1 2 3 4 5 6 7 8 9  \u0026lt;div shiro:guest=\u0026#34;\u0026#34;\u0026gt; \u0026lt;a th:href=\u0026#34;@{/shiro/login}\u0026#34;\u0026gt;login\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div shiro:hasPermission=\u0026#34;\u0026#39;user:add\u0026#39;\u0026#34;\u0026gt; \u0026lt;a th:href=\u0026#34;@{/shiro/add}\u0026#34;\u0026gt;add\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div shiro:user=\u0026#34;\u0026#34;\u0026gt; \u0026lt;a th:href=\u0026#34;@{/shiro/logout}\u0026#34;\u0026gt;logout\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt;   7、Swagger  导入依赖  1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-swagger2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.9.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-swagger-ui\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.9.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;   编写配置类  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  @Configuration @EnableSwagger2 public class SwaggerConfig { @Value(\u0026#34;${swagger.enable}\u0026#34;) private Boolean enable; @Bean public Docket docket() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() // .apis(RequestHandlerSelectors.none()) //不扫描所有接口  // .apis(RequestHandlerSelectors.any()) //扫描所有接口  .apis(RequestHandlerSelectors.basePackage(\u0026#34;com.wzc.springbootstudy.controller\u0026#34;)) //扫描包下的api接口  // .apis(RequestHandlerSelectors.withClassAnnotation(RestController.class)) //扫描类上有RestController注解的接口  // .apis(RequestHandlerSelectors.withMethodAnnotation(GetMapping.class)) //扫描方法上有GetMapping注解的接口  // .paths(PathSelectors.ant(\u0026#34;/shiro/**\u0026#34;)) //扫描路径下的api接口  .build() .enable(enable); } private ApiInfo apiInfo() { return new ApiInfo( \u0026#34;Swagger document\u0026#34;, \u0026#34;description\u0026#34;, \u0026#34;v1.0\u0026#34;, \u0026#34;https://www.wzc.com\u0026#34;, new Contact(\u0026#34;wzc\u0026#34;, \u0026#34;https://www.wzc.com\u0026#34;, \u0026#34;714479133@qq.com\u0026#34;), \u0026#34;Apache 2.0\u0026#34;, \u0026#34;https://www.apache.org/licenses/LICENSE-2.0\u0026#34;, new ArrayList\u0026lt;\u0026gt;() ); } }   实体类中的注解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  @Data @ApiModel(\u0026#34;用户\u0026#34;) public class User implements Serializable { @ApiModelProperty(\u0026#34;id\u0026#34;) private Integer id; @ApiModelProperty(\u0026#34;用户名\u0026#34;) private String name; @ApiModelProperty(\u0026#34;密码\u0026#34;) private String pwd; @ApiModelProperty(\u0026#34;年龄\u0026#34;) private Integer age; @ApiModelProperty(\u0026#34;邮箱\u0026#34;) private String email; @ApiModelProperty(\u0026#34;权限\u0026#34;) private String perms; }   效果\n接口类中的注解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  @Api(tags = \u0026#34;用户控制器\u0026#34;) @RestController public class UserController { @Autowired private UserMapper userMapper; @ApiOperation(value = \u0026#34;获取用户列表\u0026#34;, notes = \u0026#34;需要注意的地方\u0026#34;) @GetMapping(\u0026#34;/queryUserList\u0026#34;) public List\u0026lt;User\u0026gt; queryUserList() { return userMapper.queryUserList(); } }   效果\n8、异步任务 启动类上添加enable注解，开启异步 异步方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  @Service public class AsyncService { @Async public void testAsync() { try { for (int i = 0; i \u0026lt; 10; i++) { System.out.println(i + 1); Thread.sleep(1000); } } catch (InterruptedException e) { e.printStackTrace(); } } }   9、邮件任务  导包  1 2 3 4  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-mail\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;   相关类：\n MailSenderAutoConfiguration MailProperties MailSenderJndiConfiguration  配置  1 2 3 4 5 6 7 8 9 10  mail:username:714479133@qq.compassword:keqpddottxodbcfghost:smtp.qq.com# qq邮箱需要开启加密验证properties:mail:smtp:ssl:enable:true  测试  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class Test { /** * 发送邮件 */ private void simpleMailSend() { SimpleMailMessage simpleMailMessage = new SimpleMailMessage(); simpleMailMessage.setSubject(\u0026#34;测试springboot邮件发送\u0026#34;); simpleMailMessage.setText(\u0026#34;测试\u0026#34;); simpleMailMessage.setFrom(\u0026#34;714479133@qq.com\u0026#34;); simpleMailMessage.setTo(\u0026#34;714479133@qq.com\u0026#34;); javaMailSender.send(simpleMailMessage); } /** * 发送复杂邮件 */ private void mimeMailSend() throws MessagingException { MimeMessage mimeMessage = javaMailSender.createMimeMessage(); MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMessage, true); mimeMessageHelper.setSubject(\u0026#34;测试复杂邮件发送\u0026#34;); mimeMessageHelper.setText(\u0026#34;\u0026lt;p\u0026gt;html格式正文\u0026lt;/p\u0026gt;\u0026#34;, true); mimeMessageHelper.addAttachment(\u0026#34;file1.jpg\u0026#34;, new File(\u0026#34;E:\\\\Code\\\\javaWorkSpace\\\\springboot-study\\\\note\\\\img.png\u0026#34;)); mimeMessageHelper.setFrom(\u0026#34;714479133@qq.com\u0026#34;); mimeMessageHelper.setTo(\u0026#34;714479133@qq.com\u0026#34;); javaMailSender.send(mimeMessage); } }   10、定时任务 启动类上添加@EnableScheduling注解开启定时任务\n1 2 3 4 5 6 7 8 9 10 11  @Service public class ScheduledService { /** * cron表达式：秒 分 时 日 月 周 */ @Scheduled(cron = \u0026#34;0 0 12 * * ?\u0026#34;) public void ScheduleTask() { System.out.println(\u0026#34;每天12点执行一次！\u0026#34;); } }   ","date":"2022-07-09T11:18:24+08:00","image":"https://WangZichen99.github.io/img/2022/07/nature_park.jpg","permalink":"https://WangZichen99.github.io/p/springbootnote/","title":"SpringBoot笔记"},{"content":"《认知觉醒》读书笔记 第一章 大脑——一切问题的起源 第一节 大脑：重新认识你自己 三层大脑\n  演进过程   爬行动物 本能脑   哺乳动物 情绪脑   人类 理智脑    三层大脑对比  本能脑 低级 强大 婴儿时期趋于完善（2岁） 神经元细胞数量多，距离心脏近 运行速度快 控制大脑能力强 更接近原始社会-生存-及时享乐、避难趋易、急于求成   情绪脑 低级 次强 青春期早期（12岁）   理智脑 高级 弱小 成年早期（22岁） 数量少，距离远 速度慢且耗能 控制大脑能力弱 更接近现代社会   结果\n 明知读书重要，却转身掏出手机 明知跑步有益，却两天没了下文 明知要事优先，却围绕琐事打转  大多数时候我们以为自己在思考，实则都是对自身行为和欲望的合理化\n成长是克服天性的过程\n提升理智脑 ≠ 削弱本能脑和情绪脑\n理智脑指挥，本能脑行动\n第二节 焦虑的根源 焦虑的形式：\n 完成焦虑：内在欲望太广或时间安排太紧从而无法做到从容 定位焦虑：将起步的自己与他人取得的成就相比 选择焦虑：选择太多，不知道如何抉择 环境焦虑：环境迫使 难度焦虑：不下决心认真对待难度大的事情，而在周围打转  焦虑的原因：\n 总结起来就是：相同时做很多事，又想立即看到效果（欲望与能力差距较大） 人的一切痛苦本质上都是对自己的无能的愤怒 ———— 王小波  graph TD A(想同时做很多事) -- B(急于求成) -- E(天性) C(想不怎么努力就看到效果) -- D(避难趋易) -- E(天性)  第三节 耐心者得天下 宏观上：\n  复利效应：   舒适区边缘   微观上：\n 学习过程与权重  过程：学习————思考————行动————改变 权重：改变 \u0026gt; 行动 \u0026gt; 思考 \u0026gt; 学习 人们在学习过程中总是看到自己学习了多少，而不是看到自己改变了多少 书中的一两个观点改变了我 \u0026gt; 我今天读书5个小时   平台期   拥有耐性：\n 接纳天性（缺乏耐心） 延迟满足（该有的享受一点也不会少，只不过不是现在，而是在完成该做的之后） 提升认知，看到事情的深层意义 享受高级乐趣（学习的乐趣，健身的乐趣）取代低级乐趣（玩手机）  第二章 潜意识——生命留给我们的彩蛋 第一节 人生是一场消除模糊的比赛 意识分层：潜意识负责生理系统，意识负责社会系统\n意识分层导致的问题：模糊\n产生模糊的原因：\n 处理信息速度不对等 意识难以左右潜意识，但潜意识可以左右意识  人们不愿消除模糊，因为消除模糊意味着走出舒适区，人们不愿做这种高耗能的事情，而总是在重复那些已经掌握的事情，从而导致自己无法进步。\n所有的困难只因为我们对其的认知模糊，这种模糊阻碍了我们，导致拖延、不愿面对问题， 如果我们能够在一开始就主动消除模糊，就不会徒增烦恼\n所有的痛苦都不会凭空消失， 唯一的办法就是在它们变得模糊，在它们进入潜意识前正视它、拆解它。\n选择模糊会导致行动力不足， 解决办法是：细化过程，建立一条单行道，消除选择\n第二节 顶级的成长竟然是“凭感觉” 潜意识代表感性，意识代表理性。意识虽然理智但处理速度较慢，潜意识虽然更接近原始思想，但速度极快。\n两者之前的速度差距造成了模糊的认知。潜意识已经察觉到的信息，意识却无法捕捉。\n所以先用感性选择，再用理性思考。在读书时读到触动的地方马上停下，询问自己为什么触动，用理性进行思考。\n这种感性选择理性思考的方法就是小事听从你的脑，大事听从你的心。\n第三章 元认知——人类的终极能力 第一节 成长慢，是因为你不会“飞” 元认知能力可以被定义为自我审视，主动控制，防止被潜意识左右的能力。\n成长中我们在学校学习的主要是学习、理解、记忆能力，而观察、反思、判断、选择这种元认知能力却非常少用，这就是为什么有的人在走出学校之后自控能力并不是很强的原因，元认知需要我们主动锻炼，就像锻炼肌肉一样，越用越强。\n那么如何主动开启元认知能力呢？\n秘诀就是停下几秒，给理智脑一点思考的时间去自我审视，主动控制。\n第二节 自控力：我们生而为人就是为了成为思维舵手 元时间的概念：元时间是在两件事情，两个阶段或者两种状态之间。\n例如下班回到家就是从通勤到家，这时选择拿起手机还是拿起书籍就是一种选择，元时间的选择会影响下个阶段，如果拿起了手机，那下个阶段就是什么都没做，如果选择了书籍，就正确的控制了自己。\n每个元时间都是锻炼元认知能力的好机会，抓住这些机会，审视自己，主动控制。\n模糊会影响元认知能力，在大脑对未来的时间充满模糊的时候就是行动力最弱的时候，解决办法就是消除模糊，思考需要做的事情，给它们排序，让大脑中的模糊变得清晰明确。\n所以总结起来就是对当下的时间，全天的安排，人生的目标都有清晰明确的认识，这才是成为思维舵手的关键。\n第四章 专注力——情绪和智慧的交叉地带 第一节 情绪专注：一招提振你的注意力 有时我们在做一件事，脑子里却想着另外一件事，这其实不是一心二用而是不专注的表现。\n我们可以将一件事分为行动上和感受上两部分。起初在做一件事情时两者是统一的，当这件事越来越熟悉，越来越熟练之后，所花费的注意力也就越少，这时就表现出了身体与内心分离的现象。\n分心的原因有两种：一种是觉得当下的事情太无聊，一种是觉得当下的事情太痛苦。\n不管哪种都是让思想逃避现实，去想象天马行空。思想可以回到过去也可以幻想未来，但就是不会回归当下。\n然而人生就是由无数个当下所组成的，如果没有专注力，如何把握好人生呢。\n克服分心的方法是收回感受，让它回到事情本身上来，比如：\n 跑步时悉心体会抬腿摆臂，呼吸吐纳和迎面的微风。 睡觉时感受身体的紧张与松弛。 吃饭时感受每一口饭菜的香甜，体会味觉从有到无的过程。  身心合一的过程不是专注当下而是享受当下。\n第二节 学习专注：深度沉浸是进化双刃剑的安全剑柄 弱者极易分心，被身旁的事物所打扰，无法学习。而强者却会主动的练习专注能力，去热闹的地方看书学习，这使他们拥有了随时随地进入深度阅读和思考状态的能力。\n深度沉浸的方法有以下几点：\n1. 定义明确的目标：\n比如练琴时，告诉自己连续三次不犯任何错误、以适当的速度弹奏完曲子。而不是“我要练琴半小时”这样宽泛的目标。 将大目标分解为小目标使其明确化。\n2. 极度专注：\n大脑在学习时有两种模式：意识层的专注模式和潜意识的发散模式。\n从名称上来解释专注模式是在一个固定的区域的思考，而发散模式就是不固定的区域的联想思考。\n当我们认真思考问题却找不到答案时，就需要发散模式帮助我们寻找答案，但是发散模式属于潜意识层面，想要使用发散模式就必须彻底关闭意识层面的专注模式。\n所以做法就是当我们无法想到答案时，先放弃思考而去做其他毫不相干的事情，彻底关闭意识，让潜意识的发散模式去寻找答案。\n3. 有效的反馈：\n任何事情都需要形成闭环来提高，如果只是一味的努力，而没有反馈就无法认识自己的不足，一直练习自己已经学会的地方，使自己一直处在舒适区。\n形成反馈可以通过反思，复盘来获得。\n4. 始终处在拉伸区：\n一味的重复已经掌握的事情毫无意义，并会使自己感到厌倦，而进入困难区会感到挫败，焦虑。唯一的办法就是在舒适区和困难区中间\n练琴的例子：\n今天只练第一节，后面的先不练（把大目标拆分成小目标）；\n然后只练刚才弹错的地方（在拉伸区练习）；\n只要能连续流畅地弹3遍不出错就算完成（目标具体清晰）；\n练习过程中，我会及时纠正她的指法和按键错误（及时有效的反馈）；\n这样，很快进入了专注状态（沉浸其中），不一会儿就把第一节弹得很好了。\n第五章 学习力——学习不是一味地努力 第一节 匹配：舒适区边缘，适用于万物的方法论 匹配自己的计划才是能让你坚持最久的计划。\n一开始就给自己定制一个宏伟的目标，往往会使自己难以坚持下去，极其痛苦。\n最好的方式是在舒适区外的拉伸区进行练习，当你适应了当前的拉伸区就可以试着再向外走一点，离舒适区再远一些。\n当我们下定决心开始学习时，便会盲目跟随优秀者的脚步，他看什么书我就看什么书，他做什么题目我也做什么题目。\n这种做法其实是非常不可取的，用匹配原则就可以知道其中的原因，别人的拉伸区可能是是你的困难区，这样你不仅无法进步，还会容易放弃，自我焦虑。\n主动匹配自己的拉伸区，适合自己的才是最好的。\n前文中提到的定义明确目标也符合匹配拉伸区的原则，当我们将困难区的大目标拆解成拉伸区的小目标，就更驱使我们做出行动，进入拉伸区。\n在拉伸区需要明确关注点，关注的不是那些无聊的、已经学会的，而是那些还没有掌握的、出错的地方，然后不断重复直到将拉伸区变为舒适区。\n距离我们太远的事物，我们通常无法把握，无论它们是令人痛苦的还是令人享受的。\n当我们突然有了大量的时间、金钱、等等，我们通常没有能力控制自己有效的利用这些。\n大量的时间和金钱意味着突然多出了很多选择，而做选择是及其困难耗能的事情，没有能力合理的处理就意味着将会顺从自己的天性去享乐。\n所以人生最理想的状态就是持续的获得与自己能力匹配的财富和自由，不用羡慕旁人，因为即便将他人的成就给你，自己也无法把握，因为不匹配。\n第二节 深度：深度学习，人生为数不多的好出路 现在随处可见“精品课”、“几日速成”、“干货分享”等字眼，这些所谓的速成干货都是浅度学习的方法。\n在进行浅层学习时，我们输入的是别人已经咀嚼过的知识，是一种快餐式的知识，并且只注重输入，好像看过了这些知识就已经全部掌握了，这是一种浅层的、低级的学习方法。\n而深度学习注重的是学习的输入和输出，输出指的是将学到的知识与现有的知识体系连接起来，将学到的知识用自己的知识去解释，使新的知识成为自己知识体系中的一部分，然后将这些知识传授或向他人讲解。\n如果发现自己不知道从何讲起或说不清楚，那么十有八九是自己还没有掌握这些知识。输入与输出将学习知识的过程形成闭环，学以致用，进行输出，而输出必然会带来新的输入形成反馈，如此循环往复，知识会越来越精确和深刻。\n进行深度学习的几个方法： 1. 学习第一手知识：\n别人讲的课程时经别人咀嚼过的、二手的、快餐式的知识，而那些原著或论文才是值的精读和细细品味的经典。\n2. 进行记录：\n有了知识的输入之后，输出才是检验知识是否吸收的标准，用自己的语言和理解解释学到的知识也是一种输出，这个过程就是在用自己原有的知识来解释新学到的知识，是缝补的过程。\n3. 反思生活：\n反思、自省其实也是输出的一种形式，反思的目的是为了获得反馈，帮助自己发现不足和生活中的底层关系，深度学习可以用于生活的方方面面。\n最后，深度学习并不意味着放弃浅度学习，而是以深度学习为主。不同的浅度学习的输入带给我更多元的信息，接触到更广的领域，但无论如何浅度学习只能带给你不一样的视角，深度学习的输出还是需要我们自己去体会，去践行。\n专注与深度学习，同时对其按学习保持开放，毕竟深度之下的广度才是有效的。\n第三节 关联：高手的“暗箱” 在学习任何知识时，找到触动自己的地方，然后停下来思考、关联，这些知识可以用在哪些地方，解释哪些事情。\n获取到的知识就像是一盘沙子，是没有规矩的、散落的，思考和关联就是将新学到的知识与大脑中的知识系统形成联系，成为自己的知识。\n大多数人总是孤立的看待事物，不思考事情之间的联系，其实只有当我们有了某些迫切需求，或是正在完成工作，或是想要发现某种原理，在这种情况下进行关联往往会使我们的收获更加丰硕。\n同时只关联自己所需要的，避免将精力浪费在不必关注或是与自己毫不相关的小事身上，也会使关联的效能大大提高。\n第四节 体系：建立个人认知体系其实很简单 之前总认为知识就是书本上的道理、哲理、方法，其实不然。在进入社会之后，知识变成了能够帮助我们在选择面前做出决策的东西， 也就是说知识不再是具体的内容，而是反映在日常的方方面面，变成了相对抽象的东西，而这个东西更像是认知。\n在知识变得抽象之后，再结合前面所学的匹配，不难发现，没有最权威、最确定的知识体系，只有最适合个人当前状态的认知体系。\n在学习任何知识时，其实只需要关注那些触动我们，让自己有感触的内容，无需追求所谓的完美。\n记录作者的文章结构、做思维导图、找各种各样的读书心得使得自己能将书中所讲的完完整整、及其精确的记录下来。其实这么做完全没有必要，对自己最有触动的才是自己最需要的，也是能让自己记忆最深刻的。这些知识处于拉伸区，而其他的观点或知识往往处于困难区，将书中所有的观点知识全部收集下来往往使得自己无法抓住重点，不知道哪个才是对自己最重要的。\n大部分人收集记录只是为了满足自己的心理，认为只要记录了就掌握了全部，自己就会越来越好，从不注重改变，前文说过学习的权重是以改变为首，即便书中的一两个观点使你触动并在生活中实际发生了改变，也要好过盲目的全盘照搬。\n构建个人认知体系就是只吸取他人认知体系中自己最触动的部分，将这些零散的、碎片的内容融合拼接到自己的认知体系中， 形成属于自己的、独一无二的认知体系。\n刚刚学到的新知识或者新的触动对自己的认知体系还没有连接紧密，如果不及时有效的加强这些触动与认知圈的联系，它们随时会消失不见，这些就是伪触动。\n强化伪触动在于加强它们与自己认知圈的联系，也就是用自己的语言解释这些触动，进而产生关联，或是时常使用、联想这些触动，践行新学的知识，也能够极大的帮助强化关联。\n第五节 打卡：莫迷恋打卡，打卡打不出未来 学习需要有明确的目标，这种目标应该是实际的、实用的。\n比如：学习英语的目标是为了与外国人交流，而不是每天背多少个单词。\n不能为了完成所谓的目标而学，要专注于学习的长远目标，而不是专注于学习的形式或是每天完成指定的计划而学。\n认知闭合需求是指当遇到一个模糊不清的问题时，总想着要找到问题的答案。\n也就是说当任务没有完成时，我们坐立不安，时刻惦记着还有事情没有完成，而当我们做完需要做的事情，做这件事的动机就会立即变成零。这就是打卡的过程，当没有打卡时，总想着还没有完成打卡，如果时间来不及，会敷衍了事，先打卡解决这件事情再说，而如果时间足够，在完成打卡目标之后也绝不会在多做一点，所谓学不到，假装一下；学到了，立即停止。\n任务心态，在做事情时总想着还有多少才能完成，这种心态放弃聚焦事情本身和做事情的过程，而是为了完成任务而去做，这种心态只会让自己处于焦急、紧张、忙碌之中，无法专注于事情本身，无法获得过程中的快乐。\n第六节 反馈：是时候告诉你什么是真正的学习了 只注重原理知识的学习，从不实战、实践和跳过原理的学习，以实战输出为主，这两种学习方法导致的结果截然不同。\n在学习时一般都会选择从基础的理论开始并一直专注于理论层面的学习，而少了真正重要的部分，实践即输出，缺少实践的学习是不完整的，也是难以产生兴趣的，于是学习往往是枯燥乏味的，这种学习方式只是强迫理智脑在进行工作，但理智脑的能力是弱小的。\n如果是以输出为主，会使本能脑和情绪脑参加工作，更容易找到实践的乐趣并对这种学习方式产生兴趣，以此来专注于学习提升； 其次输出作品或是解决问题会产生即时的反馈，有了反馈必然会获得强烈的成就感和继续行动的欲望，这就是作品意识。\n有了产出就有了反馈，有了力量。虽然跳过理论的学习并不是长久之计，只能帮助尽快入门，让本能脑和情绪脑快速的体会到兴趣， 但反馈是贯穿始终的金钥匙，抓住反馈就抓住了进步的秘诀。\n想想也是，在我上大学时，听老师在课堂上将书本上的知识，听的云里雾里，但是到了实践课程的时候，通过自己实际操作，之前学到的知识马上理解了其中的原理，有一种豁然开朗的感觉，同时也觉得实践要比理论学习有趣的多，成就感也更大，对于工科的专业来说更是这样。\n第七节 休息：你没成功，可能是因为太刻苦了 精力是会被消耗的，随着时间的流失，做事情的精力和专注力会越来越少。这时你想到的是我要有足够的意志力，于是咬牙坚持下去， 结果是自己觉得很累，很难坚持。\n实际上正确的做法是在意识到自己的精力不足时，主动休息，等精力充足后继续专注学习，如此循环往复。\n因为当精力不足以使自己继续专注与正在做的事情时就会进入一种低效、劳累、煎熬、痛苦的状态，想休息却在咬牙坚持，如此下去必然无法长期坚持，只会使自己更快的放弃。\n番茄工作法是一种有效的工作方式，先保持极度专注的工作25分钟，然后休息5分钟，如此反复进行，只要到达休息时间就要马上停止工作，不能因为感觉自己还能继续专注而延迟休息的时间，这种做法实际上会造成后续的工作处于精力不足的状态，造成更大的损失。需要注意的是在休息时尽可能的停下来休息和放松，而不是去做刷手机、看视频这种同样耗费精力的事情。\n第六章 行动力——没有行动世界只是个概念 第一节 清晰：一个观念，重构你的行动力 每天早上都会收获满满的精力，如果起床就去看手机、刷视频，就是把这些精力浪费在了毫无用处的地方。\n增强回路指的是重复的行动将增强下次行动的动力，好比两人发生矛盾，每次肢体上的冲突都会激化矛盾，升级暴力。\n把这个道理运用到注意力上就是说每次点击手机上的标题都会使自己产生更强的欲望，如此下去便掉进了陷阱里，直到将精力消耗殆尽，又会感叹自己什么都没有做，陷入自责之中。\n知道了这个概念之后我们可能还是会拿起手机不自觉地开始负向的增强回路，一个非常重要的原因是你的想法在大脑中依然是模糊的，前文提到过，模糊使得行动变得缓慢，因为大脑讨厌模糊的事情，所以想要在一开始就开启正向的增强回路，清晰力是十分重要的。\n那么如何增强清晰力呢？\n答案就是在前一天晚上花费10分钟的时间将第二天要做的事情写下来，同时在第二天早上再花10分钟回顾。\n将一页A5纸分为4个部分：待办事项、计划完成、实际完成和备注。\n将心中的事情写下来，清空大脑，让自己处于单行线中，无法选择。\n消除模糊是提升行动力的关键，在开始行动之前确保你已经想清楚接下来要做什么怎么做。\n第二节 “傻瓜”：这个世界会奖励那些不计得失的“傻瓜” 我们总想先看到结果，然后才愿意付出努力和行动。\n然而想先看到结果再行动的人往往永远无法看到结果，因为当自己想要做一件事情的时候，我们距离目标是很远的，不然我们也不会想去做这件事，这个时候我们的认知、我们的视野看不到结果，于是很多人在两三天之后便放弃了，坚持下来的人他们的认知不断提高，视野不断清晰，有一天他们看清了结果，收获了结果。\n你觉得学习英语没用，是因为你看不到需要英语的地方。当你认为一件事情没用时，是因为自己的认知水平尚浅，没有达到更高水平的认知层次。所以当我们光想不做、缺乏行动时，我们依然一事无成。\n没有成功过，也就无法知道做成一件事是多么不容易，还在做着不切实际的幻想，也就更不会成功，如此下去进入恶行循环。\n反过来说如果你真的做成了一件事情，明白这背后付出的努力，到会减弱你的欲望，使自己能够沉静下来做一件事。\n就像我自己在大学时准备期末考试一样，在我付出了努力获得了分数上的结果，在下一个期末考试我就很容易继续付出努力，这其实也有一点增强回路的意思。\n还有一点是非常重要的，那就是突破阈值。\n很多人会发现自己努力了一段时间之后，收效甚微、不见结果，这是由于你所作的努力还在阈值之下，所谓量变产生质变，没有量的积累也就无法突破阈值的限制，永远见不到质变。\n广告行业就存在这种阈值效应，广告量少时看不到效果，在超过阈值后才能看到其产生的效果。\n在设立目标后做傻瓜式的行动，这个世界才会更加简单。\n第三节 行动：“道理都懂，就是不做”怎么破解 这世界上有两种学习方式：技能学习和认知学习。\n技能学习指的是像骑车、跳舞、唱歌这些技能的学习，它们的特点是在知道如何做后还需要大量的练习才能掌握，仅凭一次认知无法形成有效的正反馈，只有在经过不断练习的刺激后，相关的神经元与原有的神经元产生强联系，才掌握了这项技能。\n而认知学习是诸如知识、道理这些认知层次的学习，这些知识仅凭一次了解就能产生正反馈，使我们自己感觉我们已经明白了这个道理，及时满足，这样人们自然就不会再去做大量的练习巩固神经元之间的联系，这是人类的天性使然。\n既然了解了两种学习方式的概念，就很容易想到破解问题的方法就是将认知学习看作是技能学习。\n每当你了解到一个观点或是道理后就对自己说“我并没有掌握它，我还需要大量的运用和练习，让神经元之间的联系加强”，这样能够使自己坦然的面对，而不是浮躁的幻想。\n除此之外还有两点是我们需要注意的：第一点是很多人在开始时感觉到困难，于是便开始怀疑自己，产生焦虑情绪。\n其实这是完全没有必要的，在开始时感觉困难很正常，因为神经元之间还没有产生强大的联系，如果做成任何事都非常容易的话，我们为什么要去做它呢，那世界岂不是枯燥乏味，还有什么挑战性可言呢。\n第二点是将注意力放在自己的改变上而不是其他的东西。\n前面的章节提到过学习是为了改变，改变才是最终目标，没有让你获得改变的学习都是无效的学习，与其焦虑的学习各种知识，不如专注于自己改变了多少，你会发现其实我们能做的很少，只要每天改变一点点就足以让我们获得进步。\n第七章 情绪力——情绪是多角度看问题的智慧 第一节 心智带宽：唯有富足，方能解忧 印度蔗民在收获之前是最拮据的时候，他们整日忧心忡忡，表现为缺乏耐心，急于求成，而这些问题在收获之后又会得到改善。\n作者提到稀缺会使人变得目光短浅，缺乏耐心，因为心智带宽在减少。\n心智带宽就是内心的容量。\n其实不只是稀缺会消耗心智带宽，在如今的社会中，一次考试、面试、约会都是消耗心智的事情。这些事会占据我们的内心，使我们原本平和的内心变得焦躁不安，产生焦虑情绪。特别是在这个快速的社会中，压力、诱惑、欲望无一不占据着心智。\n如何清理心智带宽呢，作者提出了几点：\n1. 保持环境觉知，理智选择：\n压力通常来源于我们周围的环境，主动觉察环境发现压力，理智选择。\n2. 保持目标觉知，少即是多：\n固定目标，将精力放在最重要的事情上，放弃不重要的琐事，少即是多。\n3. 保持欲望觉知，审视决策：\n欲望太满会自乱阵脚，写下你想做的事情，清理自己的欲望，才能从杂乱中走出来。\n4. 保持情绪觉知，谨慎决定：\n一个心智富足的人，也是一个平心静气的人，保持稳定的情绪，不要被情绪扰乱你的心智。\n5. 保持闲余觉知，自我设限：\n适当的闲余时光是好的，但是过多的闲余使人变得平庸，如果你的闲余太多也要学会给自己设限，适当稀缺一些闲余。\n第二节 单一视角：你的坏情绪，源于视角单一 世界是多维的，如果我们总是以单一的视角来观察这个世界，就会偏执的对待这个世界。\n我们都知道拍照的角度不同，拍出来的画面也会大不相同，其实每个人就像一个相机，以不同的视角来看待周边的事物、看待人生以及这个世界。\n如果我们拍出来的画面是不完整的、模糊的、阴暗的，那就应该向那些清晰的、阳光的、宏大的画面看齐，寻找他们的角度。\n有些人在绝境之处依然能够看到一线生机，有些人纵使一帆风顺可依然不觉幸福。\n如何拍出好看的照片这里有几点建议：\n1. 勤移动：\n这个角度拍出来的画面太大，那就站远一点，拍出来的画面太暗，那就站在有光的地方，勤移动才能找到最合适的角度。\n2. 善学习：\n不学习无法登高处，不学习无法入江河，学习是为了能够看到更多的角度。\n3. 要开放：\n开放的态度，客观的看待一切，如果带着有色眼镜去拍照片，那自然无法看到最美的角度。\n4. 寻帮助：\n在我们陷入单一视角无法脱身时，应该借助他人的多维视角克服单一视角的局限，帮我们看清问题。\n5. 多运动：\n有氧运动产生的多巴胺会帮助大脑主动从不同的角度思考。\n6. 常反思：\n反思就是在和自己对话，站在客观的角度上看待自己的言行。\n第三节 游戏心态：幸福的人，总是在做另外一件事 自我决定理论指出人类有三种天生的内在需求：自我需求、关系需求、能力需求。\n自我需求指的是有自我选择的权力，自己能做自己想做的事情；\n关系需求是拥有良好的人际关系，受到别人的爱与尊敬；\n能力需求是有独特的本领，能够为其他人创造自己的价值。\n其中自我需求对幸福感的影响是比较大的。我们都有这样的经历：不想工作却不得不工作，不想写作业却不得不写作业。这些违背了我们意愿的事情让我们感觉不到幸福，我们会不自觉的排斥这些事情。\n那么如何让这些事情变成顺从我们的自我需求的事情呢？\n秘诀就是告诉自己其实是在做另一件事情，比如：我不是在工作，我是在提升自己；我不是在洗衣服，我是在活动放松。\n虽然这看起来比较幼稚，其实这么做是为了告诉自己我并不是在做这件事情，而是在做另一件我愿意做的事情，这样做更加符合自我选择和自我意愿。\n满足自我意愿的内在动机有两种：为自己而做和为玩而做，为自己而做，是为了应对外部的压力和要求。为玩而做，是为了应对重复、枯燥的事情。\n在做一件事情时的感受如何取决于我们赋予这件事何种角度。将它看作负担，这件事便是负担，将它看作放松，这件事便是放松。\n这个世界的模样取决于我们看待它的角度。\n第八章 早冥读写跑，人生五件套——成本最低的成长之道 第一节 早起：无闹钟、不参团、不打卡，我是如何坚持早起的  芝加哥大学的克雷特曼与德门克在实验中发现，人的眼球会在睡觉的时候来回运动，他们根据这个运动规律发现了“快速眼动睡眠”（REM）和“非快速眼动睡眠”（Non-REM）规律。健康的成年人睡觉时大多是1.5小时快速眼动睡眠、1.5小时非快速眼动睡眠，两种模式不断切换，并且在最初的两个单位时间内，也就是睡着之后的前3小时中，会进行高质量的睡眠（深度非快速眼动睡眠等于熟睡），之后则是浅层非快速眼动睡眠与快速眼动睡眠的组合。根据这一规律，人在睡眠后的3小时、4.5小时、6小时、7.5小时这几个节点醒来，就会觉得神清气爽，精力充沛。这就解释了为什么有时候我们睡了很长时间，但醒来后还是精神不佳，原因就是醒来的时机不在睡眠节点上，而是在睡眠周期中。\n  中岛孝志说：“闹钟不会照顾你的睡眠周期，时间一到，就会把手伸进你的脑子里，让你的脑子发生一场大地震，潜意识会被搅得一团糟。因为你是被闹钟吵醒的，大脑深处其实还睡着，所以明明睡了8小时，可总会觉得没睡饱，整个人昏昏沉沉的。”\n 前一天晚上将第二天早上做什么尽可能详细的计划出来，包括起晚了应该做什么或是天气不好应该做什么等等。\n计划的越明确，执行力也就越强。\n第二节 冥想：终有一天，你要解锁这条隐藏赛道 人的大脑中有7个小球，它们代表了我们的脑力资源。\n也就是说如果我们全身心的去做一件事，就是这7个小球共同在工作，如果我们在工作而脑子里却想着今天晚上吃什么的时候，可能只有3个小球在工作，剩下的4个小球去思考今天晚上应该吃什么去了。\n这就是为什么有的人能够一直保持高效率的工作，有的人工作一会就会分神。\n好在大脑的7个小球是可以被训练的，借助恰当的方式可以让它们目标一致，共同协作。这种理想的训练方式就是冥想。\n在冥想过程中，我们仅需把注意力全部集中到呼吸上，也就是说，让7个小球同时做一件事，如果其中某个小球走神了，把它柔和的拉回来即可。\n坚持这种练习，每天持续15分钟以上，就能养成专注的习惯。将专注变成无意识的行为，在不冥想时也能自动抑制思维离散，控制涣散的精神。换句话说，7个小球都能在需要的时候为你所用。\n第三节 阅读：如何让自己真正爱上阅读 未来学家凯文·凯利指出想要快速成为一个行业的高手，最好的方法就是和行业专家交流，直接向他们请教。\n但这种机会是极少的，那怎么办呢？\n看书\n看书能够在极低的代价下学习专家的观点，这就是为什么读一本好书就像是和一位智者谈话了。\n脚步不能丈量的地方，文字可以；眼睛无法看到的地方，文字可以。\n文字可以穿越古今中外，书籍就是智者看待事物、做选择、决策的过程。\n 阅读是为了改变。很多人以为一本书只要读完，读书的过程就结束了。事实上，阅读只是整个过程的开始，阅读之后的思考、思考之后的实践比阅读本身更加重要（这里主要指非虚构类书籍）。很多人的阅读仅停留在表面，读的时候觉得这里好有道理、那里好有道理，读完之后就不闻不问了，然后迅速转移到下一本书中，这种满足于录入的阅读造成的一个直接后果便是，一段时间之后再去翻这本书就好像之前没有看过一样，所有的痕迹都烟消云散了。真正读好一本书，往往需要花费数倍于阅读的时间去思考和实践，并输出自己的东西——可能是一篇文章，也可能是养成一个习惯——这个过程比阅读本身要费力得多。\n 第四节 写作：谢谢你，费曼先生 费曼技巧：无论学习什么东西，都要努力琢磨它们究竟在讲什么，它们的实际意义是什么，然后用自己的话将其重新讲出来。\n用自己的话讲出来，就是用最简单的方法让其他人明白你想要表达的意思，写作也是这样。\n这样做就会很少提及新的名词和概念，通常我们用已经知道的事物来类比需要讲述的新概念，这就自然而然的将我们已有的认知将新的认知联系起来，构造神经元之间的通路。\n人类大脑中存在着感性和理性，感性比理性更加强大。这就是为什么人们在阅读或交流时更愿意听故事，而不是讲道理。\n聪明的做法是先用合适的故事引起感性的注意，然后传达想要说明的道理给理性，既满足了感性，有照顾了理性。\n用聊天式的话语来写作也是个不错的方法。\n在闲聊时人们的语气是放松的、平和的，使读者更容易接收，避免了以说教式的话语来教育读者。\n第五节 运动：灵魂想要走得远，身体必须在路上 有氧运动会使大脑产生新的神经元，但此时的神经元是一个空白的干细胞，还无法为我们所用。\n一个空白的干细胞要经过28天的生长，长出轴突和树突之后，才能真正发挥作用。\n研究表明在运动后的1-2个小时里从事高强度脑力劳动（如学习、写作等等）或是体力劳动（如跳舞、钢琴等等）会刺激神经元的生长。\n作者还指出好的运动方式是有氧运动 + 复杂运动（如太极、瑜伽、舞蹈等等），复杂运动会促使神经细胞之间连接的更加紧密。\n结语 一流的生活不是富有，而是觉知 这篇结语主要是在说每日反思的重要性以及如何开始每日反思。\n作者指出每日反思只是记录一天中最触动自己的事情，就算某一天中断或者实在没有什么触动也没有关系，还是那句话：将注意力集中在改变上。\n复盘的方式极为简单，通常只需3点：\n 描述经过——以便日后回顾时能想起当时的场景 分析原因——多问几个为什么，直到有深度的启发 改进措施——尽可能提炼出一个认知点或行动点  总结来说就是在某个场景，我为什么会做出这样的反应，这样做对不对，如果不对我应该如何做。\n","date":"2022-03-26T00:00:00Z","image":"https://WangZichen99.github.io/img/2022/04/oasis.jpg","permalink":"https://WangZichen99.github.io/p/cognitiveawaken/","title":"认知觉醒读书笔记"},{"content":"SpringMVC 1、SpringMVC执行原理  用户访问后首先被web.xml中的DispatchServlet拦截下来 DispatchServlet调用HandlerMapping处理器映射，HandlerMapping根据请求url查找Handler HandlerExecution根据url到springmvc-servlet.xml中查找控制器controller，并将解析后的信息传递给DispatchServlet HandlerAdapter为处理器适配器，按照特定的规则执行Handler Handler让具体的controller执行 controller将执行信息(ModelAndView)返回给HandlerAdapter HandlerAdapter将视图逻辑名或模型传递给DispatchServlet DispatchServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名 视图解析器ViewResolver将解析的逻辑视图名传给DispatchServlet DispatchServlet根据视图解析器解析的结果，调用具体的视图   web.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;!--注册DispatchServlet--\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;!--关联一个springmvc配置文件：【servlet-name】-servlet.xml--\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:springmvc-servlet.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;!--启动级别-1--\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;!--/匹配所有请求：（不包括.jsp）--\u0026gt; \u0026lt;!--/*匹配所有请求（包括.jsp）--\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;/web-app\u0026gt;   springmvc-servlet.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\u0026#34;/\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\u0026#34;/\u0026gt; \u0026lt;!--视图解析器：DispatcherServlet返回的ModelAndView--\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026#34; id=\u0026#34;internalResourceViewResolver\u0026#34;\u0026gt; \u0026lt;!--前缀--\u0026gt; \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/WEB-INF/jsp/\u0026#34;/\u0026gt; \u0026lt;!--后缀--\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.jsp\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;   HelloController.java (实现了Controller接口就成为了一个视图解析器，返回ModelAndView)\n1 2 3 4 5 6 7 8 9 10 11 12 13  public class HelloController implements Controller { @Override public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { //ModelAndView模型和视图  ModelAndView mv = new ModelAndView(); //封装对象放在ModelAndView中  mv.addObject(\u0026#34;msg\u0026#34;, \u0026#34;HelloSpringMVC\u0026#34;); //封装要跳转的视图放在ModelAndView中  mv.setViewName(\u0026#34;hello\u0026#34;); ///WEB-INF/jsp/hello.jsp  //返回ModelAndView  return mv; } }   在spring-servlet.xml中注册bean，id对应请求路径，class对应视图解析器\n1 2  \u0026lt;!--Handler--\u0026gt; \u0026lt;bean id=\u0026#34;/hello\u0026#34; class=\u0026#34;com.wzc.controller.HelloController\u0026#34;/\u0026gt;   2、使用注解开发 配置资源过滤问题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  \u0026lt;build\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/java\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/resources\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;/build\u0026gt;   web.xml注册DispatchServlet\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;!--注册DispatchServlet--\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;!--关联一个springmvc配置文件：【servlet-name】-servlet.xml--\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:springmvc-servlet.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;!--启动级别-1--\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;!--/匹配所有请求：（不包括.jsp）--\u0026gt; \u0026lt;!--/*匹配所有请求（包括.jsp）--\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;/web-app\u0026gt;   springmvc-servlet.xml配置文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xmlns:mvc=\u0026#34;http://www.springframework.org/schema/mvc\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\u0026#34;\u0026gt; \u0026lt;!--自动扫描包，让指定包下的注解生效，有IOC容器统一管理--\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.wzc.controller\u0026#34;/\u0026gt; \u0026lt;!--让Spring MVC不处理静态资源--\u0026gt; \u0026lt;mvc:default-servlet-handler/\u0026gt; \u0026lt;!--支持mvc注解驱动，在spring中一般采用@RequestMapping注解来完成映射关系， 要使RequestMapping注解生效必须向上下文注册DefaultAnnotationHandlerMapping和AnnotationMethodHandlerAdapter实例， 这两个实例分别在类级别和方法级别处理，annotation-driven配置帮助我们自动完成两个实例的注入--\u0026gt; \u0026lt;mvc:annotation-driven/\u0026gt; \u0026lt;!--视图解析器--\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026#34; id=\u0026#34;internalResourceViewResolver\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/WEB-INF/jsp/\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.jsp\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;   HelloController.java\n1 2 3 4 5 6 7 8 9 10 11 12  @Controller @RequestMapping(\u0026#34;/api\u0026#34;) public class HelloController { @RequestMapping(\u0026#34;/hello\u0026#34;) public String hello(Model model) { //封装数据  model.addAttribute(\u0026#34;msg\u0026#34;, \u0026#34;hello annotation\u0026#34;); //视图解析器解析WEB-INF/jsp/hello.jsp  return \u0026#34;hello\u0026#34;; } }   使用Spring MVC必须配置的三大件：处理器映射器、处理器配置器、视图解析器\n通常我们只需手动配置视图解析器，处理器映射器和处理器配置器只需要开启注解驱动即可，省去了大量的xml配置\n3、Controller和RestFul风格 3.1、实现Controller接口 1 2 3 4 5 6 7 8 9 10 11 12 13  public class HelloController implements Controller { @Override public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { //ModelAndView模型和视图  ModelAndView mv = new ModelAndView(); //封装对象放在ModelAndView中  mv.addObject(\u0026#34;msg\u0026#34;, \u0026#34;HelloSpringMVC\u0026#34;); //封装要跳转的视图放在ModelAndView中  mv.setViewName(\u0026#34;hello\u0026#34;); ///WEB-INF/jsp/hello.jsp  //返回ModelAndView  return mv; } }   缺点：一个controller中只能实现一个方法\n3.2、使用注解@Controller  开启自动扫描  1 2  \u0026lt;context:component-scan base-package=\u0026#34;com.wzc.controller\u0026#34;/\u0026gt;   在类上添加@Controller注解 在方法上添加@RequestMapping  3.3、@RequestMapping RequestMapping注解用于映射url到控制器类或一个特定的方法，可同时注解在类和方法上\n访问时的顺序是类/方法\n3.4、RestFul风格 RestFul风格可以通过不同的请求方式来实现不同的效果，比如：\n http://127.0.0.1/item/1————查询, GET http://127.0.0.1/item————新增, POST http://127.0.0.1/item————修改, PUT http://127.0.0.1/item————删除, DELETE  在SpringMVC中可以使用@PathVariable注解，让方法的参数值对应绑定到一个url模板变量上\n1 2 3 4 5 6 7 8 9  @Controller public class RestFulController { @RequestMapping(\u0026#34;/add/{a}/{b}\u0026#34;) public String add(@PathVariable(\u0026#34;a\u0026#34;) int a, @PathVariable(\u0026#34;b\u0026#34;) int b, Model model) { model.addAttribute(\u0026#34;msg\u0026#34;, a + b); return \u0026#34;restful\u0026#34;; } }   注解介绍：\n@GetMapping(\u0026quot;\\hello\u0026quot;)表示get请求\n@PostMapping(\u0026quot;\\hello\u0026quot;)表示post请求\n@PutMapping(\u0026quot;\\hello\u0026quot;)表示put请求\n@DeleteMapping(\u0026quot;\\hello\u0026quot;)表示delete请求\n使用路径变量的好处：\n 使路径变得更加简洁 获得参数更加方便  3.5、重定向和转发 通过SpringMVC实现重定向和转发，无需视图解析器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  @Controller public class ForwardAndRedirect { //转发一  @RequestMapping(\u0026#34;/ForwardAndRedirect/forward1\u0026#34;) public String forward1(Model model) { model.addAttribute(\u0026#34;msg\u0026#34;, \u0026#34;转发到restful.jsp\u0026#34;); return \u0026#34;/WEB-INF/jsp/restful.jsp\u0026#34;; } //转发二  @RequestMapping(\u0026#34;/ForwardAndRedirect/forward2\u0026#34;) public String forward2() { return \u0026#34;forward:/index.jsp\u0026#34;; } //重定向（重定向不走视图解析器，并且重定向不能访问WEB-INF下的内容）  @RequestMapping(\u0026#34;/ForwardAndRedirect/redirect\u0026#34;) public String redirect() { return \u0026#34;redirect:/index.jsp\u0026#34;; } }   3.6、SpringMVC参数接收 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  @Controller @RequestMapping(\u0026#34;/user\u0026#34;) public class UserController { @GetMapping(\u0026#34;/get\u0026#34;) public String get(@RequestParam(\u0026#34;username\u0026#34;) String name, Model model) { model.addAttribute(\u0026#34;msg\u0026#34;, name); return \u0026#34;/WEB-INF/jsp/restful.jsp\u0026#34;; } @GetMapping(\u0026#34;getUser\u0026#34;) public void getUser(User user) { System.out.println(user); } }   在使用实体类接收参数时，前端需要将参数名与实体类变量名称一一对应，否则无法接收到所传参数\n3.7、乱码问题 在post请求中，前端传递中文时会产生乱码问题\n方法一：使用过滤器解决乱码\n1 2 3 4 5 6 7 8  public class EncodingFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { servletRequest.setCharacterEncoding(\u0026#34;utf-8\u0026#34;); servletResponse.setCharacterEncoding(\u0026#34;utf-8\u0026#34;); filterChain.doFilter(servletRequest, servletResponse); } }   web.xml中配置filter\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;web-app\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;encodingFilter\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;com.wzc.filter.EncodingFilter\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;encodingFilter\u0026lt;/filter-name\u0026gt; \u0026lt;!--/不包括jsp页面--\u0026gt; \u0026lt;!--/*包括jsp页面--\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; \u0026lt;/web-app\u0026gt;   方法二：springmvc提供的编码过滤器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;web-app\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;encoding\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.CharacterEncodingFilter\u0026lt;/filter-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;encoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;utf-8\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;encoding\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; \u0026lt;/web-app\u0026gt;   4、JSON 4.1、Jackson  导包  1 2 3 4 5 6  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.11.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   使用方法  1 2 3 4 5 6 7 8 9 10 11 12  @Controller public class UserController { @GetMapping(\u0026#34;/getUser\u0026#34;) @ResponseBody public String getUser() throws JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); User user = new User(1, \u0026#34;王子琛\u0026#34;, 22); String result = mapper.writeValueAsString(user); return result; } }   乱码问题的解决方法： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;!--Json乱码问题解决--\u0026gt; \u0026lt;mvc:annotation-driven\u0026gt; \u0026lt;mvc:message-converters\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.http.converter.StringHttpMessageConverter\u0026#34;\u0026gt; \u0026lt;constructor-arg value=\u0026#34;UTF-8\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.http.converter.cbor.MappingJackson2CborHttpMessageConverter\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;objectMapper\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;failOnEmptyBeans\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/mvc:message-converters\u0026gt; \u0026lt;/mvc:annotation-driven\u0026gt;   @Controller和@RestController的区别：\n @Controller会走是解析器 @RestController会返回字符串 @ResponseBody是配合@Controller来使用，如果使用了@RestController就不需要了  返回日期类型\n1 2 3 4 5 6 7 8 9 10 11 12 13  @RestController public class UserController { @GetMapping(\u0026#34;/getDate\u0026#34;) public String getDate() throws JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); //不使用时间戳方式返回Date  mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //自定义文件格式  mapper.setDateFormat(new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;)); return mapper.writeValueAsString(new Date()); } }   封装工具类JsonUtil\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public class JsonUtil { public static String getJson(Object object) { return getJson(object, \u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); } public static String getJson(Object object, String format) { ObjectMapper mapper = new ObjectMapper(); mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); mapper.setDateFormat(new SimpleDateFormat(format)); try { return mapper.writeValueAsString(object); } catch (JsonProcessingException e) { e.printStackTrace(); } return null; } }   4.2、FastJson  导包  1 2 3 4 5 6  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.75\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   用法   java对象转Json字符串  JSON.toJSONString()   Json字符串转java对象  JSON.parseObject()   java对象转Json对象  JSON.toJSON()   JSON对象转java对象  JSON.parseJavaObject()    5、整合SSM  数据库  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  CREATEDATABASE`ssmbuild`;USE`ssmbuild`;CREATETABLE`books`(`bookID`INT(10)NOTNULLauto_incrementCOMMENT\u0026#39;id\u0026#39;,`bookName`VARCHAR(100)NOTNULLCOMMENT\u0026#39;书名\u0026#39;,`bookCounts`INT(11)NOTNULLCOMMENT\u0026#39;数量\u0026#39;,`detail`VARCHAR(200)NOTNULLCOMMENT\u0026#39;描述\u0026#39;,KEY`bookID`(`bookID`))ENGINE=INNODBDEFAULTCHARSET=utf8;INSERTINTO`books`(`bookID`,`bookName`,`bookCounts`,`detail`)VALUES(1,\u0026#39;Java\u0026#39;,1,\u0026#39;从入门到放弃\u0026#39;),(2,\u0026#39;MySQL\u0026#39;,10,\u0026#39;从删库到跑路\u0026#39;),(3,\u0026#39;Linux\u0026#39;,5,\u0026#39;从进门到进牢\u0026#39;);  导包和静态资源导出问题  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85  \u0026lt;project\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.25\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--数据库连接池c3p0--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.mchange\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;c3p0\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.5.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.5.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.5.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet.jsp\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jsp-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jstl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.75\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.16\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;*/src/main/java\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;*/src/main/resources\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt;   5.1、Mybatis层  mybatis-config.xml  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!--配置数据源，交给Spring去做--\u0026gt; \u0026lt;typeAliases\u0026gt; \u0026lt;package name=\u0026#34;com.wzc.pojo\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;package name=\u0026#34;com.wzc.mapper\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt;   Books  1 2 3 4 5 6 7 8 9  @Data @AllArgsConstructor @NoArgsConstructor public class Books { private int bookID; private String bookName; private int bookCounts; private String detail; }   BookMapper  1 2 3 4 5 6 7 8 9 10 11  public interface BookMapper { int addBook(Books book); int deleteBookById(@Param(\u0026#34;Id\u0026#34;) int id); int updateBook(Books book); Books queryBookById(@Param(\u0026#34;Id\u0026#34;) int id); List\u0026lt;Books\u0026gt; queryAllBook(); }   BookMapper.xml  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.wzc.com.wzc.controller.mapper.BookMapper\u0026#34;\u0026gt; \u0026lt;insert id=\u0026#34;addBook\u0026#34; parameterType=\u0026#34;Books\u0026#34;\u0026gt; insert into ssmbuild.books(bookID, bookName, bookCounts, detail) VALUES (#{bookID}, #{bookName}, #{bookCounts}, #{detail}) \u0026lt;/insert\u0026gt; \u0026lt;delete id=\u0026#34;deleteBookById\u0026#34; parameterType=\u0026#34;int\u0026#34;\u0026gt; delete from ssmbuild.books where bookID = #{id} \u0026lt;/delete\u0026gt; \u0026lt;update id=\u0026#34;updateBook\u0026#34; parameterType=\u0026#34;Books\u0026#34;\u0026gt; update ssmbuild.books set bookName = #{bookName}, bookCounts = #{bookCounts}, detail = #{detail} where bookID = #{bookId} \u0026lt;/update\u0026gt; \u0026lt;select id=\u0026#34;queryBookById\u0026#34; parameterType=\u0026#34;int\u0026#34; resultType=\u0026#34;Books\u0026#34;\u0026gt; select bookID, bookName, bookCounts, detail from ssmbuild.books where bookID = #{id} \u0026lt;/select\u0026gt; \u0026lt;select id=\u0026#34;queryAllBook\u0026#34; resultType=\u0026#34;Books\u0026#34;\u0026gt; select bookID, bookName, bookCounts, detail from ssmbuild.books; \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt;   BookService  1 2 3 4 5 6 7 8 9 10 11  public interface BookService { int addBook(Books book); int deleteBookById(@Param(\u0026#34;Id\u0026#34;) int id); int updateBook(Books book); Books queryBookById(@Param(\u0026#34;Id\u0026#34;) int id); List\u0026lt;Books\u0026gt; queryAllBook(); }   BookServiceImpl  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  public class BookServiceImpl implements BookService { private BookMapper bookMapper; public void setBookMapper(BookMapper bookMapper) { this.bookMapper = bookMapper; } @Override public int addBook(Books book) { return bookMapper.addBook(book); } @Override public int deleteBookById(int id) { return bookMapper.deleteBookById(id); } @Override public int updateBook(Books book) { return bookMapper.updateBook(book); } @Override public Books queryBookById(int id) { return bookMapper.queryBookById(id); } @Override public List\u0026lt;Books\u0026gt; queryAllBook() { return bookMapper.queryAllBook(); } }   5.2、Spring层 spring-dao.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;!--关联数据库配置文件--\u0026gt; \u0026lt;context:property-placeholder location=\u0026#34;classpath:database.properties\u0026#34;/\u0026gt; \u0026lt;!--连接池 dbcp：半自动化操作，不能自动连接 c3p0：自动化操作（自动化加载配置文件并自动设置到对象中） druid，hikari--\u0026gt; \u0026lt;bean id=\u0026#34;datasource\u0026#34; class=\u0026#34;com.mchange.v2.c3p0.ComboPooledDataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClass\u0026#34; value=\u0026#34;${jdbc.driver}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;jdbcUrl\u0026#34; value=\u0026#34;${jdbc.url}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;user\u0026#34; value=\u0026#34;${jdbc.username}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${jdbc.password}\u0026#34;/\u0026gt; \u0026lt;!--c3p0私有属性--\u0026gt; \u0026lt;property name=\u0026#34;maxPoolSize\u0026#34; value=\u0026#34;30\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;minPoolSize\u0026#34; value=\u0026#34;10\u0026#34;/\u0026gt; \u0026lt;!--关闭连接后不自动commit--\u0026gt; \u0026lt;property name=\u0026#34;autoCommitOnClose\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;!--获取连接超时时间--\u0026gt; \u0026lt;property name=\u0026#34;checkoutTimeout\u0026#34; value=\u0026#34;10000\u0026#34;/\u0026gt; \u0026lt;!--连接失败重试次数--\u0026gt; \u0026lt;property name=\u0026#34;acquireRetryAttempts\u0026#34; value=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--sqlSessionFactory--\u0026gt; \u0026lt;bean id=\u0026#34;sqlSessionFactory\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;datasource\u0026#34;/\u0026gt; \u0026lt;!--绑定Mybatis配置文件--\u0026gt; \u0026lt;property name=\u0026#34;configLocation\u0026#34; value=\u0026#34;classpath:mybatis-config.xml\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--配置dao接口扫描包，动态实现了dao接口可以注入到spring容器中--\u0026gt; \u0026lt;bean class=\u0026#34;org.mybatis.spring.mapper.MapperScannerConfigurer\u0026#34;\u0026gt; \u0026lt;!--注入sqlSessionFactory--\u0026gt; \u0026lt;property name=\u0026#34;sqlSessionFactoryBeanName\u0026#34; value=\u0026#34;sqlSessionFactory\u0026#34;/\u0026gt; \u0026lt;!--要扫描的dao包--\u0026gt; \u0026lt;property name=\u0026#34;basePackage\u0026#34; value=\u0026#34;com.wzc.mapper\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;   spring-service.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;!--扫描service下的包--\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.wzc.service\u0026#34;/\u0026gt; \u0026lt;!--声明式事务配置--\u0026gt; \u0026lt;bean id=\u0026#34;transactionManager\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DataSourceTransactionManager\u0026#34;\u0026gt; \u0026lt;!--注入数据源--\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;datasource\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--aop事务支持--\u0026gt; \u0026lt;/beans\u0026gt;   5.3、SpringMVC层 spring-mvc.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:mvn=\u0026#34;http://www.springframework.org/schema/mvc\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;!--注解驱动--\u0026gt; \u0026lt;mvn:annotation-driven/\u0026gt; \u0026lt;!--静态资源配置过滤--\u0026gt; \u0026lt;mvn:default-servlet-handler/\u0026gt; \u0026lt;!--扫描包：controller--\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.wzc.controller\u0026#34;/\u0026gt; \u0026lt;!--视图解析器--\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/WEB-INF/jsp/\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.jsp\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;   web.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;!--DispatchServlet--\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:applicationContext.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;!--乱码过滤--\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;encodingFilter\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.CharacterEncodingFilter\u0026lt;/filter-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;encoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;utf-8\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;encodingFilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; \u0026lt;!--Session--\u0026gt; \u0026lt;session-config\u0026gt; \u0026lt;session-timeout\u0026gt;15\u0026lt;/session-timeout\u0026gt; \u0026lt;/session-config\u0026gt; \u0026lt;/web-app\u0026gt;   applicationContext.xml\n1 2 3 4 5 6 7 8 9 10  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;import resource=\u0026#34;classpath:spring-dao.xml\u0026#34;/\u0026gt; \u0026lt;import resource=\u0026#34;classpath:spring-service.xml\u0026#34;/\u0026gt; \u0026lt;import resource=\u0026#34;classpath:spring-mvc.xml\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt;   6、拦截器 拦截器只会拦截controller中的方法，而不会拦截静态资源\n实现InterceptorHandler接口就可以自定义一个拦截器\n拦截器是AOP思想的具体应用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public class MyInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // return true为放行，return false为拦截  return HandlerInterceptor.super.preHandle(request, response, handler); } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { HandlerInterceptor.super.postHandle(request, response, handler, modelAndView); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { HandlerInterceptor.super.afterCompletion(request, response, handler, ex); } }   1 2 3 4 5 6 7  \u0026lt;!--拦截器配置--\u0026gt; \u0026lt;mvc:interceptors\u0026gt; \u0026lt;mvc:interceptor\u0026gt; \u0026lt;mvc:mapping path=\u0026#34;/**\u0026#34;/\u0026gt; \u0026lt;bean class=\u0026#34;com.wzc.config.MyInterceptor\u0026#34;/\u0026gt; \u0026lt;/mvc:interceptor\u0026gt; \u0026lt;/mvc:interceptors\u0026gt;   未登录用户拦截\nmain.jsp\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;首页\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;首页\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;${sessionScope.username}\u0026lt;/p\u0026gt; \u0026lt;a href=\u0026#34;${pageContext.request.contextPath}/user/logout\u0026#34;\u0026gt;注销\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   login.jsp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;登录\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form action=\u0026#34;${pageContext.request.contextPath}/user/login\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;label\u0026gt;用户名：\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34;\u0026gt; \u0026lt;label\u0026gt;密码：\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;pwd\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   LoginController\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  @Controller @RequestMapping(\u0026#34;/user\u0026#34;) public class LoginController { @GetMapping(\u0026#34;/main\u0026#34;) public String main() { return \u0026#34;main\u0026#34;; } @GetMapping(\u0026#34;/login\u0026#34;) public String login() { return \u0026#34;login\u0026#34;; } @PostMapping(\u0026#34;/login\u0026#34;) public String login(Login login, HttpServletRequest request) { request.getSession().setAttribute(\u0026#34;username\u0026#34;, login.getUsername()); return \u0026#34;main\u0026#34;; } @GetMapping(\u0026#34;/logout\u0026#34;) public String logout(HttpServletRequest request) { request.getSession().removeAttribute(\u0026#34;username\u0026#34;); return \u0026#34;login\u0026#34;; //如果要返回首页，需要写成return \u0026#34;redirect:/user/main\u0026#34;，否则需要点击两次注销才会被拦截  // 如果写成return \u0026#34;main\u0026#34;，返回的还是main.jsp，这时第一次点击注销时无法触发拦截器  } }   LoginInterceptor\n1 2 3 4 5 6 7 8 9 10 11  public class LoginInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //如果session中有username或者访问登录页面就放行  if (request.getSession().getAttribute(\u0026#34;username\u0026#34;) != null || request.getRequestURI().toLowerCase().contains(\u0026#34;login\u0026#34;)) { return true; } request.getRequestDispatcher(\u0026#34;/WEB-INF/jsp/login.jsp\u0026#34;).forward(request, response); return false; } }   7、文件上传与下载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  @RestController @RequestMapping(\u0026#34;/file\u0026#34;) public class FileController { @PostMapping(\u0026#34;/upload\u0026#34;) public String upload (@RequestParam(\u0026#34;file\u0026#34;)CommonsMultipartFile file, HttpServletRequest request) throws IOException { String filename = file.getOriginalFilename(); if (StringUtils.isEmpty(filename)) { return \u0026#34;redirect:/index.jsp\u0026#34;; } String path = request.getServletContext().getRealPath(\u0026#34;/upload\u0026#34;); File filepath = new File(path); if (!filepath.exists()) { filepath.mkdirs(); } //读写文件  try (InputStream inputStream = file.getInputStream(); FileOutputStream fileOutputStream = new FileOutputStream(new File(filepath, filename));) { int len = 0; byte[] buffer = new byte[1024]; while ((len = inputStream.read(buffer)) != -1) { fileOutputStream.write(buffer, 0, len); fileOutputStream.flush(); } } return \u0026#34;上传成功！\u0026#34;; } @PostMapping(\u0026#34;/upload1\u0026#34;) public String upload1 (@RequestParam(\u0026#34;file\u0026#34;)CommonsMultipartFile file, HttpServletRequest request) throws IOException { String path = request.getServletContext().getRealPath(\u0026#34;/upload\u0026#34;); File filepath = new File(path); if (!filepath.exists()) { filepath.mkdirs(); } //直接写文件  file.transferTo(new File(filepath + File.separator + file.getOriginalFilename())); return \u0026#34;上传成功！\u0026#34;; } @RequestMapping(\u0026#34;download\u0026#34;) public void download(HttpServletRequest request, HttpServletResponse response, String filename) throws UnsupportedEncodingException { //设置response响应头  response.reset(); response.setCharacterEncoding(\u0026#34;UTF-8\u0026#34;); response.setContentType(\u0026#34;multipart/form-data\u0026#34;); response.setHeader(\u0026#34;Content-Disposition\u0026#34;, \u0026#34;attachment;fileName=\u0026#34; + URLEncoder.encode(filename, \u0026#34;UTF-8\u0026#34;)); File file = new File(request.getServletContext().getRealPath(\u0026#34;/upload\u0026#34;), filename); try (FileInputStream fileInputStream = new FileInputStream(file); ServletOutputStream outputStream = response.getOutputStream()) { int len = 0; byte[] buffer = new byte[1024]; while ((len = fileInputStream.read(buffer)) != -1) { outputStream.write(buffer, 0, len); outputStream.flush(); } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } }   ","date":"2022-03-12T00:00:00Z","image":"https://WangZichen99.github.io/img/2022/04/beach.png","permalink":"https://WangZichen99.github.io/p/springmvcnote/","title":"SpringMVC笔记"},{"content":"Mybatis 1、第一个Mybatis程序 1.1、搭建环境 搭建数据库：\n1 2 3 4 5 6 7 8 9  CREATEDATABASE`mybatis`;USE`mybatis`;CREATETABLE`user`(`id`INT(20)NOTNULLPRIMARYKEY,`name`VARCHAR(30)DEFAULTNULL,`pwd`VARCHAR(30)DEFAULTNULL)ENGINE=INNODBDEFAULTCHARSET=utf8;  新建项目：\n 新建一个maven项目 删除src目录 导入maven依赖  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  \u0026lt;dependencies\u0026gt; \u0026lt;!--mysql驱动--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.25\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--mybatis--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.13\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.22\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;   1.2、创建一个模块  编写mybatis的核心配置文件  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;!--核心配置文件--\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;!--事务管理--\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;\u0026gt;\u0026lt;/transactionManager\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mybatis?userSSL=true\u0026amp;amp;useUnicode=true\u0026amp;amp;characterEncoding=utf-8\u0026amp;amp;serverTimezone=GMT%2B8\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;123456\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;!--每一个mapper.xml都需要在mybatis配置文件中注册--\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;com/wzc/dao/UserMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt;    编写mybatis的工具类  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  //sqlSessionFactory --\u0026gt; sqlSession public class MybatisUtils { private static SqlSessionFactory sqlSessionFactory; static { try { //使用Mybatis获取sqlSessionFactory对象  String resource = \u0026#34;mybatis-config.xml\u0026#34;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); } } public static SqlSession getSqlSession() { return sqlSessionFactory.openSession(); } }   1.3、编写代码  实体类  1 2 3 4 5 6 7 8  @Data @AllArgsConstructor @NoArgsConstructor public class User { private int id; private String name; private String pwd; }    Dao接口  1 2 3  public interface UserDao { List\u0026lt;User\u0026gt; userList(); }    mapper.xml  1 2 3 4 5 6 7 8 9 10  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.wzc.dao.UserDao\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;userList\u0026#34; resultType=\u0026#34;com.wzc.pojo.User\u0026#34;\u0026gt; select * from user; \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt;   1.4、测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  public class UserDaoTest { @Test public void test1() { //获取sqlSession对象  SqlSession sqlSession = MybatisUtils.getSqlSession(); try { //方法一：getMapper，推荐（不需要强转以及写错字符串）  UserDao mapper = sqlSession.getMapper(UserDao.class); List\u0026lt;User\u0026gt; userList = mapper.userList(); //方法二：不推荐使用  //List\u0026lt;User\u0026gt; userList = sqlSession.selectList(\u0026#34;com.wzc.dao.UserDao.userList\u0026#34;);  for (User user : userList) { System.out.println(user); } } finally { //关闭sqlSession  sqlSession.close(); } } }   2、CRUD 2.1 namespace namespace中的包名要和mapper接口的包名一致\n2.2、select 查询语句\n id：对应接口中的方法名 resultType：sql语句的返回值 parameterType：参数类型  1 2 3  \u0026lt;select id=\u0026#34;getUserById\u0026#34; parameterType=\u0026#34;int\u0026#34; resultType=\u0026#34;com.wzc.pojo.User\u0026#34;\u0026gt; select * from user where id = #{id}; \u0026lt;/select\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12  public class UserDaoTest { @Test public void userListTest() { try (SqlSession sqlSession = MybatisUtils.getSqlSession()) { UserDao mapper = sqlSession.getMapper(UserDao.class); List\u0026lt;User\u0026gt; userList = mapper.userList(); for (User user : userList) { System.out.println(user); } } } }   2.3、insert 1 2 3  \u0026lt;insert id=\u0026#34;addUser\u0026#34; parameterType=\u0026#34;com.wzc.pojo.User\u0026#34;\u0026gt; insert into user (id, name, pwd) values (#{id}, #{name}, #{pwd}); \u0026lt;/insert\u0026gt;   2.4、update 1 2 3  \u0026lt;update id=\u0026#34;updateUserById\u0026#34; parameterType=\u0026#34;com.wzc.pojo.User\u0026#34;\u0026gt; update user set name = #{name}, pwd = #{pwd} where id = #{id}; \u0026lt;/update\u0026gt;   2.5、delete 1 2 3  \u0026lt;delete id=\u0026#34;deleteUserById\u0026#34; parameterType=\u0026#34;int\u0026#34;\u0026gt; delete from user where id = #{id}; \u0026lt;/delete\u0026gt;   注意点：\n 增删改操作都需要提交事务：sqlSession.commit();  3、万能Map 当实体类中字段过多时，应当考虑使用Map\n1 2 3  public interface UserDao { int addUserMap(Map\u0026lt;String, Object\u0026gt; user); }   Map传递参数直接在sql中取出key即可\n4、模糊查询  传递带通配符的参数  1 2 3  public class UserDaoTest { List\u0026lt;User\u0026gt; userList = mapper.getUserLikeName(\u0026#34;%i%\u0026#34;); }   在sql中拼接通配符  1 2 3  \u0026lt;select id=\u0026#34;getUserLikeName\u0026#34; resultType=\u0026#34;com.wzc.pojo.User\u0026#34;\u0026gt; select * from user where name like concat(\u0026#39;%\u0026#39;, #{name}, \u0026#39;%\u0026#39;); \u0026lt;/select\u0026gt;   5、配置解析 5.1、核心配置文件  mybatis-config.xml  1 2 3 4 5 6 7 8 9 10 11 12 13  configuration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器）   5.2、环境配置（environments） Mybatis可以配置成适应多种环境，但是尽管可以配置多种环境，每个SqlSessionFactory实例只能选择一种环境\nMybatis默认的事务管理器就是JDBC\n5.3、属性（properties） 属性可以外部配置和动态替换，既可以在java属性文件中配置，也可以使用properties子元素指定\n编写配置文件db.properties\n1 2 3 4  driver=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/mybatis?userSSL=true\u0026amp;useUnicode=true\u0026amp;characterEncoding=utf-8\u0026amp;serverTimezone=GMT%2B8 #username=root #password=123456   在核心配置文件中引入\n1 2 3 4 5 6 7 8  \u0026lt;configuration\u0026gt; \u0026lt;!--引入外部配置文件--\u0026gt; \u0026lt;properties resource=\u0026#34;db.properties\u0026#34;\u0026gt; \u0026lt;!--优先读取property属性指定的配置，然后才读取外部配置文件覆盖同名属性--\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;123456\u0026#34;/\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/configuration\u0026gt;   优先读取property标签中的属性，然后读取外部配置文件中的属性并覆盖同名的属性\n5.4、类型别名（typeAliases）  类型别名是为java类型设置一个短的名字 存在的意义仅在于用来减少类完全限定名的冗余  1 2 3  \u0026lt;typeAliases\u0026gt; \u0026lt;typeAlias type=\u0026#34;com.wzc.pojo.User\u0026#34; alias=\u0026#34;User\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt;   也可以指定一个包名，Mybatis会在包名下面搜索需要的java bean，默认的别名为类名\n1 2 3 4  \u0026lt;typeAliases\u0026gt; \u0026lt;!--\u0026lt;typeAlias type=\u0026#34;com.wzc.pojo.User\u0026#34; alias=\u0026#34;User\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;package name=\u0026#34;com.wzc.pojo\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt;   5.5、设置（settings）  logImpl：指定Mybatis所用日志 cacheEnabled：全局开启或关闭缓存 lazyLoadingEnabled：全局懒加载开关  6、其他配置  typeHandler（类型处理器） objectFactory（类型工厂） plugins（插件）  mybatis-generator-core mybatis-plus 通用mapper    7、映射器（mappers） MapperRegistry：注册绑定Mapper文件\n方法一：【推荐使用】\n1 2 3 4  \u0026lt;!--每一个mapper.xml都需要在mybatis配置文件中注册--\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;com/wzc/mapper/UserMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt;   方法二：使用class文件绑定注册\n1 2 3  \u0026lt;mappers\u0026gt; \u0026lt;mapper class=\u0026#34;com.wzc.mapper.UserMapper\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt;   注意点：\n 接口和Mapper配置文件必须同名 接口和Mapper配置文件必须在同一个包下  方法三：使用扫描包进行注入\n注意点和方法二一样\n1 2 3  \u0026lt;mappers\u0026gt; \u0026lt;package name=\u0026#34;com.wzc.mapper\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt;   8、生命周期和作用域 生命周期和作用域是重要的，因为错误的使用会导致严重的并发问题\nSqlSessionFactoryBuilder：\n 一旦创建了SqlSessionFactory，就不再需要SqlSessionFactoryBuilder 局部变量  SqlSessionFactory：\n 可以理解为数据库连接池 一旦创建就应该在程序运行期间一直存在， 没有理由丢弃或重新创建一个实例（单例模式或静态单例模式实现） SqlSessionFactory的最佳作用域是应用作用域  SqlSession：\n 可以理解为连接池的一个请求 SqlSession实例不是线程安全的，所以不能被共享，最佳作用域是请求或方法作用域 用完之后需要关闭，释放资源  9、resultMap 结果集映射，解决数据库字段名与实体类属性名称不一致的问题\n1 2 3 4 5 6  \u0026lt;resultMap id=\u0026#34;UserMap\u0026#34; type=\u0026#34;User\u0026#34;\u0026gt; \u0026lt;!--column：数据库中的字段，property：实体类中的属性--\u0026gt; \u0026lt;result column=\u0026#34;id\u0026#34; property=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;name\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;pwd\u0026#34; property=\u0026#34;password\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt;   10、日志 10.1、日志工厂 Mybatis的settings中提供了日志配置的设置logImpl 支持的选项有：\n SLF4J LOG4J【掌握】 LOG4J2 JDK_LOGGING COMMONS_LOGGING STDOUT_LOGGING【掌握】 NO_LOGGING  STDOUT_LOGGING标准日志输出：\n1 2 3  \u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026#34;logImpl\u0026#34; value=\u0026#34;STDOUT_LOGGING\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt;   6.2、Log4j  先导入log4j的包  1 2 3 4 5  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.logging.log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.17.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   log4j.properties  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  # 将等级为DEBUG的日志输出到console和file这两个目的地 log4j.rootLogger=DEBUG,console # ,file # 控制台输出相关设置 log4j.appender.console=org.apache.log4j.ConsoleAppender log4j.appender.console.Target=System.out log4j.appender.console.Threshold=DEBUG log4j.appender.console.layout=org.apache.log4j.PatternLayout log4j.appender.console.layout.ConversionPattern=[%c]-%m%n # 文件输出相关设置 # log4j.appender.file=org.apache.log4j.RollingFileAppender # log4j.appender.file.File=输出文件路径 # log4j.appender.file.MaxFileSize=最大文件大小 # log4j.appender.file.Threshold=DEBUG # log4j.appender.console.layout=org.apache.log4j.PatternLayout # log4j.appender.console.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n # 日志输出级别 log4j.logger.org.mybatis=DEBUG log4j.logger.java.sql=DEBUG log4j.logger.java.sql.Statement=DEBUG log4j.logger.java.sql.ResultSet=DEBUG log4j.logger.java.sql.PreparedStatement=DEBUG   配置log4j日志实现  1 2 3  \u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026#34;logImpl\u0026#34; value=\u0026#34;LOG4J\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt;   简单使用\n 导入org.apache.log4j.Logger 获取日志对象  1  static Logger logger = Logger.getLogger(UserMapperTest.class);   日志级别  1 2 3  logger.info(\u0026#34;info: 进入了test2\u0026#34;); logger.debug(\u0026#34;debug: 进入了test2\u0026#34;); logger.error(\u0026#34;error: 进入了test2\u0026#34;);   7、分页 7.1、使用limit分页 1  select*fromuserlimitstartIndex,pageSize;  使用Mybatis实现分页，核心为sql\n 接口  1  List\u0026lt;User\u0026gt; userPage(Map\u0026lt;String, Integer\u0026gt; condition);   Mapper.xml  1 2 3  \u0026lt;select id=\u0026#34;userPage\u0026#34; parameterType=\u0026#34;map\u0026#34; resultMap=\u0026#34;UserMap\u0026#34;\u0026gt; select * from user limit #{startIndex}, #{pageSize}; \u0026lt;/select\u0026gt;   测试  1 2 3 4 5 6 7 8 9 10 11 12 13  @Test public void userPageTest() { try (SqlSession sqlSession = MybatisUtil.getSqlSession()) { UserMapper mapper = sqlSession.getMapper(UserMapper.class); Map\u0026lt;String, Integer\u0026gt; condition = new HashMap\u0026lt;\u0026gt;(); condition.put(\u0026#34;startIndex\u0026#34;, 1); condition.put(\u0026#34;pageSize\u0026#34;, 2); List\u0026lt;User\u0026gt; userList = mapper.userPage(condition); for (User user : userList) { System.out.println(user); } } }   7.2、RowBounds分页【不推荐使用】  接口  1  List\u0026lt;User\u0026gt; userRowBounds();   mapper.xml  1 2 3  \u0026lt;select id=\u0026#34;userRowBounds\u0026#34; resultMap=\u0026#34;UserMap\u0026#34;\u0026gt; select * from user; \u0026lt;/select\u0026gt;   测试  1 2 3 4 5 6 7 8 9  @Test public void userRowBoundsTest() { try (SqlSession sqlSession = MybatisUtil.getSqlSession()) { List\u0026lt;User\u0026gt; userList = sqlSession.selectList(\u0026#34;com.wzc.mapper.UserMapper.userRowBounds\u0026#34;, null, new RowBounds(1, 2)); for (User user : userList) { System.out.println(user); } } }   7.3、分页插件 pageHelper：https://pagehelper.github.io/docs/howtouse/\n8、使用注解开发  接口  1 2 3 4  public interface UserMapper { @Select(\u0026#34;select * from user\u0026#34;) List\u0026lt;User\u0026gt; userList(); }   配置文件中绑定接口  1 2 3  \u0026lt;mappers\u0026gt; \u0026lt;mapper class=\u0026#34;com.wzc.mapper.UserMapper\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt;   Mybatis实现流程\n8.1、注解CRUD 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public interface UserMapper { @Select(\u0026#34;select * from user\u0026#34;) List\u0026lt;User\u0026gt; userList(); //方法存在多个参数时，所有参数前面必须加上@Param注解  @Select(\u0026#34;select id, name, pwd as password from user where id = #{id}\u0026#34;) User getUserById(@Param(\u0026#34;id\u0026#34;) int id); @Insert(\u0026#34;insert into user(id, name, pwd) values(#{id}, #{name}, #{password})\u0026#34;) int addUser(User user); @Update(\u0026#34;update user set name = #{name}, pwd = #{password} where id = #{id}\u0026#34;) int updateUser(User user); @Delete(\u0026#34;delete from user where id = #{id}\u0026#34;) int deleteUser(@Param(\u0026#34;id\u0026#34;) int id); }   【注意：必须将接口绑定到配置文件中】\n关于@Param注解\n 基本类型或String类型需要添加@Param注解，引用类型不需要添加  9、Lombok  安装插件 导入jar包  1 2 3 4 5 6  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.22\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt;   在实体类上加注解  10、多对一处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  CREATETABLE`teacher`(`id`INT(10)NOTNULL,`name`VARCHAR(30)DEFAULTNULL,PRIMARYKEY(`id`))ENGINE=INNODBDEFAULTCHARSET=utf8;INSERTINTO`teacher`(`id`,`name`)VALUES(1,\u0026#39;张老师\u0026#39;);CREATETABLE`student`(`id`INT(10)NOTNULL,`name`varchar(30)DEFAULTNULL,`tid`INT(10)DEFAULTNULL,PRIMARYKEY(`id`),KEY`fktid`(`tid`),CONSTRAINT`fktid`FOREIGNKEY(`tid`)REFERENCES`teacher`(`id`))ENGINE=INNODBDEFAULTCHARSET=utf8;INSERTINTO`student`(`id`,`name`,`tid`)VALUES(1,\u0026#39;小明\u0026#39;,1);INSERTINTO`student`(`id`,`name`,`tid`)VALUES(2,\u0026#39;小李\u0026#39;,1);INSERTINTO`student`(`id`,`name`,`tid`)VALUES(3,\u0026#39;小赵\u0026#39;,1);INSERTINTO`student`(`id`,`name`,`tid`)VALUES(4,\u0026#39;小王\u0026#39;,1);  10.1、按照查询嵌套处理（子查询） 1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026lt;mapper namespace=\u0026#34;com.wzc.mapper.StudentMapper\u0026#34;\u0026gt; \u0026lt;resultMap id=\u0026#34;studentTeacher\u0026#34; type=\u0026#34;Student\u0026#34;\u0026gt; \u0026lt;result property=\u0026#34;id\u0026#34; column=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;name\u0026#34; column=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;!--对象：association，集合：collection--\u0026gt; \u0026lt;association property=\u0026#34;teacher\u0026#34; column=\u0026#34;tid\u0026#34; javaType=\u0026#34;Teacher\u0026#34; select=\u0026#34;selectTeacher\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;studentList\u0026#34; resultMap=\u0026#34;studentTeacher\u0026#34;\u0026gt; select * from student \u0026lt;/select\u0026gt; \u0026lt;select id=\u0026#34;selectTeacher\u0026#34; resultType=\u0026#34;Teacher\u0026#34;\u0026gt; select * from teacher where id = #{tid} \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt;   10.2、按照结果嵌套处理（联表查询） 1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;mapper\u0026gt; \u0026lt;resultMap id=\u0026#34;studentTeacher\u0026#34; type=\u0026#34;Student\u0026#34;\u0026gt; \u0026lt;result property=\u0026#34;id\u0026#34; column=\u0026#34;sid\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;name\u0026#34; column=\u0026#34;sname\u0026#34;/\u0026gt; \u0026lt;association property=\u0026#34;teacher\u0026#34; javaType=\u0026#34;Teacher\u0026#34;\u0026gt; \u0026lt;result property=\u0026#34;id\u0026#34; column=\u0026#34;tid\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;name\u0026#34; column=\u0026#34;tname\u0026#34;/\u0026gt; \u0026lt;/association\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;studentList\u0026#34; resultMap=\u0026#34;studentTeacher\u0026#34;\u0026gt; select s.id sid, s.name sname, t.id tid, t.name tname from student s left join teacher t on t.id = s.tid \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt;   11、一对多处理 一个老师教多个学生\n11.1、按结果嵌套（联表查询） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;mapper namespace=\u0026#34;com.wzc.mapper.TeacherMapper\u0026#34;\u0026gt; \u0026lt;!--按结果嵌套--\u0026gt; \u0026lt;resultMap id=\u0026#34;teacherStudent\u0026#34; type=\u0026#34;Teacher\u0026#34;\u0026gt; \u0026lt;result property=\u0026#34;id\u0026#34; column=\u0026#34;tid\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;name\u0026#34; column=\u0026#34;tname\u0026#34;/\u0026gt; \u0026lt;collection property=\u0026#34;students\u0026#34; ofType=\u0026#34;Student\u0026#34;\u0026gt; \u0026lt;result property=\u0026#34;id\u0026#34; column=\u0026#34;sid\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;name\u0026#34; column=\u0026#34;sname\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;tid\u0026#34; column=\u0026#34;stid\u0026#34;/\u0026gt; \u0026lt;/collection\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;getTeacher\u0026#34; resultMap=\u0026#34;teacherStudent\u0026#34;\u0026gt; select t.id tid, t.name tname, s.id sid, s.name sname, s.tid stid from teacher t left join student s on t.id = s.tid where t.id = #{id} \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt;   11.2、按查询嵌套 1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;mapper\u0026gt; \u0026lt;resultMap id=\u0026#34;teacherStudent\u0026#34; type=\u0026#34;Teacher\u0026#34;\u0026gt; \u0026lt;result property=\u0026#34;id\u0026#34; column=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;name\u0026#34; column=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;collection property=\u0026#34;students\u0026#34; column=\u0026#34;id\u0026#34; javaType=\u0026#34;ArrayList\u0026#34; ofType=\u0026#34;Student\u0026#34; select=\u0026#34;studentList\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;getTeacher\u0026#34; resultMap=\u0026#34;teacherStudent\u0026#34;\u0026gt; select * from teacher where id = #{id} \u0026lt;/select\u0026gt; \u0026lt;select id=\u0026#34;studentList\u0026#34; resultType=\u0026#34;Student\u0026#34;\u0026gt; select * from student where tid = #{id} \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt;   11.3、小结  关联-association【多对一】 集合-collection【一对多】 javaType：用来指定实体类中属性的类型 ofType：用来指定泛型的类型 注意点：  保证sql的可读性 多对一和一对多中，属性名和字段的问题    12、动态SQL 动态SQL就是根据不同的条件生成不同的SQL语句\n1 2 3 4 5 6 7  CREATETABLE`blog`(`id`bigintNOTNULLCOMMENT\u0026#39;博客id\u0026#39;,`title`varchar(100)NOTNULLCOMMENT\u0026#39;博客标题\u0026#39;,`author`varchar(30)NOTNULLCOMMENT\u0026#39;博客作者\u0026#39;,`create_time`datetimeNOTNULLCOMMENT\u0026#39;创建时间\u0026#39;,`views`intNOTNULLCOMMENT\u0026#39;浏览量\u0026#39;)ENGINE=InnoDBDEFAULTCHARSET=utf8;  实体类\n1 2 3 4 5 6 7 8  @Data public class Blog { private int id; private String title; private String author; private Date createTime; private int views; }   12.1、IF标签 1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;select id=\u0026#34;blogListByIf\u0026#34; parameterType=\u0026#34;Map\u0026#34; resultType=\u0026#34;Blog\u0026#34;\u0026gt; select * from blog \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;title != null\u0026#34;\u0026gt; and title like concat(\u0026#34;%\u0026#34;, #{title}, \u0026#34;%\u0026#34;) \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;author != null\u0026#34;\u0026gt; /*从第二个if开始必须要加and*/ and author like concat(\u0026#34;%\u0026#34;, #{author}, \u0026#34;%\u0026#34;) \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt;   12.2、choose（when, otherwise） 类似switch-case\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;select id=\u0026#34;blogListByChoose\u0026#34; parameterType=\u0026#34;Map\u0026#34; resultType=\u0026#34;Blog\u0026#34;\u0026gt; select * from blog \u0026lt;where\u0026gt; \u0026lt;choose\u0026gt; \u0026lt;when test=\u0026#34;title != null\u0026#34;\u0026gt; /*当一个choose前还有choose标签的时候第一个条件也要加and*/ and title like concat(\u0026#34;%\u0026#34;, #{title}, \u0026#34;%\u0026#34;) \u0026lt;/when\u0026gt; \u0026lt;when test=\u0026#34;author != null\u0026#34;\u0026gt; and author like concat(\u0026#34;%\u0026#34;, #{author}, \u0026#34;%\u0026#34;) \u0026lt;/when\u0026gt; \u0026lt;otherwise\u0026gt; /*前面都不执行时会执行otherwise*/ and views \u0026gt;= 1000 \u0026lt;/otherwise\u0026gt; \u0026lt;/choose\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt;   12.3、trim（where, set） 1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;update id=\u0026#34;updateBlog\u0026#34; parameterType=\u0026#34;Blog\u0026#34;\u0026gt; update blog \u0026lt;set\u0026gt; \u0026lt;if test=\u0026#34;title != null\u0026#34;\u0026gt; title = #{title}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;author != null\u0026#34;\u0026gt; author = #{author}, \u0026lt;/if\u0026gt; \u0026lt;/set\u0026gt; where id = #{id} \u0026lt;/update\u0026gt;   SQL片段\n 使用sql标签抽取公共的sql  1 2 3 4 5 6 7 8 9  \u0026lt;sql id=\u0026#34;ifSql\u0026#34;\u0026gt; \u0026lt;if test=\u0026#34;title != null\u0026#34;\u0026gt; and title like concat(\u0026#34;%\u0026#34;, #{title}, \u0026#34;%\u0026#34;) \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;author != null\u0026#34;\u0026gt; /*从第二个if开始必须要加and*/ and author like concat(\u0026#34;%\u0026#34;, #{author}, \u0026#34;%\u0026#34;) \u0026lt;/if\u0026gt; \u0026lt;/sql\u0026gt;   在需要的地方使用include引用  1 2 3 4 5 6  \u0026lt;select id=\u0026#34;blogListByIf\u0026#34; parameterType=\u0026#34;Map\u0026#34; resultType=\u0026#34;Blog\u0026#34;\u0026gt; select * from blog \u0026lt;where\u0026gt; \u0026lt;include refid=\u0026#34;ifSql\u0026#34;\u0026gt;\u0026lt;/include\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt;   注意点：\n 最好基于单表定义sql片段 不要存在where标签  12.4、foreach collection：要遍历集合的参数名 item：遍历项 open：起始追加 close：结尾追加 separate：分隔符\n1 2 3 4 5 6  \u0026lt;select id=\u0026#34;blogListByForeach\u0026#34; parameterType=\u0026#34;List\u0026#34; resultType=\u0026#34;Blog\u0026#34;\u0026gt; select * from blog where \u0026lt;foreach collection=\u0026#34;ids\u0026#34; item=\u0026#34;id\u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34; separator=\u0026#34;or\u0026#34;\u0026gt; id = #{id} \u0026lt;/foreach\u0026gt; \u0026lt;/select\u0026gt;   13、Mybatis缓存  Mybatis系统中定义了两级缓存：一级和二级缓存 默认情况下，只有一级缓存开启（sqlSession级别的缓存，也称为本地缓存） 二级缓存需要配置开启，也可以通过实现Cache接口实现（namespace级别的缓存，也称为全局缓存）  13.1、一级缓存 1 2 3 4 5 6 7 8 9 10 11 12 13 14  public class UserMapperTest { @Test public void test1() { try (SqlSession sqlSession = MybatisUtil.getSqlSession()) { /*一级缓存：sqlSession级别，第二次查询时从缓存中取结果，两次查询的结果相同*/ UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user1 = mapper.getUserById(1); User user2 = mapper.getUserById(1); System.out.println(user1); System.out.println(user2); System.out.println(user1 == user2); } } }   缓存失效情况：\n 增删改操作，可能会改变数据，所以会刷新缓存 查询不同的sql 查询不同的mapper 手动清除缓存（sqlSession.clearCache()）  小结：一级缓存是默认开启的，只在一次sqlSession中有效\n13.2、二级缓存 二级缓存工作机制：\n 当一次会话关闭后，一级缓存中的数据会被保存到二级缓存中，新会话从二级缓存中获取数据 不同的mapper对应不同的二级缓存  使用步骤：\n 开启二级缓存（默认就是开启的）  1 2  \u0026lt;!--开启二级缓存--\u0026gt; \u0026lt;setting name=\u0026#34;cacheEnabled\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt;   mapper.xml中添加cache标签  1 2  \u0026lt;!--在当前mapper中使用二级缓存，FIFO策略，每60秒刷新缓存，缓存空间大小512，只读--\u0026gt; \u0026lt;cache eviction=\u0026#34;FIFO\u0026#34; flushInterval=\u0026#34;60000\u0026#34; size=\u0026#34;512\u0026#34; readOnly=\u0026#34;true\u0026#34;/\u0026gt;   测试  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public class UserMapperTest { @Test public void test2() { try (SqlSession sqlSession1 = MybatisUtil.getSqlSession(); SqlSession sqlSession2 = MybatisUtil.getSqlSession()) { UserMapper mapper1 = sqlSession1.getMapper(UserMapper.class); UserMapper mapper2 = sqlSession2.getMapper(UserMapper.class); User user1 = mapper1.getUserById(1); System.out.println(user1); sqlSession1.close(); /*一级缓存关闭后，其中的数据会保存到二级缓存，再次查询从二级缓存中获取数据*/ User user2 = mapper2.getUserById(1); System.out.println(user2); System.out.println(user1 == user2); } } }   注意： 实体类需要实现Serializable接口序列化，否则会报NotSerializableException\n13.3、缓存原理  先看二级缓存中有没有 再看一级缓存中有没有 查询数据库   13.6、自定义缓存ehcache Ehcache是一种广泛使用的开源java分布式缓存，主要面向通用缓存\n 导包  1 2 3 4 5  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.caches\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-ehcache\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   配置文件指定使用ehcache  1  \u0026lt;cache type=\u0026#34;org.mybatis.caches.ehcache.EhcacheCache\u0026#34;/\u0026gt;   编写ehcache的配置文件  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;ehcache xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:noNamespaceSchemaLocation=\u0026#34;http://ehcache.org/ehcache.xsd\u0026#34; updateCheck=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;diskStore path=\u0026#34;./tmpdir/Tmp_EhCache\u0026#34;/\u0026gt; \u0026lt;defaultCache eternal=\u0026#34;false\u0026#34; maxElementsInMemory=\u0026#34;10000\u0026#34; overflowToDisk=\u0026#34;false\u0026#34; diskPersistent=\u0026#34;false\u0026#34; timeToIdleSeconds=\u0026#34;1800\u0026#34; timeToLiveSeconds=\u0026#34;259200\u0026#34; memoryStoreEvictionPolicy=\u0026#34;LRU\u0026#34;/\u0026gt; \u0026lt;cache name=\u0026#34;cloud_user\u0026#34; eternal=\u0026#34;false\u0026#34; maxElementsInMemory=\u0026#34;5000\u0026#34; overflowToDisk=\u0026#34;false\u0026#34; diskPersistent=\u0026#34;false\u0026#34; timeToIdleSeconds=\u0026#34;1800\u0026#34; timeToLiveSeconds=\u0026#34;1800\u0026#34; memoryStoreEvictionPolicy=\u0026#34;LRU\u0026#34;/\u0026gt; \u0026lt;/ehcache\u0026gt;   ","date":"2022-03-07T18:24:52+08:00","image":"https://WangZichen99.github.io/img/2022/03/lake.jpg","permalink":"https://WangZichen99.github.io/p/mybatisnote/","title":"Mybatis笔记"},{"content":"Spring学习笔记 1、介绍 1.1、导包 导入spring-webmvc和spring-jdbc\n1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;project\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.0.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.0.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/project\u0026gt;   1.2、优点   开源免费\n  轻量级、非入侵式\n  控制反转（IOC）、面向切面编程（AOP）\n  支持事务处理，对框架整合的支持\n  总结：Spring就是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架\n1.3、组成 1.4、拓展 在Spring官网有这个介绍：现代化的java开发，就是基于Spring的开发\nSpring Boot：Build Anything\nSpring Cloud：Coordinate Anything\nSpring Cloud Data Flow：Connect Everything\n  Spring Boot\n 一个快速开发的脚手架 基于Spring Boot可以快速的开发单个微服务 约定大于配置    Spring Cloud\n Spring Cloud是基于Spring Boot实现的    弊端：发展了太久之后就违背了原来的理念，配置十分繁琐\n2、IOC理论推导   UserDao接口\n  UserDaoImpl实现类\n  UserService业务接口\n  UserServiceImpl业务实现类\n  在之前的业务中，用户的需求可能会影响原来的代码，需要根据需求修改源代码，如果代码量十分大，修改一次的成本十分昂贵\n使用一个Set接口实现，已经发生了革命性的变化\n1 2 3 4 5 6  private UserDao userDao; //利用set进行动态实现值的注入 public void setUserDao(UserDao userDao) { this.userDao = userDao; }    之前，程序是主动创建对象，控制权在程序员手上 使用了set注入后，程序不再具有主动性，而是变成了被动的接收对象  这种思想，从本质上解决了问题，程序员不再管理对象的创建，系统的耦合性大大降低，可以更加专注于业务的实现，这是IOC的原型\nIoC本质 控制反转IoC（Inversion of Control），是一种设计思想，DI（依赖注入）是实现IoC的一种方法。\n没有IoC的程序中，我们使用面向对象编程，对象的创建与对象间的依赖关系完全硬编程在程序中，对象的创建由程序自己控制 控制反转后将对象的创建转移给第三方，获得依赖对象的方式反转了。\n控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器， 其实现方法是依赖注入（Dependency Injection，DI）\n3、Hello Spring  控制：谁来控制对象的创建，传统应用程序的对象是由程序本身控制创建的，使用Spring后，对象是由Spring创建的 反转：程序本身不创建对象，而变成被动的接收对象 依赖注入：就是利用set方法来进行注入的 IoC是一种编程思想，由主动的编程变成被动的接收  4、IoC创建对象的方式  使用无参构造创建对象（默认） 如果要使用有参构造创建对象  下标赋值  1 2 3  \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.wzc.pojo.User\u0026#34;\u0026gt; \u0026lt;constructor-arg index=\u0026#34;0\u0026#34; value=\u0026#34;wzc\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   类型（不建议使用）  1 2 3  \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.wzc.pojo.User\u0026#34;\u0026gt; \u0026lt;constructor-arg type=\u0026#34;java.lang.String\u0026#34; value=\u0026#34;wzc\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   参数名  1 2 3  \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.wzc.pojo.User\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;name\u0026#34; value=\u0026#34;wzc\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;     总结：在配置文件加载的时候，容器中管理的对象已经初始化了\n5、Spring配置 5.1、别名 1 2  \u0026lt;!--别名，可以通过别名获取对象--\u0026gt; \u0026lt;alias name=\u0026#34;user\u0026#34; alias=\u0026#34;userNew\u0026#34;/\u0026gt;   5.2、Bean的配置 1 2 3 4  \u0026lt;!--有参构造对象，name也可以取别名，可以取多个--\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.wzc.pojo.User\u0026#34; name=\u0026#34;user2, u2\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;name\u0026#34; value=\u0026#34;wzc\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   5.3、Import import一般用于团队开发，可以将多个配置文件，导入合并为一个\n如果项目中有多人开发，三个人使用不同的类开发，不同的类需要注册在不同的bean中， 可以利用import将所有人的beans.xml合并为一个总的，使用的时候，直接使用总的配置就可以\n6、依赖注入 6.1、构造器注入 前面已经说过\n6.2、Set方法注入【重点】  依赖注入：Set方法注入  依赖：bean对象的创建依赖于容器 注入：bean对象中的所有属性，由容器来注入 name属性值与类中的成员变量名以及set方法的参数名都无关, 只与对应的set方法名有关 如果通过set方法注入属性，那么Spring会通过默认的空参构造方法来实例化对象， 所以如果在类中写了一个带有参数的构造方法，一定要把空参数的构造方法写上， 否则spring没有办法实例化对象，导致报错。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  \u0026lt;bean id=\u0026#34;address\u0026#34; class=\u0026#34;com.wzc.pojo.Address\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;address\u0026#34; value=\u0026#34;北京\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;student\u0026#34; class=\u0026#34;com.wzc.pojo.Student\u0026#34;\u0026gt; \u0026lt;!--普通值注入: Spring会将name值的每个单词首字母转换成大写, 然后再在前面拼接上\u0026#34;set\u0026#34;构成一个方法名, 然后去对应的类中查找该方法,通过反射调用,实现注入--\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;wzc\u0026#34;/\u0026gt; \u0026lt;!--Bean注入--\u0026gt; \u0026lt;property name=\u0026#34;address\u0026#34; ref=\u0026#34;address\u0026#34;/\u0026gt; \u0026lt;!--数组注入--\u0026gt; \u0026lt;property name=\u0026#34;books\u0026#34;\u0026gt; \u0026lt;array\u0026gt; \u0026lt;value\u0026gt;活着\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;平凡的世界\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;你当像鸟飞往你的山\u0026lt;/value\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--List注入--\u0026gt; \u0026lt;property name=\u0026#34;hobbies\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;看书\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;打篮球\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;听音乐\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--Map注入--\u0026gt; \u0026lt;property name=\u0026#34;cards\u0026#34;\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry key=\u0026#34;身份证\u0026#34; value=\u0026#34;110154158754582057\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;银行卡\u0026#34; value=\u0026#34;1111 2222 3333 4444\u0026#34;/\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--Set注入--\u0026gt; \u0026lt;property name=\u0026#34;games\u0026#34;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;value\u0026gt;穿越火线\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;NBA2KOL2\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;QQ飞车\u0026lt;/value\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--null值注入--\u0026gt; \u0026lt;property name=\u0026#34;wife\u0026#34;\u0026gt; \u0026lt;null/\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--Properties注入--\u0026gt; \u0026lt;property name=\u0026#34;info\u0026#34;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;prop key=\u0026#34;学号\u0026#34;\u0026gt;1725840658\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;性别\u0026#34;\u0026gt;男\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;邮箱\u0026#34;\u0026gt;194829422@qq.com\u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;     6.3、拓展方式注入 使用p命名和c命名空间注入\n 导入xml约束  1 2  xmlns:p=\u0026#34;http://www.springframework.org/schema/p\u0026#34; xmlns:c=\u0026#34;http://www.springframework.org/schema/c\u0026#34;   注入  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:p=\u0026#34;http://www.springframework.org/schema/p\u0026#34; xmlns:c=\u0026#34;http://www.springframework.org/schema/c\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!--p命名空间注入（无参构造，set方法注入），可以直接注入属性的值--\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.wzc.pojo.User\u0026#34; p:name=\u0026#34;wzc\u0026#34; p:age=\u0026#34;22\u0026#34;/\u0026gt; \u0026lt;!--c命名空间注入（有参构造）--\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.wzc.pojo.User\u0026#34; c:name=\u0026#34;wzc\u0026#34; c:age=\u0026#34;22\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt;   测试  1 2 3 4 5 6 7  public class UserTest { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;userbeans.xml\u0026#34;); User user = context.getBean(\u0026#34;user\u0026#34;, User.class); System.out.println(user.toString()); } }   6.4、Bean的作用域  单例模式（Spring默认机制）  1  \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.wzc.pojo.User\u0026#34; c:name=\u0026#34;wzc\u0026#34; c:age=\u0026#34;22\u0026#34; scope=\u0026#34;singleton\u0026#34;/\u0026gt;   原型模式：每次从容器中get的时候都会产生一个新对象  1  \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.wzc.pojo.User\u0026#34; c:name=\u0026#34;wzc\u0026#34; c:age=\u0026#34;22\u0026#34; scope=\u0026#34;prototype\u0026#34;/\u0026gt;   其余的request、session、application这些只能在web开发中使用到  7、Bean的自动装配  自动装配是Spring满足bean依赖的一种方式 Spring会在上下文中自动寻找，并装配属性  在Spring中有三种装配方式\n 在xml中显示装配 在java中显示装配 隐式的自动装配【重要】  7.1、byName自动装配 1 2 3 4 5 6 7  \u0026lt;bean id=\u0026#34;dog\u0026#34; class=\u0026#34;com.wzc.pojo.Dog\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;cat\u0026#34; class=\u0026#34;com.wzc.pojo.Cat\u0026#34;/\u0026gt; \u0026lt;!--byName会自动在容器上下文中查找bean的id前加上\u0026#34;set\u0026#34;和对应属性的set方法名称相同的bean进行自动注入--\u0026gt; \u0026lt;bean id=\u0026#34;person\u0026#34; class=\u0026#34;com.wzc.pojo.Person\u0026#34; autowire=\u0026#34;byName\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;wzc\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   7.2、byType自动装配 1 2 3 4 5 6 7  \u0026lt;bean id=\u0026#34;dog\u0026#34; class=\u0026#34;com.wzc.pojo.Dog\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;cat\u0026#34; class=\u0026#34;com.wzc.pojo.Cat\u0026#34;/\u0026gt; \u0026lt;!--byType会自动在容器上下文中查找bean的类型和该对象属性类型相同的bean进行自动注入（必须保证全局唯一）--\u0026gt; \u0026lt;bean id=\u0026#34;person\u0026#34; class=\u0026#34;com.wzc.pojo.Person\u0026#34; autowire=\u0026#34;byType\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;wzc\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   7.3、constructor自动装配 1 2 3 4 5 6 7 8  \u0026lt;bean id=\u0026#34;dog\u0026#34; class=\u0026#34;com.wzc.pojo.Dog\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;cat\u0026#34; class=\u0026#34;com.wzc.pojo.Cat\u0026#34;/\u0026gt; \u0026lt;!--通过构造方法进行自动注入，Spring会匹配与构造方法参数类型一致的bean进行注入， 如果构造方法参数没有完全匹配则注入失败--\u0026gt; \u0026lt;bean id=\u0026#34;person\u0026#34; class=\u0026#34;com.wzc.pojo.Person\u0026#34; autowire=\u0026#34;constructor\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;wzc\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   小结：\n byName的时候，需要保证所有bean的id唯一 byType的时候，需要保证所有bean的class唯一  7.4、使用注解实现自动装配 要使用注解须知：\n 导入约束：context约束 配置注解的支持  1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;context:annotation-config/\u0026gt; \u0026lt;/beans\u0026gt;   @Autowired注解\n直接在属性上使用即可，也可以在set方法上使用\n科普：\n1 2 3 4  @Nullable 字段标记这个注解后，说明这个字段可以为null //如果定义了@Autowired的require属性为false，说明这个对象可以为空 @Autowired(require = false)   @Autowired默认使用byType方式注入，如果beans.xml中有多个type符合的bean， 则使用@Qualifier(value = \u0026ldquo;name\u0026rdquo;)注入id为name的bean\n1 2 3  @Autowired @Qualifier(value = \u0026#34;dog\u0026#34;) private Dog dog1;   @Resource注解\n1 2  @Resource(name = \u0026#34;cat1\u0026#34;) private Cat cat;   小结： @Autowired和@Resource的区别：\n @Autowired默认按照byType方式装配 @Resource默认按照byName方式装配  8、使用注解开发 在Spring4之后，要使用注解开发，必须保证aop的包导入了\n使用注解需要导入context约束，增加注解的支持\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.wzc\u0026#34;/\u0026gt; \u0026lt;context:annotation-config/\u0026gt; \u0026lt;/beans\u0026gt;     bean\n@Component：表示组件，放在类上表示这个类被Spring管理\n  属性如何注入\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  @Component //等价于\u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.wzc.pojo.User\u0026#34;/\u0026gt; public class User { @Value(\u0026#34;wzc\u0026#34;) //等价于\u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;wzc\u0026#34;/\u0026gt;  private String name; public String getName() { return name; } @Value(\u0026#34;wzc\u0026#34;) //等价于\u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;wzc\u0026#34;/\u0026gt;  public void setName(String name) { this.name = name; } }    衍生的注解\n@Component有几个衍生注解，我们在web开发中，会按照mvc三层架构分层\n dao：@Repository service：@Service controller：@Controller  这四个注解功能相同，代表将某个类注册到Spring容器中，装配bean\n  自动装配\n@Autowired\n@Resource\n  作用域\n@Scope(value = \u0026ldquo;prototype\u0026rdquo;)\n  小结\nxml与注解：\n xml更万能，适用于任何场合，维护简单方便 注解只能对当前类生效，维护相对复杂 xml一般用来管理bean，注解只负责属性的注入    9、使用java的方式配置Spring 所有配置由注解完成\n两种方法注入bean：\n @Component建立的对象通过getBean(\u0026ldquo;user\u0026rdquo;)获取 配置类中定义一个方法，使用@Bean注解声明，通过getBean(\u0026ldquo;getUser\u0026rdquo;)获取  实体类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  @Component() //第一种方法直接使用Component注解注入bean，通过getBean(\u0026#34;user\u0026#34;)来得到bean public class User { @Value(\u0026#34;wzc\u0026#34;) private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } }   配置类\n1 2 3 4 5 6 7 8 9  @Configuration //@Configuration代表这是一个配置类(第二种方法) @ComponentScan(\u0026#34;com.wzc.pojo\u0026#34;) //自动扫描com.wzc.pojo下的bean进行注入，这里注入的是user(与第一种方法配合使用) public class UserConfig { @Bean //注册一个Bean，相当于一个bean标签，这个方法的名字就是bean标签中的id，方法的返回值就是bean标签中的class，这里注入的是getUser  public User getUser() { return new User(); } }   测试类\n1 2 3 4 5 6 7 8 9 10 11 12 13  public class UserTest { @Test public void test1() { //如果使用配置类注入，使用AnnotationConfigApplicationContext来获取容器  ApplicationContext context = new AnnotationConfigApplicationContext(UserConfig.class); User user1 = context.getBean(\u0026#34;getUser\u0026#34;, User.class); User user2 = context.getBean(\u0026#34;user\u0026#34;, User.class); user1.setName(\u0026#34;test\u0026#34;); System.out.println(user1); System.out.println(user2); System.out.println(user1 == user2); //user1和user2不是同一个对象  } }   这种纯java的配置方式在SpringBoot中随处可见\n10、代理模式 代理模式是SpringAOP的底层实现\n代理模式的分类：\n 静态代理 动态代理  10.1、静态代理 角色分析：\n 抽象角色：一般会使用接口或者抽象类来解决 (租房) 真实角色：被代理的角色 (房东) 代理角色：代理真实角色，代理真实角色后，会做一些附属操作 (中介) 客户：访问代理对象 (客户)  代理模式的好处：\n 可以使真实角色的操作更加纯粹，不用关注一些公共的业务 公共业务交给代理角色，实现了业务的分工 公共业务发生扩展的时候，方便集中管理  缺点：\n 一个真实角色就会产生一个代理角色，代码量会翻倍  接口 (租房)\n1 2 3 4 5 6  //租房 public interface Rent { public void rent(); }   真实角色 (房东)\n1 2 3 4 5 6 7  public class Host implements Rent { @Override public void rent() { System.out.println(\u0026#34;房东要出租房子\u0026#34;); } }   代理角色 (中介)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  public class Proxy implements Rent { //要代理的角色  private Host host; public Proxy() { } public Proxy(Host host) { this.host = host; } @Override public void rent() { lookHouse(); host.rent(); signContract(); fee(); } /** * 看房(附属操作) */ public void lookHouse() { System.out.println(\u0026#34;中介带领看房\u0026#34;); } /** * 签合同(附属操作) */ public void signContract() { System.out.println(\u0026#34;签租赁合同\u0026#34;); } /** * 收中介费(附属操作) */ public void fee() { System.out.println(\u0026#34;收中介费\u0026#34;); } }   客户端访问代理角色\n1 2 3 4 5 6 7 8 9 10  public class Client { public static void main(String[] args) { //房东要租房子  Host host = new Host(); //代理中介帮房东租房子，代理会有一些附属操作  Proxy proxy = new Proxy(host); //找中介租房子  proxy.rent(); } }   10.2、静态代理加深理解 接口\n1 2 3 4 5 6 7 8 9  public interface UserService { public void insert(); public void delete(); public void update(); public void select(); }   真实角色\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public class UserServiceImpl implements UserService { @Override public void insert() { System.out.println(\u0026#34;增加用户\u0026#34;); } @Override public void delete() { System.out.println(\u0026#34;删除用户\u0026#34;); } @Override public void update() { System.out.println(\u0026#34;修改用户\u0026#34;); } @Override public void select() { System.out.println(\u0026#34;查询用户\u0026#34;); } }   代理角色\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  public class UserServiceProxy implements UserService { private UserServiceImpl userService; public void setUserService(UserServiceImpl userService) { this.userService = userService; } @Override public void insert() { log(\u0026#34;insert\u0026#34;); userService.insert(); } @Override public void delete() { log(\u0026#34;delete\u0026#34;); userService.delete(); } @Override public void update() { log(\u0026#34;update\u0026#34;); userService.update(); } @Override public void select() { log(\u0026#34;select\u0026#34;); userService.select(); } //日志输出(附属方法)  public void log(String msg) { System.out.println(\u0026#34;使用了\u0026#34; + msg + \u0026#34;方法\u0026#34;); } }   客户端\n1 2 3 4 5 6 7 8 9 10 11 12  public class Client { public static void main(String[] args) { //真实角色  UserServiceImpl userService = new UserServiceImpl(); //代理角色(添加日至输出)  UserServiceProxy userServiceProxy = new UserServiceProxy(); userServiceProxy.setUserService(userService); userServiceProxy.insert(); } }   10.3、动态代理  动态代理和静态代理角色一样 动态代理的代理类是自动生成的(通过反射)，不是直接写好的 动态代理分为两大类：基于接口的动态代理，基于类的动态代理  基于接口\u0026mdash;JDK动态代理 √ 基于类\u0026mdash;cglib java字节码实现\u0026mdash;javasist    需要了解两个类：Proxy：代理，InvocationHandler：调用处理程序\n接口\n1 2 3 4 5 6 7 8 9  public interface UserService { public void insert(); public void delete(); public void update(); public void select(); }   真实角色\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public class UserServiceImpl implements UserService { @Override public void insert() { System.out.println(\u0026#34;增加用户\u0026#34;); } @Override public void delete() { System.out.println(\u0026#34;删除用户\u0026#34;); } @Override public void update() { System.out.println(\u0026#34;修改用户\u0026#34;); } @Override public void select() { System.out.println(\u0026#34;查询用户\u0026#34;); } }   InvocationHandler动态代理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  public class ProxyInvocationHandler implements InvocationHandler { private Object target; //要代理的角色  public void setTarget(Object target) { this.target = target; } /** * 生成代理类 */ public Object getProxy() { return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(), this); } /** * 返回代理实例 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { log(method.getName()); Object result = method.invoke(target, args); return result; } /** * 附属方法：写日志 */ public void log(String msg) { System.out.println(\u0026#34;执行了\u0026#34; + msg + \u0026#34;方法\u0026#34;); } }   客户端\n1 2 3 4 5 6 7 8 9 10 11 12 13  public class Client { public static void main(String[] args) { //真实角色  UserServiceImpl userService = new UserServiceImpl(); //代理角色  ProxyInvocationHandler handler = new ProxyInvocationHandler(); //设置要代理的对象  handler.setTarget(userService); //动态生成代理类  UserService proxy = (UserService) handler.getProxy(); proxy.insert(); } }   动态代理的好处：\n 可以使真实角色的操作更加纯粹，不用关注一些公共业务 公共业务交给代理角色，实现了业务的分工 公共业务发生扩展的时候方便集中管理 一个动态代理类代理的是一个接口，一般就是对应的一类业务 一个动态代理可以代理多个类，只要是实现了同一个接口即可  11、AOP 11.1、什么是AOP AOP（Aspect Oriented Programming）意为：面向切面编程， 通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。 AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容， 是函数式编程的一种衍生范型。利用AOP业务逻辑的各个部分进行隔离， 从而使得各部分逻辑之间的耦合度降低，提高程序的可重用性，同时提高了开发效率\n11.2、AOP在Spring中的作用 提供声明事务，允许用户自定义切面\n理解： 切面：包含要切入的具体方法的类\n通知：切面中的某个具体方法\n切入点：具体在哪个类哪个方法进行切入\n11.3、使用Spring实现AOP 导包\n1 2 3 4 5 6 7  \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;   方式一：使用Spring的接口 前置通知和后置通知\n1 2 3 4 5 6 7 8 9 10 11 12 13  public class BeforeLog implements MethodBeforeAdvice { /** * 方法执行前操作 * @param method 要执行的目标对象的方法 * @param objects 方法参数 * @param o 目标对象 * @throws Throwable */ @Override public void before(Method method, Object[] objects, Object o) throws Throwable { System.out.println(o.getClass().getName() + \u0026#34;的\u0026#34; + method.getName() + \u0026#34;被执行\u0026#34;); } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14  public class AfterLog implements AfterReturningAdvice { /** * 方法执行后操作 * @param o 返回值 * @param method 要执行的目标对象方法 * @param objects 方法参数 * @param o1 目标对象 * @throws Throwable */ @Override public void afterReturning(Object o, Method method, Object[] objects, Object o1) throws Throwable { System.out.println(\u0026#34;执行了\u0026#34; + method.getName() + \u0026#34;方法，返回结果为\u0026#34; + o); } }   配置文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;com.wzc.service.UserServiceImpl\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;beforeLog\u0026#34; class=\u0026#34;com.wzc.log.BeforeLog\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;afterLog\u0026#34; class=\u0026#34;com.wzc.log.AfterLog\u0026#34;/\u0026gt; \u0026lt;!--方式一：使用原生接口配置AOP--\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;!--切入点：expression：表达式，execution(要执行的位置 包名.类名.方法名)--\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;pointcut\u0026#34; expression=\u0026#34;execution(* com.wzc.service.UserServiceImpl.*(..))\u0026#34;/\u0026gt; \u0026lt;!--执行环绕增强--\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026#34;beforeLog\u0026#34; pointcut-ref=\u0026#34;pointcut\u0026#34;/\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026#34;afterLog\u0026#34; pointcut-ref=\u0026#34;pointcut\u0026#34;/\u0026gt; \u0026lt;/aop:config\u0026gt; \u0026lt;/beans\u0026gt;   方式二：自定义类来实现AOP 自定义类\n1 2 3 4 5 6 7 8 9  public class CustomPointCut { public void beforeMethod() { System.out.println(\u0026#34;方法执行前\u0026#34;); } public void afterMethod() { System.out.println(\u0026#34;方法执行后\u0026#34;); } }   配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;com.wzc.service.UserServiceImpl\u0026#34;/\u0026gt; \u0026lt;!--方式二：自定义类--\u0026gt; \u0026lt;bean id=\u0026#34;customPointCut\u0026#34; class=\u0026#34;com.wzc.custom.CustomPointCut\u0026#34;/\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;!--自定义切面--\u0026gt; \u0026lt;aop:aspect ref=\u0026#34;customPointCut\u0026#34;\u0026gt; \u0026lt;!--切入点--\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;pointcut\u0026#34; expression=\u0026#34;execution(* com.wzc.service.UserServiceImpl.*(..))\u0026#34;/\u0026gt; \u0026lt;!--通知--\u0026gt; \u0026lt;aop:before method=\u0026#34;beforeMethod\u0026#34; pointcut-ref=\u0026#34;pointcut\u0026#34;/\u0026gt; \u0026lt;aop:after-returning method=\u0026#34;afterMethod\u0026#34; pointcut-ref=\u0026#34;pointcut\u0026#34;/\u0026gt; \u0026lt;/aop:aspect\u0026gt; \u0026lt;/aop:config\u0026gt; \u0026lt;/beans\u0026gt;   方式三：使用注解实现AOP 切面类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  /** * 通过注解实现AOP */ @Aspect //标注这个类为一个切面 public class AnnotationPointCut { @Before(\u0026#34;execution(* com.wzc.service.UserServiceImpl.*(..))\u0026#34;) public void beforeMethod() { System.out.println(\u0026#34;方法执行前\u0026#34;); } @AfterReturning(\u0026#34;execution(* com.wzc.service.UserServiceImpl.*(..))\u0026#34;) public void afterMethod() { System.out.println(\u0026#34;方法执行后\u0026#34;); } /** * 环绕增强中，可以通过ProceedingJoinPoint来获取处理切入的点 */ @Around(\u0026#34;execution(* com.wzc.service.UserServiceImpl.*(..))\u0026#34;) public void aroundMethod(ProceedingJoinPoint joinPoint) throws Throwable { System.out.println(\u0026#34;环绕前\u0026#34;); System.out.println(\u0026#34;signature：\u0026#34; + joinPoint.getSignature()); //获得签名(方法名全称)  joinPoint.proceed(); //执行方法  System.out.println(\u0026#34;环绕后\u0026#34;); } }   配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;com.wzc.service.UserServiceImpl\u0026#34;/\u0026gt; \u0026lt;!--方式三：注解实现AOP--\u0026gt; \u0026lt;bean id=\u0026#34;annotationPointCut\u0026#34; class=\u0026#34;com.wzc.custom.AnnotationPointCut\u0026#34;/\u0026gt; \u0026lt;!--开启注解支持--\u0026gt; \u0026lt;aop:aspectj-autoproxy/\u0026gt; \u0026lt;/beans\u0026gt;   12、整合Mybatis 步骤：\n 导入相关jar包  junit mybatis mysql spring相关 aop织入 mybatis-spring【new】   编写配置文件 测试  12.1、回忆Mybatis  编写实体类  1 2 3 4 5 6  @Data public class User { private int id; private String name; private String pwd; }   编写核心配置文件  mybatis-config.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;typeAliases\u0026gt; \u0026lt;package name=\u0026#34;com.wzc.pojo\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;\u0026gt;\u0026lt;/transactionManager\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mybatis?useUnicode=true\u0026amp;amp;characterEncoding=utf8\u0026amp;amp;useSSL=true\u0026amp;amp;serverTimezone=Asia/Shanghai\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;123456\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper class=\u0026#34;com.wzc.mapper.UserMapper\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt;   pom.xml\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;build\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/java\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;true\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;/build\u0026gt;   编写接口  1 2 3  public interface UserMapper { List\u0026lt;User\u0026gt; selectUser(); }   编写Mapper.xml  1 2 3 4 5 6 7 8 9 10  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.wzc.mapper.UserMapper\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;selectUser\u0026#34; resultType=\u0026#34;com.wzc.pojo.User\u0026#34;\u0026gt; select * from mybatis.user; \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt;   测试  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public class UserTest { @Test public void test1() throws IOException { String resources = \u0026#34;mybatis-config.xml\u0026#34;; InputStream in = Resources.getResourceAsStream(resources); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(in); SqlSession sqlSession = sessionFactory.openSession(true); UserMapper mapper = sqlSession.getMapper(UserMapper.class); List\u0026lt;User\u0026gt; userList = mapper.selectUser(); for (User user : userList) { System.out.println(user); } } }   12.2、整合Mybatis  编写数据源配置  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!--DataSource:使用Spring的数据源替换Mybatis的配置 c30p dbcp druid--\u0026gt; \u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DriverManagerDataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;com.mysql.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mybatis?useUnicode=true\u0026amp;amp;characterEncoding=utf8\u0026amp;amp;useSSL=true\u0026amp;amp;serverTimezone=Asia/Shanghai\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;123456\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--sqlSessionFactory--\u0026gt; \u0026lt;bean id=\u0026#34;sqlSessionFactory\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34;/\u0026gt; \u0026lt;!--绑定Mybatis配置文件--\u0026gt; \u0026lt;property name=\u0026#34;configLocation\u0026#34; value=\u0026#34;classpath:mybatis-config.xml\u0026#34;/\u0026gt; \u0026lt;!--\u0026lt;property name=\u0026#34;typeAliases\u0026#34; value=\u0026#34;com.wzc.pojo.User\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;property name=\u0026#34;mapperLocations\u0026#34; value=\u0026#34;classpath:com/wzc/mapper/*.xml\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--sqlSession--\u0026gt; \u0026lt;bean id=\u0026#34;sqlSession\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionTemplate\u0026#34;\u0026gt; \u0026lt;!--只能用构造器注入，因为没有set方法--\u0026gt; \u0026lt;constructor-arg name=\u0026#34;sqlSessionFactory\u0026#34; ref=\u0026#34;sqlSessionFactory\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;   sqlSessionFactory  1 2 3 4 5 6 7 8  \u0026lt;!--sqlSessionFactory--\u0026gt; \u0026lt;bean id=\u0026#34;sqlSessionFactory\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34;/\u0026gt; \u0026lt;!--绑定Mybatis配置文件--\u0026gt; \u0026lt;property name=\u0026#34;configLocation\u0026#34; value=\u0026#34;classpath:mybatis-config.xml\u0026#34;/\u0026gt; \u0026lt;!--\u0026lt;property name=\u0026#34;typeAliases\u0026#34; value=\u0026#34;com.wzc.pojo.User\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;property name=\u0026#34;mapperLocations\u0026#34; value=\u0026#34;classpath:com/wzc/mapper/*.xml\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   sqlSessionTemplate  1 2 3 4 5  \u0026lt;!--sqlSession--\u0026gt; \u0026lt;bean id=\u0026#34;sqlSession\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionTemplate\u0026#34;\u0026gt; \u0026lt;!--只能用构造器注入，因为没有set方法--\u0026gt; \u0026lt;constructor-arg name=\u0026#34;sqlSessionFactory\u0026#34; ref=\u0026#34;sqlSessionFactory\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   实现类，注入Spring  1 2 3 4 5 6 7 8 9 10 11 12 13 14  public class UserMapperImpl implements UserMapper { //原来所有操作都使用sqlSession来执行，现在使用sqlSessionTemplate  private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) { this.sqlSession = sqlSession; } @Override public List\u0026lt;User\u0026gt; selectUser() { return sqlSession.getMapper(UserMapper.class).selectUser(); } }   1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;import resource=\u0026#34;spring-dao.xml\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;userMapper\u0026#34; class=\u0026#34;com.wzc.mapper.UserMapperImpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;sqlSession\u0026#34; ref=\u0026#34;sqlSession\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;   测试  1 2 3 4 5 6 7 8 9 10 11  public class UserTest { @Test public void test2() throws IOException { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); UserMapperImpl userMapper = context.getBean(\u0026#34;userMapper\u0026#34;, UserMapperImpl.class); List\u0026lt;User\u0026gt; userList = userMapper.selectUser(); for (User user : userList) { System.out.println(user); } } }   13、声明式事务 13.1、回顾事务  把一组业务当成一个业务来做，要么都成功，要么都失败 事务在开发中十分重要，涉及到数据的一致性问题  事务的ACID原则：\n 原子性 一致性 隔离性  多个业务可能操作同一个资源，防止数据损坏   持久性  事务一旦提交，无论系统发生什么问题，结果都不会再被影响，被持久化的写到存储器中    13.2、Spring中的事务管理  声明式事务：AOP 编程式事务：需要在代码中进行事务的管理  mapper\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  public class UserMapperImpl implements UserMapper { //原来所有操作都使用sqlSession来执行，现在使用sqlSessionTemplate  private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) { this.sqlSession = sqlSession; } @Override public List\u0026lt;User\u0026gt; transaction() { sqlSession.getMapper(UserMapper.class).insertUser(new User(2, \u0026#34;admin\u0026#34;, \u0026#34;admin123\u0026#34;)); sqlSession.getMapper(UserMapper.class).deleteUser(2); return sqlSession.getMapper(UserMapper.class).selectUser(); } @Override public List\u0026lt;User\u0026gt; selectUser() { return sqlSession.getMapper(UserMapper.class).selectUser(); } @Override public int insertUser(User user) { return sqlSession.getMapper(UserMapper.class).insertUser(user); } @Override public int deleteUser(int id) { return sqlSession.getMapper(UserMapper.class).deleteUser(id); } }   配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xmlns:tx=\u0026#34;http://www.springframework.org/schema/tx\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd\u0026#34;\u0026gt; \u0026lt;!--DataSource:使用Spring的数据源替换Mybatis的配置 c30p dbcp druid--\u0026gt; \u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DriverManagerDataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;com.mysql.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mybatis?useUnicode=true\u0026amp;amp;characterEncoding=utf8\u0026amp;amp;useSSL=true\u0026amp;amp;serverTimezone=Asia/Shanghai\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;123456\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--sqlSessionFactory--\u0026gt; \u0026lt;bean id=\u0026#34;sqlSessionFactory\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34;/\u0026gt; \u0026lt;!--mapper文件位置--\u0026gt; \u0026lt;property name=\u0026#34;mapperLocations\u0026#34; value=\u0026#34;classpath:com/wzc/mapper/*.xml\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--sqlSession--\u0026gt; \u0026lt;bean id=\u0026#34;sqlSession\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionTemplate\u0026#34;\u0026gt; \u0026lt;!--只能用构造器注入，因为没有set方法--\u0026gt; \u0026lt;constructor-arg name=\u0026#34;sqlSessionFactory\u0026#34; ref=\u0026#34;sqlSessionFactory\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--配置声明式事务--\u0026gt; \u0026lt;bean id=\u0026#34;transactionManager\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DataSourceTransactionManager\u0026#34;\u0026gt; \u0026lt;constructor-arg ref=\u0026#34;dataSource\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--结合AOP实现事务的织入--\u0026gt; \u0026lt;!--配置事务通知--\u0026gt; \u0026lt;tx:advice id=\u0026#34;txAdvice\u0026#34; transaction-manager=\u0026#34;transactionManager\u0026#34;\u0026gt; \u0026lt;!--name: 给哪些方法配置事务，propagation: 配置事务的传播特性【new】--\u0026gt; \u0026lt;tx:attributes\u0026gt; \u0026lt;tx:method name=\u0026#34;selectUser\u0026#34; read-only=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;tx:method name=\u0026#34;insertUser\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt; \u0026lt;tx:method name=\u0026#34;updateUser\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt; \u0026lt;tx:method name=\u0026#34;deleteUser\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt; \u0026lt;tx:method name=\u0026#34;*\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt; \u0026lt;/tx:attributes\u0026gt; \u0026lt;/tx:advice\u0026gt; \u0026lt;!--配置事务切入--\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;txPrintCut\u0026#34; expression=\u0026#34;execution(* com.wzc.mapper.*.*(..))\u0026#34;/\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026#34;txAdvice\u0026#34; pointcut-ref=\u0026#34;txPrintCut\u0026#34;/\u0026gt; \u0026lt;/aop:config\u0026gt; \u0026lt;/beans\u0026gt;   测试\n1 2 3 4 5 6 7 8 9 10 11  public class UserTest { @Test public void test1() { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); UserMapper userMapper = context.getBean(\u0026#34;userMapper\u0026#34;, UserMapper.class); List\u0026lt;User\u0026gt; userList = userMapper.transaction(); for (User user : userList) { System.out.println(user); } } }   ","date":"2022-03-07T00:00:00Z","image":"https://WangZichen99.github.io/img/2022/03/trees_road.jpg","permalink":"https://WangZichen99.github.io/p/springnote/","title":"Spring笔记"},{"content":"我的第一篇博客\n","date":"2022-03-06T00:00:00Z","image":"https://WangZichen99.github.io/img/2022/03/mountain.jpg","permalink":"https://WangZichen99.github.io/p/firstblog/","title":"我的第一篇博客"}]