[{"content":"蛤蟆先生去看心理医生 第五章 成长的寓言 儿童的基本情感是指每个人生来就具备的情感，随着不断成长和不同的经历，我们会成为不同的个体。\n儿童的基本情感包括：快乐和深情、愤怒、悲伤、恐惧。这些情绪是儿童自我状态的重要组成部分，如果一个人处在上述的某个情绪中，就进入了儿童自我状态。\n每个人一生下来就有着快乐、悲伤、愤怒恐惧这几种基本情感。而后天的变化是根据父母对我们的行为被影响的。在我们哭闹时，父母就会哄我们，我们想要获得更多的关注，想要得到父母的关爱，这就形成了让我们生存下去的行为模式。\n在婴儿时期孩子只能适应父母去成长，所以父母的角色对孩子的成长是至关重要的，父母的行为会影响孩子的情感发展。\n第六章 探索童年  你要记住，就像是画家调色板上的红黄蓝三原色一样，每一个‘自然型儿童’都具备基本情感。但随后我们必须学习调整自然行为来适应特殊情形。我们会将三原色的色调调暗，使它们看上去柔和，以利于生存，同时也借此保护我们个体的完整性。这就意味着我们得学会处理愤怒，包括父母的愤怒，还有我们自己的。\n 适应型儿童的特点：被迫顺从，不与争辩、牺牲自己，取悦别人、道歉、依赖。\n 成长的本质就是要减少并最终打破这样的依赖关系，这样才能成为一个独立自主的人。很少有人能完全达成这点，有些人能部分达成，而很多人则会依赖一辈子。\n 第七章 愤怒的表现 在我们小时候无法得到满足时或是因为某件事情生气时，我们便学会了不带攻击性的愤怒。愤怒的发泄方式有两种，一种是将阀门快速打开，让气体马上喷出，另一种则是缓慢打开阀门，让气体慢慢泄漏出来，我们学会的便是后者。具体表现是撒泼或者怄气，撒泼是表达愤怒的一种幼稚的方式，而怄气也是同样的，怄气的人总是绷着脸、阴沉沉的样子，安静得反常。\n当成年人怄气、撒泼、郁闷或是厌烦，其实是在无意识或无法控制的重演童年的行为模式。当我们在生活中重演了儿童的行为模式，比如任性、撒泼、怄气等，会导致两个负面后果：第一：被人嘲笑；第二：向别人反映自己是个失败者。\n第九章 秘密协议  但是越是能帮助你深入自我的概念，也越容易引发激烈的阻抗。”\n“为什么呢？”\n“因为这些概念最容易打破我们的心理平衡，它们最有可能带你走向深层的蜕变，而这个过程往往是痛苦的，我想你现在也感受到了。我们看到的自己，并不一定总是我们喜欢的样子。从当下的你，变成你想成为的自己，必定要经历行为和态度的转变，需要付出艰辛的努力，需要勇气和决心。所以蛤蟆，你现在应该懂了，为什么你会拒绝打开这扇学习之门，因为它通向一条艰苦之路。”\n 父母自我状态：处于父母自我状态时，我们表现的像自己的父母。父母状态包含了自出生起，我们从父母那里学到的所有的价值观和道德观以及对生活的评判标准。这些价值观来自父母，所以父母是最能左右我们行为的人。他们的言行塑造了我们童年的生活，也不可避免的对我们之后的人生产生影响。\n挑剔型父母状态的人的特点：爱批评人、愤怒、严厉\n每个人都拥有父母自我状态，有的人在批评别人，有的人喜欢责怪自己。没有一种批判比自我批判更强烈，也没有一个法官比我们自己更严苛。\n你能停止自我批判吗？你能对自己好一些吗？也许最重要的问题是，你能开始爱自己吗？\n第十一章 蛤蟆先生的选择 除了儿童自我状态和父母自我状态外，还有一种自我状态，既不会表现得像父母，也不会感觉像个孩子，在这个自我状态里，我们更像个成年人，更像当下的自己，这个状态被称为成人状态。\n 成人自我状态是指我们用理性而不是情绪化的方式来行事。它让我们能应对此时此刻正在发生的现实情况。\n在这个状态下，我们能计划、考虑、决定、行动，我们能理性而合理的行事。处于这个状态时，我们所有的知识和技能都能为自己所用，而不再被脑子里父母过去的声音所驱使，也不会被童年的情绪所围困。相反，我们能思考当下的状况，基于事实来决定要怎么做。\n只有在成人自我状态里，才能学到关于自我的新知识。\n在‘儿童状态’时，你会体验到童年的感受，好的坏的都有。你会再现过去的情形，再次体验过去的情绪，可你学不到任何新的东西。\n当你处在‘父母状态’时，基本上你不是在挑剔就是在教育别人。不管是哪种，你都在用言行重复从父母那里学来的观念和价值观，你会想证明给别人看，让别人接受你的观念和价值观。这种确信无疑的状态，就没法给新知识和新理念留出一席之地。旧的思想主宰着你，这就是为什么单靠争论不能改变一个人的想法，只会让人更固执己见。\n 进入成人状态需要刻意的努力和思考，而父母和儿童状态几乎不需要思考，因为我们知道父母和儿童时的行为做法。只有对自己负责，才能认识到自己是有主动权的。我们有力量来改变处境，有力量能够改变自己。\n第十三章 人生坐标与心理游戏  所谓活得真实，就是真诚地回应当下的需求。这能打破从童年延续而来的因果循环，让真实的自我摆脱过去经历的束缚，在自由中成为真正的自己。他决定要让自己活得更真实一点儿。\n想要理解你的现在，就必须回顾你的过去，你应该不会觉得意外。实际上，我们得回顾你生命最早期的阶段，从出生到大约四五岁的时候，发生的一切都对你影响重大，还影响了你后来的成长，牵涉到你怎样看待自己和别人。这种影响是普遍存在的。就这样，你形成了对这个世界特有的看法，对你而言，这就是你看待事情的唯一方式。从那时起，你就生活在自己的世界里，用同一个视角看待一切事物。\n  一旦我们在童年决定用哪种态度和观点，我们就会在随后的人生里始终坚持自己的选择。这些态度和观点，变成我们存在的底层架构。从那以后，我们便建构出一个世界，不断确认和支持这些信念和预期。\n假如你认为生活让你不快乐，不善待你，那么今天喝醉就是你用的某种方法，它可以印证明天你会感觉悲惨的预期。\n这是一种长期重复的行为，这种行为可能持续一辈子，这类行为就被称为游戏。实际上，刚才说的这种游戏叫‘酗酒’。\n 第十四章 赢了游戏 输了自己 我不好你好的人生坐标，代表了认为生活虐待了自己而溺爱了别人。认为所有的人都要比自己过的幸福。他们认为自己很不幸，可怜弱小的我，用自怜来抨击自己，同时期望鄙人无时无刻的对自己好。如果一个人极其讨厌自己，贬低自己而羡慕别人，便会自杀，他们处在悲伤儿童状态。\n我好你不好的人生坐标恰恰相反，他们总希望抓住别人的小错误，然后以此为借口将愤怒传达给别人，他们站在权力的制高点上无情的批判着别人，以此来建立一种优越感，表示自己要好于别人。就像上司与下属一样，上司将自己想象成父母，而下属是他们的孩子，他们自然的责备下属犯的错误。除此之外，\u0026lsquo;你怎么总是让我失望\u0026rsquo;和\u0026rsquo;你怎么敢这样\u0026rsquo;通常是他们的话语。他们用任何时机来制造能让他们评判和惩罚别人的情景，他们是生活中的施暴者，永远都是挑剔型父母。\n第十六章 道别与新生  人们太容易让重要的事件就这么过去，忘记关注或为它们庆祝，也许是因为我们通常都只在事后才明白它们有多重要。\n ","date":"2023-02-04T22:17:32+08:00","image":"https://WangZichen99.github.io/img/2023/02/photo-1491036775913-3fbc5c455842.jpg","permalink":"https://WangZichen99.github.io/p/toadseepsychologist/","title":"蛤蟆先生去看心理医生读书笔记"},{"content":"欲望的博弈：如何用正念摆脱上瘾 导言 书中写到，当我们第一次品尝美食后，大脑会记住这种愉悦感，同时记住了美食能够使我们获得愉悦感，那么当我们不开心或是无所事事的时候，大脑就会说既然没什么事情做，既然不开心，那就奖励自己一下吧，于是我们又开始高兴的品尝美食，但是虽然品尝美食能够使我们获得愉悦感，却不是解决我们无所事事或是心情低落的根本方法，换句话说不吃美食不是造成心情低落的原因，而是其他的事情。当我们不断重复着上面这样的想法，上瘾就形成了。\n如果我们想上面一样，本来想通过美食来缓解自己低落的情绪，但是你会发现这样做却带来了另外一件烦恼：变胖，那么我们就应该停下来思考是什么问题造成了这种偏差。那么正念又是什么呢？\n 正念就是更清楚地看待世界。如果我们因为自己的主观偏差而迷失，不停地兜圈子，那么正念能让我们意识到这些偏差，看出自己是怎么走向歧途的。只要我们看到自己在原地打转，哪儿也没去成，就可以停下来，扔掉不必要的包袱，重新对自己定位。用个比喻的说法，正念就是帮助我们在生活疆域里导航的地图。\n 如果人在森林里迷路了，本能的感到恐慌，那么自然的会加快脚步，但是这么做只会越来越糟，我们应该停下来，然后审视四周，找到自己的位置，找到问题所在，然后开始行动。\n第1章 直接上瘾  上瘾就是哪怕存在不良后果仍持续使用。如果因为采用特定的某种物或某一特定行为（不管是尼古丁、酒精、可卡因，还是赌博或其它什么），事情出了岔子，我们却还是继续这么做——这就是上瘾，也是评估上瘾的基础。它把我们和身边的生活搞得有多乱七八糟，则有助于判断上瘾的严重程度。\n 上瘾的过程：触发因素，行为，奖励，重复。对于大多数上瘾来说奖励来自不快之事的消失，也就是消极强化。上瘾搭乘的便车，是进化带来的不可抵抗的力量：每一种成瘾性药物，都劫持了多巴胺奖励系统。所以正是由于奖励才使得我们容易上瘾。\n文中阐述了几点烟与其他上瘾物质相比更难以戒除的原因：\n 第一，尼古丁是一种兴奋剂，它不会麻木我们的日常认知能力。我们可以抽着烟开车，也可以抽着烟操作重型机械。\n第二，在任何时间任何地点都可以抽烟。一个每天抽一包烟的人，单单一天里就能强化自己的习惯20次。\n第三，我们不会因为上班吸烟遭到解雇。\n第四，吸烟不会马上置我们于死地，虽然吸烟会增加肺癌的可能性，但长期规划思维无法抵挡眼前的诱惑。\n第五，肺部大量的毛细血管会让尼古丁迅速进入血液，然后大脑释放多巴胺，产生愉悦。\n 如何利用正念去戒除上瘾：\n第一，觉知。\n在使用正念对抗上瘾时，需要看清自己从上瘾的行为中真正获得了什么，更深层次的理解自己的上瘾行为，看清自己上瘾行为的后果，就会放弃旧有的习惯。正念是对自己身体和思想里发生的事情感兴趣，靠近观察，与之亲近，正念时接近自己体验的意愿，而不是努力想要放弃自己不快的渴求。\n第二，使用注意法训练。\n注意到自己的体验和感受想法。正视上瘾时的感觉，寻找上瘾时身体和内心的感觉，然后用单词来形容这种感觉，比如肚子躁动、灼热等等。接着紧紧跟着感觉，知道感觉完全消退。\n第三，加入冥想练习。\n练习冥想能够帮助自己更好的察觉和跟随自己的感觉。\n想抽烟时的渴求就像是一场火灾，如果选择不再吸烟，等燃料消耗殆尽，渴求之火自然就会熄灭，想抽烟的感觉就会降低直到消失。如果继续选择抽烟那就会为渴求之火提供燃料，使得渴求之火继续燃烧。\n第2章 技术上瘾 当你迷恋于发布自己的动态在朋友圈中，期待所有人给你点赞时，你就患上了技术上瘾。\n谈论自己有奖励效果，从而导致这种上瘾。当我们从他人那里获得了关于自己的讨论反馈给自己，这样的反馈使自己相信，自己与其他人有着联系，自己获得了关注，比如从同伴那里得到赞赏或是评论回复，使得我们感到宽慰兴奋。那就像记住了好吃的食物在哪里一样，使得我们不断的重复同样的行为，寻找社交食物。\n这种上瘾带来了社交退缩的负面影响，当我们看到了他人的美好生活，看到了别人的生活比自己的更加精彩，更加美好的时候，这让我们想要获得别人的生活，给自己徒增烦恼。\n人们错误的把思想的兴奋感当成了真正的幸福，认为多巴胺启动带来的感觉就等于是幸福，但是这种兴奋感是为了让自己记住到哪里找到食物而确立的。真正的幸福应该是没有负面影响的，而所有上瘾行为都是会带来负面影响的，比如巧克力上瘾使你变胖，对Facebook上瘾使你感到焦虑难过。如果我们能够停止足够长的时间不去做上瘾的行为，而是退后一步，对真正的奖励进行反思，就能够看出什么样的行为会让人围着压力转，重新发现让人幸福的东西，我们能学会解读自己的指南针。\n第3章 对自己上瘾 主观偏差是指自己的主观认知与实际情况存在偏差，如果我们一直陷入主观偏差中无法自拔，那就是对自己上瘾。\n主观偏差不会上世界变成我们想象的样子，但是如果我们一直按照自己的主观偏差采取行动，就会走上错误的道路，出现各种问题。\n有两种自我会造成主观偏差，第一点是不断自我模拟。自我模拟本身就是一种主观偏差，我们带着自己的有色眼镜看世界，我们看见的世界是自己想要看到的世界，但并不是真是的世界。第二个自我是来自他人对我们的评价，我们要知道，别人对我们的评价是别人眼中的自我，别人的凭借或是反应可能会让我们获得错误的自我认知，从而导致主观偏差的产生，让自己被蒙蔽。\n第4章 分心上瘾 深陷智能手机，无法完成自己的工作和生活，又或是本来正在做项目，但是一次一次的想要查看自己的电子邮件，被称为分心上瘾。\n大脑中有两个系统，系统一代表较为原始的情绪系统，与该系统相关的大脑区域包括内侧前额叶皮层和后扣带皮层。如果发生了某件跟我们相关的事情，比如想到了自己、做白日梦等，这些部位就会被持续激活。\n系统二是后来演化出来的大脑部位，代表更高级、使人类独一无二的能力，包括计划、逻辑推理和自我控制。位于背外侧前额叶皮层。\n面对分心上瘾，我们需要看清从分心中获得的实际奖励，看到我们分心带来的不是积极的影响，而是让我们烦躁的消极影响。\n第5章 思考上瘾 反刍式思考，反复思考，无法确定，纠结，就像自己陷入了巨大的漩涡中无法出来就是作者所说的思考上瘾。\n当涉及“我”或是以我为中心的问题时，默认的网络——内侧前额叶皮层和后扣带皮层就会被激活，这两个部位就像爬行脑，低级且及时享乐。当我们什么都不做或是走神时，这两个部位就会活跃，可以理解为这时的行为完全处于本能状态，没有任何高级的思考。当学习，看书时这两个部位的活跃度就会降低。\n冥想能够帮助降低内侧前额叶皮层和后扣带皮层的活跃度。\n第6章 对爱上瘾  如果我们把“我”这面大旗插在地上，宣称我们必须这样或那样，两人的关系就会江河日下。毕竟，上瘾不是要照料自己的孩子，拯救这个世界。它是一次又一次地被吸入漩涡，满足个人欲望。\n 这说明真正的爱情并不是以自我为中心的，不是单方面痴迷的爱。如果总是认为爱情总是聚焦于自我，那我们就漏掉了爱更宽广、更深刻的意义层面，小爱自我，大爱无私。\n第7章 全神贯注为什么这么难，这是真的吗 人越是沉迷于感官快乐，对感官享乐的渴望就越强，但是依赖于感官享乐只能得到一定程度上的满足和享乐。沉迷于感官享乐带来的愉悦使得我们不断重复这一过程，当我们从中得到兴奋，我们就会渴望更多。但是欲望是无限的，我们应该为自己重新定义幸福，清楚的看到兴奋与喜悦之间的差异，否则不足以改变我们的习惯。我们将继续回到自己的欲望上。\n专注于某件事带来的是全身心的投入，能够获得更为平静的喜悦，而不是兴奋所带来的短暂的满足。\n 喜悦和兴奋之间的关键区别在于，喜悦来自关注和好奇。实际上，在任何清醒的瞬间，我们都有可能切入这种意识。它不需要你付出任何辛劳，因为人的觉知随时都在，我们只要时刻保持觉知状态就行。反过来说，兴奋需要有某件事发生在我们身上，或是要求我们获得某样自己想要的东西，我们必须要去做些什么，才能得到自己想要的东西。为了从兴奋切换到喜悦，我们可以留心触发因素，行为，注意喜悦、安宁、平静。借助自己的奖励式学习过程，我们越多地采取这些步骤，就越是能够建立起更专注、更幸福的习惯模式。事实上，我们可能会发现，只要有合适的条件，这种存在模式是随时可行的。\n 第8章 学习刻薄和友善  但很关键的地方在于，我们要真正准确地看到正在发生些什么。在这方面，正念可能大有帮助。我们必须取下自己带主观偏差的眼镜，它扭曲了我们对所发生事情的阐释，这样一来，我们才能清楚地看到自己行为所导致的一切。除非我们得到即时反馈（看到行为的后果），否则，我们学到的有可能完全是另一些事情。\n在我的“愤怒”冥想静修中，我注意到自己的习惯对集中精神毫无帮助。我开始不再为它感到那么兴奋，接着我发现，我为其他事情释放出了更多的精力。为什么呢？所有人恐怕都有过体会：愤怒是会让人筋疲力尽的！静修期间，我的精力改换了意图，让我的思想变得不再那么分散，更加专注。随着愤怒的消退，我得以把恰当的条件结合到一起，进入了一种非常专注的状态，一次能停留整整一个小时。\n 停止兴奋，就能释放出更多精力在其他事情上，而不是为了不良情绪消耗能量。\n保持慷慨善良的精神就更容易获得喜悦的感觉。如果你每天表现得像个混蛋，就很难坐下来冥想，因为只要你尝试聚焦在一个物体上，那这一天发生的所有触及情绪化的事情都会冲进大脑里，让你无法集中注意力，但是如果我们没有说谎、作弊、偷东西、就不会有那么多垃圾需要倾泻。保持无私的心才更容易获得喜悦。\n第9章 心流 在稍微具有挑战的事情上更容易进入沉浸状态，找到心流。\n当你心无杂念时，事情就这样发生了，你不会关注结果，只是沉浸在过程中。\n 不要自我打击。不足为奇，任何乐手都可以证实，我们可以成为自己最大的敌人：在排练时自我指责，产生表演焦虑，或者因为搞砸了表演而打击自己。我们越是陷入这些习惯循环中，就越是在练习失败而非成功。\n慢慢来。专注并仔细地从头学习怎样演奏一支新作品，一开始会让人觉得十分乏味，可我们必须确保学习正确的技巧和音乐结构。如果没有先分别掌握所有部分，就急着去演奏整部作品，这可能是不安或懒惰的表现。\n搞砸的话别太上心。当失误出现时要尽快把它们抛开，这有助于我们避免把问题越弄越复杂。分析我们做了些什么，或是老想着有没有人注意到，是自我意识的形式。忽略这种潜在的干扰，可以避免小失误愈演愈烈变成大失误。\n质量甚于数量。在疲倦或不专心的时候学会停下，这是个关键。我们的自我常常说，要继续下去，以便向自己和同伴乐手吹嘘：我们那天练了6个小时！这条建议还适用于不为“没练够该练的时长”而感到内疚。\n 第10章 训练韧性 如果没有韧性，当生活的压力来临后，我们又会因为压力重新上瘾。如果能够培养起精神韧性来应对生活中出现的诸多变化和挑战，我们就可以放松琴弦，给琴板加点润滑；这样的话，不管在任何时候，倘若出现来自阻力的不必要的负担，也会变得更容易背负。只有这样，我们才能从艰难局面里恢复过来，获得足够的弹性，随着事情的变化懂得转换。\n面对压力时将自我从个人情绪中剔除，释放处于自我保护的能量，就能消除共情疲劳，增加韧性，韧性其实就是消除疲劳快速恢复的能力。\n 在任何类型的成瘾行为中，反应性都是通过重复（阻力训练）来增强力量的。每一次，我们上Facebook看自己有了多少个“赞”，都是在推起“我”的哑铃；每一次，我们响应触发因素抽起烟来，都是在做着“我抽烟”的俯卧撑；每一次，我们兴奋地跑到同事那里，告诉她我们最新最了不起的想法，都是在做着“我很聪明”的仰卧起坐。我们锻炼得太多了。\n到了某个时候，我们不再围着自己的积极和消极强化循环圈奔跑了。这是什么时候发生的？大多是在我们筋疲力尽的时候，我们厌倦了所有的杠杆压力，开始清醒地意识到，我们不会抵达任何地方。当我们停下来，观察自己的生活时，我们可以退后一步，发现自己迷失了方向，哪儿也去不了。我们可以拿出指南针，看看自己是不是一直在朝着错误的方向走。这里最棒的地方是，只要注意到我们是怎么给自己找压力的（保持正念之心就行），就可以开始训练自己选择另一条路。\n不过，我们的阻力训练也不会白费功夫。因为它将有助于提醒我们，哪些行为会把我们带到错误的方向，日复一日地愈发不安和不满。我们越是清楚地看到这种不必要的结果来自一种重复行为，我们就会变得越来越祛魅，也越少不自觉地为这种行为所吸引。我们不再为从前认为是快乐源泉的东西感到兴奋了。为什么呢？因为放手、单纯地做自己所带来的奖励，比不安更好。我们的大脑是为了学习而演变出来的。然而，我们大多数人不曾学过，指南针针尖的红点表示北方。只要我们清楚地看到紧缩、自我强化的奖励，与开放、扩张、喜悦的自我遗忘所带来的奖励有什么不同，就能学会解读指南针。然后，我们重新定位，开始朝着另一个方向前进，去追求真正的幸福。知道一种工具是怎么用的，带给人很强的力量感；我们可以充分地利用它了。面对自己的痛苦，我们无须退缩，或是因为自己陷入另一种习惯循环而呵斥自己，我们只需要拿出指南针，问问自己：“这是在朝着哪个方向走？”我们甚至可以向自己的习惯鞠躬表示感激，因为，从这一刻起，它开始扮演老师的角色，帮助我们了解自己和自己的习惯性反应，让我们得以从经验中成长。\n 我们只要按照自己的感觉，做某件事情是让我更沉重了还是让我感觉更轻松了，答案自然会揭晓，你就知道这件事情是不是让你陷入了森林中无法出来，你是否需要停下来拿出指南针。\n后记 未来就是此刻  专注于自我，以及奖励式学习带来的主观偏差的发展，他们或许不光识别出了这个过程的渴望和反应，甚至还找出了一条简单的解决之道：关注我们行为的感知奖励。更清楚地看到行动的结果，帮助我们削弱自己的主观偏差，而这一重新定位自然会让我们走出不健康的习惯，从压力转到一种不依赖于获得什么东西的快乐。完成这一调整，可以释放出汹涌的能量，而且，还可以把这些能量引导到各种能改善我们生活的地方，比如减少分心，更充分地投入世界，找到更大的幸福，甚至体验到心流。\n ","date":"2023-02-04T22:15:55+08:00","image":"https://WangZichen99.github.io/img/2023/02/pexels-yaroslav-shuraev-6882086.jpg","permalink":"https://WangZichen99.github.io/p/resistdesire/","title":"欲望的博弈：如何用正念摆脱上瘾读书笔记"},{"content":"第一章 投资新手的建业 找到长期收益率最高的产品 现金流指购买资产获得的额外收益。\n能产生现金流的资产：债券、股票、房地产，这些资产的价格由现金流的大小和稳定性决定。\n不能产生现金流的资产：黄金、首饰、字画，这些资产的价格由供求关系决定。\n看收益更要看风险 复利计算公式：最初本金 * (1 + 年复合收益率) ^ 投资年数\n如果能长期保持13%的收益率是非常不错的事情，如果最初投入10万元，那么30年后就能得到391万，这就是复利。\n第二章 投资工具这么多，为什么要选指数基金 什么是指数  指数是一个选股规则，它的目的是按照某个规则挑选出一篮子股票，并反映这一篮子股票的平均价格走势。\n每一个指数都有一个点数。这个点数就是指数背后公司的平均股价。这个点数下跌，就代表指数背后的公司股价整体下跌了；如果点数上涨，就代表指数背后的公司股价整体上涨了。\n 谁开发的股票指数  开发指数的机构主要有两类：证券交易所和指数公司。\n国内有三大指数系列。\n 上海证券交易所（简称上交所）开发的上证系列指数， 深圳证券交易所（简称深交所）开发的深证系列指数， 以及中证指数有限公司开发的中证系列指数。   指数基金是怎么来的  前面提到过，指数是一种选股规则，按照某个规则挑选出一篮子股票。如果有基金公司开发一个基金产品，也完全按照指数的选股规则去买入完全一样的一篮子股票，这就是指数基金了。\n简单来说，指数基金是一种特殊的股票基金。一般的股票基金依赖于基金经理的个人决策能力，而指数基金不一样：它是以某指数作为模仿对象，按照该指数构成的标准，购买该指数包含的证券市场中全部或部分的证券，目的在于获得与该指数相同的收益水平。\n 躺着赚钱的指数基金  指数基金的三个好处：\n  长生不老\n没有一家公司可以长生不老，但是指数基金可以通过吸收新公司替换老公司的方法，实现长生不老。理论上，指数的寿命与国家的寿命等同。普通的股票基金无法做到这一点，因为普通股票基金的表现取决于基金经理，由基金经理来决定股票的买入和卖出。但很少有基金经理能投资30~40年以上，所以普通股票基金一般无法长期存在下去。\n  长期上涨\n指数基金为何能长期上涨呢，背后的解释有很多。一个比较通用的解释是，指数背后的公司，每年赚的钱，会不断再投入生产，这样来年可以带来更多的盈利。这样不断地利滚利，就会推动指数不断上涨。所以只要国家有一个稳定的环境，指数背后的公司就能创造越来越多的盈利。或许某些年份遭遇困境，盈利会下滑，但长期看盈利会不断上涨。这是指数长期上涨的根本动力。\n  成本低\n管理费是交给基金公司的费用，托管费是交给托管方的费用。指数基金的管理费和托管费都要更低一些\n  指数基金能够规避投资常见的三种风险：\n  个股黑天鹅风险\n指突发的、无法预料的风险，比如三聚氰胺事件等等，这就导致某一只股票可能会突然破产，但指数基金买的不是某一种，而是几十几百只股票，所以分散了这种风险。\n  本金永久损失风险\n某一个公司可能今天盈利不错，但是明年突然倒闭了，那本金也就没了。指数基金同样分散了这种风险。\n  制度风险\n指数基金买哪些股票是明确的，不存在内幕交易等情况。\n   第三章：常见指数基金品种 指数基金的分类 指数基金可以分为宽基指数和行业指数。宽基指数基金所购买的股票不限行业，行业指数基金购买的股票是某一行业\n常见宽基指数基金 上证50  上证50指数是从上交所挑选沪市规模最大、流动性好、最具代表性的50只股票组成样本股，以综合反映沪市最具影响力的一批优质大盘企业的整体状况。代码为000016。\n 上证50以大盘股为主，这些大盘股也称为蓝筹股。同时上证50只有上交所的股票，没有深交所的股票，所以无法反映国内股票的整体走势。\n 什么是蓝筹股？蓝筹这个词来自西方赌场。在西方赌场里，一般有三种颜色的筹码，其中蓝色筹码最为值钱。后来就用蓝筹股，代表规模较大、有较大影响力的公司。\n场内基金在证券交易所上市，可以有“申购赎回”和“买入卖出”两套交易体系，其中买入卖出方式需要在证券交易所中进行，是通过股票交易软件来操作的。如果基金没有在证券交易所上市，那就是场外基金，它只有“申购赎回”一种交易方式。\n追踪同一个指数的不同指数基金，它们的单价可能会差很多，有的基金单价是0.9元，有的基金单价却是3元。这主要是由于基金成立时间的不同而导致的，对我们的投资并没有什么影响。\n举个例子，一只上证50指数基金A，基金净值1元；另一只上证50指数基金B，基金净值2元。如果上证50指数上涨50%，那A基金净值会涨到1.5元，B基金会涨到3元，它们上涨的百分比是大致相同的。当然，前提是指数基金追踪指数的效果是正常的。\n提示：为何要避开规模较小的指数基金？\n如果一个指数基金规模较小，它清盘的概率就比较大。基金清盘并不是说我们的投资血本无归了，而是按照某一个基金净值强制赎回，导致我们的投资中断。如果基金规模太小，那么基金公司运作这个基金可能就是亏本的，基金公司就有可能停止这个基金的运作。所以一般挑选指数基金的时候，会避开规模较小的指数基金，最好规模在1亿以上再考虑。\n 沪深300  沪深300指数是由中证指数公司开发的，从上交所和深交所挑选规模最大、流动性最好的300只股票。它的成份股数目比上证50多，也都是以大公司为主。沪深300指数所包括的公司，从市值规模上来说，占到国内股市全部规模的60%以上，比较有代表性，所以沪深300也被认为是国内股市最具代表性的指数。沪深300在上交所的代码是000300，在深交所的代码是399300。\n 沪深300也是以大盘股为主，比起上证50更能反应中国股市的整体情况，更具代表性。\n 挑选指数基金，一般有两种思路。\n第一种思路是寻找费用最低、误差最小的品种，这是“指数基金之父”约翰·博格所提倡的。因为基金费用越低、误差越小，指数基金的表现就越贴近于指数。这也是挑选指数基金最常用的方式。\n第二种挑选指数基金的思路，是寻找有特色的增强型指数基金。\n什么是增强型指数基金？\n我们知道，指数基金的目的是复制指数。不过有的时候，股市会出现一些比较明显的能获得超额收益的机会。于是，有的指数基金就会在追踪指数的基础上，去做一些操作来赚取超额收益，例如打新、量化模型等，希望相对于指数获得一些增强收益。这就是增强型指数基金。\n什么是联接基金？\n联接基金是基金公司开发的特殊品种。场内基金投资需要开股票账户，具体操作在步骤上也比较麻烦，也没有自动定投的功能。所以基金公司就开发了一个联接基金，方便从场外来投资。联接基金是一种场外基金，通过申购赎回来交易。但它并不直接投资股票，而是通过投资对应的场内指数基金来实现复制指数的目的，也是指数基金的一种。联接基金一般不再单独收费，整体费率跟对应的ETF基金一样。\n 中证500  将全部沪深300指数的300家公司排除，然后将最近一年日均总市值排名前300名的企业也排除，这样可以最大限度地避免选入大公司。在剩下的公司中，选择日均总市值排名前500名的企业，这就是中证500指数啦。中证500指数跟沪深300没有重合，是国内中型公司的代表。代码是000905和399905。\n 中证500是以中型上市公司为主，不同于上证50和沪深300。\n创业板指数 有些公司规模比较小，还无法达到主板上市的要求，国家为了给中小型企业/创业型企业/高科技产业公司提供一个上市融资渠道，就有了创业板。\n由于创业板都是小公司，所以涨跌不稳定，可能出现暴涨暴跌，风险也会较主板大一些。\n 相关指数：\n 创业版综指：为了衡量创业板所有上市公司的股价平均表现而设立的，代码是399102。 创业板指数：为了衡量创业板最主要的100家企业的平均表现而设立的，代码是399006。 创业板50：从创业板指数中选出流动性最好的前50家企业构成，代码是399673。   红利指数 以上基金指数都是按照市值来分配购买股票的权重比例，称为市值加权。其他分配方式统称为策略加权。\n红利指数是按照股息率来决定权重，所以属于策略加权。\n 相关指数：\n  上证红利指数：挑选了上交所过去两年平均现金股息率最高的50只股票，指数代码为000015。\n  中证红利指数：同时从上交所和深交所挑选过去两年平均现金股息率最高的股票，成份股数量扩大到100只。因为中证红利指数同时覆盖了两个股票交易所的上市公司，所以可以挑选的高分红股票会更多一些。从历史表现上来说，中证红利的历史收益就比上证红利指数更好一些。从两个市场挑，可选面总比一个市场要广一些。代码是000922/399922。\n  深证红利指数：深交所过去两年平均现金股息率最高的40支成分股，代码为399324。\n  红利机会指数：由标普公司开发，在股息率的基础上增加了3个筛选条件：过去3年盈利增长必须为正；过去12个月的净利润必须为正；每只股票权重不超过3%，单个行业不超过33%。根据股息率排出前100支股票构成。代码为CSPSADRP。\n这样做的好处有两方面。一方面长期分红的根本来源是盈利，挑选盈利增长、净利润为正的股票，可以去掉很多盈利走下坡路的高分红股。这样筛选出来的股票，长期分红能力会更强。另外盈利增速高也会带来更好的收益。另一方面则限制了指数行业的占比，这样可以避免某些特殊时间段某些行业占比过高的情况，长期更加稳健。像2007年的时候，当时钢铁行业整体高分红，就占据了红利指数很大比例。限制行业占比，可以避免某些行业仓位过重，降低风险。\n场内基金主要有两种，ETF基金和LOF基金（上市型开放式基金）。这两种基金都是可以在股票交易所里自由买卖的。所不同的是，ETF基金只能通过股票交易软件来交易，而LOF基金除了可以通过股票交易软件来交易之外，还可以像场外基金一样，在场外通过申购赎回的方式来交易。\n  指数特点：\n 高股息率，在熊市更有优势。熊市分红后相同金额所能买到的股票份额更多。 能持续发放现金股息的公司，盈利能力和财务健康状况好的概率越高。 提供分红现金流。   基本面指数 基本面指的是公司的营业收入、现金流、净资产和分红这四个方面。哪个公司的基本面更好就选哪个公司。\n 相关指数：\n 中证基本面50：在深交所和上交所中按照基本面指标挑选过去五年中排名前50的股票，指数代码为000925/399925。   指数特点是大盘股，从多个维度挑选公司，考虑更全面。\n央视财经50指数 央视50是一种专家加权的指数，是深证指数和中央财经频道联合推出。央视50指数依靠专家的选股能力来选股，其规则并不透明，是一种很特殊的指数。指数代码是399550。\n央视50指数的特点是专家在挑选股票时会挑选龙头企业，同时也会挑选一些成长性好、有前景的小盘股。\n恒生指数 投资于香港交易所、美国等海外市场的基金称为QDII基金，意思是合格境内机构投资者，这些海外交易市场都是使用非人民币来交易，所以在一定程度上能够抵御货币贬值的风险。如果人民币贬值，那么持有海外市场的指数基金不会受到贬值影响，相反，如果人民币汇率提高，那么持有的海外市场指数基金就会受到损失。\n 需要注意一点，内地金融整体来说还不成熟，政策也经常变化。\n\t如2016年2月份，就有部分QDII基金暂停申购，但可以赎回。原因是我国限制人民币外流，所以部分基金没有换外汇的额度了，基金无法将人民币换为外币，但是可以换回来。\n这是投资QDII基金需要额外承担的一种风险。不过从总体上来看，虽然QDII基金有额外的风险，但是对我们普通投资者来说还是很有用的。通过这种基金可以很方便地配置非人民币资产，一般也没有太大的额度限制（如果是个人用人民币兑换外币，每年有额度限制，但是申购这些QDII基金，并不占用个人的外汇额度）。\n 恒生指数投资的是所有在中国香港上市的公司规模中最大的50家企业，比如中国移动、腾讯都在中国香港上市。指数代码是HSI。\n指数特点：\n  历史悠久，成熟开放\n中国香港是一个开放的国际金融中心，企业在港交所上市更简单一些，同时港交所也比内地的证券交易更加成熟。\n  跟内地紧密相关，但投资者以境外投资者为主\n由于很多内地企业都在港交所上市，所以股票的投资价值与内地关系密切，但是由于投资者以境外投资者为主，又非常容易受到境外市场的影响。\n 1987年10月19日，美股爆发了历史上最大的一次崩盘事件。美国股市一天之内跌幅达22.6%。港股跟随，在不到半个月时间里，恒生指数从3 949点暴跌到了2 204点，下跌幅度达到44%。是一次非常惊人的股灾。\n 不过虽然极易受到境外市场影响，但指数基金具有长期上涨的特性，回过头看那次暴跌只不过是一个小浪花而已。\n 不过这一特点如今也在慢慢地发生变化。最近3年国家先后开通了沪港通和深港通，内地资金正在夺回港股的定价权，这是过去几十年里港股所没有发生过的事情。到2015年，内地投资者交易量在港股中的占比提升到了21.9%，仅次于欧洲（34.2%）和美国（22.5%），但港股仍然是以欧美为主。相信下一个十年，内地投资者夺回港股定价权就是大概率事件了，港股市场也会成为中国第三大证券交易市场。\n什么是港股通？\n港股通是互联互通的一部分，也是中国金融业的一次大创新。在港股通之前，境外投资者很难直接投资A股市场，内地投资者想要走出去也困难重重。港股通于2014年成立，开通港股通后，个人投资者可以很方便地投资中国香港股票市场的股票。港股通初期以恒生指数和恒生中国企业指数的成份股为主，因为这些指数的成份股相对可靠，遇到风险的概率较小，后期也逐渐扩展到香港中小盘股。基金公司也通过港股通，成立了很多投资中国香港股票市场的基金品种。\n   老千股导致个股投资风险巨大。\n港股中存在老千股，指钻了政治的空子，利用股票市场来谋求利益的股票。所以个人投资者最好是投资指数基金来减小风险。\n  H股指数 如果一家公司在内地注册，但是在香港地区上市，这样的公司就是H股了。H股的全称是恒生中国企业指数。H股和恒生不同，恒生挑选的是香港股市规模最大的50家公司，H股挑选的是内地注册香港上市的规模最大的40家公司。\n指数特点：\n  内地公司在境外的代言人\n境外投资者无法直接投资中国内地的股票，但是香港市场是对国际开放的，所以境外投资者通过购买H股来购买国内企业的股票。\n  与内地经济紧密相关，但仍然是以境外投资者为主\n因为H股的公司注册地和业务都在内地，所以与内地的经济紧密相关。但是由于以境外投资者为主，当境外发生大的事件时也会影响到H股。虽然会影响H股的走势，但对于H股背后的那家公司并不影响。\n  H股与A股关系密切\nH股指数是挑选在中国香港上市的规模最大的40家H股。而这些H股背后的公司，很多也在A股上市。所以H股与A股很多指数的关系都非常密切。但是H股的投资对象主要是欧美投资者，A股的投资对象是内地投资者。同一批公司在不同的市场上的表现也有可能截然不同。\n  上证50AH优选指数 上面提到过，因为A股和H股的公司相似，但不同市场环境会表现出不同的趋势，但从长期来看，由于是同一公司的股票，所以A股与H股两者的趋势应该是相似的。如果某个时间段A股上涨H股下跌，那么未来的某个时间段H股也很大可能会上涨，这样才能长期趋于一致。\nAH股的轮动策略就是买入AH股中相对便宜的，卖出相对贵的，以此来获得超额收益。\n指数特点：\n  成分股与上证50相同\n 上证50指数：27只纯A股+23只同时具备A、H股的公司中的A股。 50AH优选指数：27只纯A股+23只同时具备A、H股的公司中相对更便宜的那一类。 H股指数：17只纯H股+23只同时具备A、H股的公司中的H股。    如果同时存在与A、H股中，选取相对便宜的\n经过汇率调整后，如果A股价格/H股价格\u0026gt;1.05，说明A股贵，则选相对便宜的H股；反之，如果A股价格/H股价格\u0026lt;1.05，则说明A股便宜，选A股。\n换句话说，50AH优选指数认为，正常情况下，A股应该比H股贵5%。\n  每个月第二个星期五进行一次轮动\n轮动规则为：\n A股价格/H股价格\u0026gt;1.05，说明A股贵，如果持有A股，则换成H股。 A股价格/H股价格\u0026lt;1，说明A股便宜，如果持有H股，则换成A股。 如果A股价格/H股价格介于1～1.05，则不轮动。  这样能够在轮动的同时，防止AH股价格相差不多时的频繁调仓。\n  如果在未来国家控制港股或投资港股的内地投资者逐渐占据主要地位，那么A股和H股之间的差距也会慢慢减小。\n纳斯达克100指数 纳斯达克100指数投资的是纳斯达克规模最大的100家大型企业。指数代码是NDX。\n纳斯达克主要以龙头企业为主，并且以技术类公司为主，包括了全世界规模最大的一批信息技术公司。\n 投资QDII指数基金的风险：外汇额度不够导致暂停申购。\n投资港股的QDII指数基金因为港股通不限额度，所以不会有额度不足的情况，但投资美股的QDII指数基金，会因为基金公司美元额度不足，经常暂停基金的申购（赎回还是可以的）。\n这是由于我们申购美股指数基金，其实是把人民币交给基金公司，基金公司拿着人民币换成美元，再用美元去投资美股。如果基金公司美元额度不足，即使拿到了人民币，也无法换成美元。每家基金公司的美元额度都是有限的，所以投资美股的QDII指数基金经常暂停申购。\n 标普500指数 标普500指数是美国影响力最大的一个股票指数，是美国传统经济的代表，定位上类似于国内的沪深300指数。指数代码是SPX。\n标普500指数也是以大盘股为主，有500只成份股。不过标普500并不限制入选公司的市值规模，也就是说，标普500不仅有大公司（大约占90%），还有很多中型公司（大约占10%）。标普500指数倾向于选择行业的领导者、长期盈利更好的公司。\n上证综指 上证综指包括了上交所全部的上市公司，目的是反映上交所所有股票的走势。指数代码为000001，国内历史最悠久的一个指数。\n成分股太多，不好追踪，一般都是抽选一部分，用近似拟合的方式实现对上证综指的追踪。\n中证100 中证100指数是从沪深300指数中，再挑选出规模最大的100只股票组成的。比起上证50指数，它覆盖了深交所的大公司，所以更加全面一些。代码为000903。\n中证800指数、中证1000指数、中证全指 中证800指数＝沪深300指数+中证500指数，基本上把A股的大中型公司都囊括在内，其指数代码为000906。\n中证1000指数，追踪除去中证800指数之外最大的1 000只小盘股，指数代码为000852。\n中证全指目的是覆盖A股全部市场上的股票，除了亏损比较严重的公司和上市不足3个月的新公司。不过中证全指没有对应的基金产品，它主要是为了方便统计A股的整体走势时使用的，其指数代码为399985。\n等权重指数 等权重指数是指分配给每个成份股完全相同的权重。\n开始的时候每个成份股都是相同的权重，但是由于各个成份股的涨跌幅度和速度都不同，就导致一段时间后它们的权重也不同了。所以等权重指数一般每隔一段时间会强制再平衡一次，一般是一年一次。\n这种指数的好处是避免了部分股票在指数中的占比过高，缺点是流动性太差，不建议购买。\n价值指数 市盈率、市净率、市现率较低而股息率较高的股票被称为价值型股票，价值指数就是这些价值型股票的指数。价值型股票很少且规模不大，了解就好。\n行业指数基金 哪些行业值得投资？ 值得投资的行业有两种，一个是天生容易赚钱的行业，另一个是有明显周期性的行业\n企业想要获得盈利需要有稳定的需求。\n 不过有时候，即使客户需求稳定，我们也不一定能赚到钱。生产的产品是同质化的，客户选择我们的产品和选择别人家的没啥区别，这就是一片红海，最终竞争会导致价格战，将利润空间吞噬掉。例如智能手机行业，很多智能手机生产商都是微利。 那么，客户需求稳定，我们的产品也有别人模仿不了的优点，我们就一定能赚到钱了吗？其实也不然。有的企业需要经常再投入巨资用于维护以保证稳定的生产，赚到的钱如果不再投入，企业就经营不下去。这时候我们赚到的钱也不属于自己。例如某些高污染的重工业，不注重风控的金融业，即使前期赚到大钱，后期也会还回去。 所以，市场需求比较稳定，企业有护城河能保证一定的利润率，并且再投资需求小，能获得大量的自由现金流，只有容易形成这些条件的行业，才能比较容易的赚钱。\n 也就是说：\n 市场需求稳定； 产品有自己的特点； 盈利是自由的现金流，不需要再投入以维护生产； 企业管理得当；  符合以上4点的行业就是相对容易赚钱的行业，主要体现在消费和医药行业，其中消费行业又分为必须消费行业和可选消费行业。除此之外养老行业由于建立在消费与医药两者基础之上，所以养老行业也是相对容易赚钱的行业。\n那么什么是强周期性行业呢？\n强周期性行业是指行业的盈利会展现出周期性的变化，所谓\u0026quot;三年不开张，开张吃三年\u0026quot;，在低估值时买入，高估值时卖出就能获得比较不错的收益，像金融行业中的银行、证券、保险、地产行业、能源行业、部分材料行业等。\n相关行业指数基金 必须消费行业 指的是日常生活中经常消费的物品，比如：食品、饮料、烟草等等\n 上证消费指数：从上交所挑选必需消费行业公司。 上证消费80指数：从上交所挑选80家规模最大的必需消费行业公司。 中证消费指数：从中证800，即沪深300和中证500中挑选必需消费行业公司。 全指消费指数：从所有上市公司中挑选必需消费行业公司，覆盖范围最广。  医药行业 人都会生老病死，医药行业基本上可以说是万年不死的行业，并且在经济萧条时期也不会太过低迷\n 拿日本股市为例。日本股市的代表是日经指数。从1983年到2012年，日本的日经指数上涨114%，同期日本医药指数上涨312%。具体到日本经济衰落的几十年里，也就是1992年到2012年之间，日经指数下跌25.6%，而医药指数却上涨了92%。\n美国也是如此。美国的标普医药行业指数，是从标普500中挑选医药行业的股票，其表现远远超越同期的标普500指数。从1989年9月11日到2014年7月8日，标普500指数上涨了465%，而同期标普500医药指数上涨了969%。医药行业的涨幅是标普500的2倍多。\n  中证医药指数：又称中证800医药指数，是从中证800指数中挑选医药行业。 中证医药100指数：挑选了100家大型医药股，每只股票买入相同的金额。 上证医药指数：只投资上交所的医药行业公司。 全指医药指数：从整个A股中挑选医药行业，它覆盖的医药公司是最全的。 细分医药指数：挑选了医药行业细分领域的主要公司。 300医药指数：挑选了沪深300指数里的医药行业公司。 500医药指数：挑选了中证500指数里的医药行业公司。  可选消费行业 可选消费指的是有钱之后才会消费的物品，基本上以奢侈品为主，比如：汽车、手机、家电等等。可选消费行业有以下几个特点：\n 需求比必须消费弱，有一定周期性  这是必然的，既然可选消费物品是在人们有钱后才会消费的物品，那么就一定收人均可支配收入的影响，人们有钱时就会消费，没钱时就会选择推迟或不消费。\n 受益于人口红利，特别是人均消费金额的提升  人口红利是指在一个时期内生育率迅速下降，少儿与老年抚养负担均相对较轻，总人口中劳动适龄人口比重上升，从而在老年人口比例达到较高水平之前，形成一个劳动力资源相对比较丰富，对经济发展十分有利的黄金时期。\n经济发展之后，人均消费水平就会提高，这也促进着可选消费行业的兴起\n 可选消费行业的升级换代特性  汽车、手机、家电等等这些可选消费产品每隔一段时间都会发布新产品，这也体现了周期性的特点，同时如果一个企业无法跟上行业的升级换代，那就会被这个行业淘汰。\n养老行业 养老行业是一个概念性的行业，包括了医疗保健、信息技术、日常消费、可选消费等行业，包括80支成分股。\n 挑选规则如下。\n（1）消费电子、休闲用品、酒店旅游、教育、文化传媒、药品零售、乳品、家庭用品、医药卫生、人寿保险、互联网软件等行业属于养老行业，每个子行业挑出一个市值最大的，列入成份股，这就有了十几只。\n（2）挑完后，在剩余的养老产业股票中，挑选市值最大的作为指数样本股，直到样本股数量满80只。\n简单说，就是先保证各个子行业的龙头入选，再按市值来挑选。\n 强周期性行业 银行业 销售保健品行业会随着销售的淡季和旺季发生变化，券商会因为牛市和熊市产生变化，航空股会因为油价上涨和下降发生变化。不管这些周期性行业如何变化，促使变化发生的原因都是不同的，所以周期也会完全不同。最具代表性的周期行业是金融行业。\n金融行业的子行业众多，主要以银行、保险、证券为主。\n首先来看银行业\n 银行具备不错的商业模式，可以简单地看作是“两个收入，两个费用”：利息收入，非利息收入，利息费用，风险准备金。\n例如，银行可以以3%的利率从储户手里收集钱财，然后以6%的利率贷给企业。贷款的利息就是利息收入，支付的3%就是利息费用。\n另外银行还可以收取中间收入或者渠道费用，例如手续费、管理费。这个费用与利息无关，所以是“非利息收入”。\n银行贷款给客户，如果客户还不上钱，银行就得从自己的收益中拿出一部分来弥补亏空。这个用来弥补亏空的资金要预先准备好，这就是“风险准备金”费用。\n银行的收益 = 利息收入 + 非利息收入 - 利息费用 - 风险准备金 = 利差收益 + 非利息收入 - 风险准备金\n 以上可以看出银行的周期性受宏观经济影响巨大。当经济处于下行，企业效益不好，就没有能力偿还贷款，银行就需要使用风险准备金。经济下行时，国家会降息来刺激消费，利息收入就会减少。这样一来，银行效益就会变差。相反宏观经济好的时候，银行的效益也会提高。因为宏观经济的波动，银行的效益就呈现出周期性。\n不同银行的效益体现在对风险的控制上，当经济下行来临时，风控能力强的银行需要更少的风险准备金，收益波动较小，周期性小，能够实现稳步增长。\n银行有几种不同的经营模式：\n  注重利差收益的的银行\n这种经营模式看重利差收益，将存款利息降至最低，并注重企业偿还贷款的能力。这种发展模式是银行最正统、最保险的发展模式。\n  依赖区域经济发展的地区性银行\n 由于业务比较集中在一个地区，因此地区性银行的资产质量、业务量与当地经济的发展情况、当地居民的金融习惯高度相关。如果当地经济发展良好，或者说居民偏爱储蓄、诚信良好，那么银行的资产质量会非常高，相应地，风险准备金会比较小。\n区域性的银行大多与当地政府、企业关系更加密切，能获取很多稳定的业务。例如北京银行，基本包揽了北京地区市属高校、医院等单位的代发工资、贷款等业务。腾讯与北京银行合作京医通，就是看中了北京银行常年经营的这块独属蛋糕。这也是护城河的一种形式。\n   注重非利息收入的银行\n注重利差收益的银行，在经济下行时期，客户还款能力差时会不可避免的受到影响。所以有些银行就在非利息收入上做文章。做中间人，它们和金融机构合作，然后收取资金托管费。\n或者是将资产证券化，转为发行证券，将贷款出售出去，这样就增加了流动性，也避免了利息收入不稳定所带来的影响。\n  一般来说上证50、基本面50、H股指数、50AH股优选指数中就包括了一些银行的成分股。如果投资了这些指数就不需要单独投资银行业指数，避免资产重复配置。\n 分级基金是最近几年兴起的一类比较特殊的基金品种。\n分级基金由三部分组成。母基金是一只普通的指数基金，投资分级母基金，与投资其他指数基金的方式是一样的，投资者可以持有分级母基金来追踪对应的指数。\n在母基金的基础上，分级基金还会拆分成分级基金A份额和B份额。其中，A份额相当于一个债券型品种，目的是获得一个较为固定的收益；B份额相当于一个杠杆型品种，目的是在指数基础上加杠杆，获得更高的收益，当然了，由于加了杠杆，其风险也非常大。\n由于分级基金A份额和B份额的投资特征、投资难度都与普通的指数基金有很大的不同，所以从2017年5月1日开始，国家限制了分级基金A份额和B份额的投资门槛，需要有30万元以上的资金才能投资。而母基金是一只普通的指数基金，没有30万元的投资门槛，跟其他的指数基金一样可以正常交易。\n 证券业 证券行业也就是券商业，也被称为“周期之王”。它是最典型的一个强周期性行业。\n证券公司的收入主要源于交易费用，所以当市场处于牛市时，证券公司的收益会增加，周期与牛熊市息息相关。\n 证券行业适合长期投资吗？\n**证券行业并不适合买入后长期持有。**证券行业可以说是不适合长期持有的行业的一个典型：证券行业是充分竞争的行业，大多数券商提供的服务同质化严重，导致券商行业的基本面和股价的走势高度趋同。激烈的竞争不断地压缩券商的主要收入——佣金。大多数券商没有核心竞争力或者说护城河，不能把自己从竞争中脱离出来，客户可以更加自由地选择券商。再加上互联网金融的冲击，未来超低佣金会成为主流。这些加剧了证券行业的竞争程度。\n 证券行业的指数基金追踪的是中证全指证券行业指数，代码为399975。\n金融行业指数 金融行业指数分为两类；一类是包括银行、保险、证券行业的指数基金，另一类是不包括银行的指数基金，称为非银金融行业指数。\n上证180金融行业指数、沪深300金融行业指数、全指金融行业指数这三种指数基金属于第一种。\n 上证180金融行业指数是挑选上交所的上证180指数中的金融企业 沪深300金融行业指数是挑选沪深300指数中的金融企业 全指金融行业指数是挑选上海和深圳两个证券交易所中的金融企业  目前国内的金融企业绝大多数都被沪深300覆盖了，所以沪深300金融行业指数和全指金融行业指数的表现非常接近。\n非银金融行业指数中大约有40%是保险公司，60%是证券公司。目前非银金融行业指数只有沪深300非银指数，从沪深300金融行业中排除银行业组成。\n地产行业 目前国内的地产行业指数一共有三只，即中证800地产指数、国证地产指数和地产等权指数。\n 中证800地产指数，投资了沪深300和中证500中的地产企业。 国证地产指数是国证系列指数，我们可以把它近似看成是全指地产，也就是投资了A股全部的地产企业。 地产等权指数则是每家地产企业都买一点。  其他指数基金 军工行业 军工行业的指数是中证军工指数，指数代码为399967。\n 从2007年以来，国内的军费总支出年均增长速度超过12%。但到目前为止，我国国防力量、装备先进程度等，跟以美国为首的发达国家相比还有一定差距。所以军工行业也是必须要着重发展的一个行业。不过这个行业受国家政策的影响比较大，所以投资起来难度也比一般的行业要高一些。\n 环保行业 环保行业的指数，主要是中证环保指数，指数代码为000827。环保和军工都是要看国家政策。\n白酒行业 白酒行业是必需消费行业下的一个子行业。白酒行业的指数，主要是中证白酒指数，指数代码为399997。\n第四章 如何挑选适合投资的指数基金 价值投资理念 股神巴菲特的老师格雷厄姆对价值投资总结了三个理论，分别是价格与价值的关系、能力圈和安全边际。\n价格与价值的关系  股票有其内在价值，股票的价格围绕其内在价值上下波动。\n 巴菲特做了一个形象的比喻：股票的价值与价格就像主人在溜他的狗一样。小狗一会儿跑到主人的前面，一会儿跑到主人的后面，但是他们是同时到达目的地的。这是说股票的价格有时会比其内在价值高，有时会比内在价值低，但是长期来说它们是趋于一致的。\n能力圈 在投资时，你对自己所投资的产品越了解，能够判断出投资品种的价值，说明你的能力圈越大。做你能够做的事情。巴菲特强调重要的不是能力全的大小，而是自己是否清楚的知道能力圈的边界。即使能力圈很大，但如果你不知道它的边界，也就无法判断自己有没有能力做这项投资。\n安全边际 安全边际是指当前股价与股票内在价值的关系，任何人都不会花2块钱去买内在价值为1块钱的股票，使用多少钱买入才是安全的，这就是安全边际。\n 我们要用0.4元买价值1元的东西。——格雷厄姆\n 常见的估值指标 市盈率、盈利收益率、市净率、股息率\n市盈率 市盈率 (PE) = 公司市值 (P) / 公司盈利 (E)\n 如果公司盈利取上一年度的公司净利润，则算出来的是静态市盈率 如果公司盈利取最近4个季度的财报净利润，则算出来的是滚动市盈率 如果公司盈利取下一年度的公司净利润，则算出来的是动态市盈率  市盈率能够反映出我们愿意为获取1元的净利润所付出的代价，如果市盈率为10，表示我们愿意为这个公司1元盈利付出10元。\n通过市盈率能够估算出公司的市值。如果一个公司一年赚了100亿，市盈率为10，那么该公司的市值为1000亿。\n 市值代表我们买下这个公司理论上需要的资金量。很少有公司的盈利会在一年的时间里大幅波动，但是公司的市值可以在牛市的时候大幅上涨，在熊市的时候大幅下跌，原因就在于市盈率估值的大幅波动：牛市推高了投资者对单位盈利的估值。\n 由于市盈率是通过公司市值和公司盈利计算得出，**所以流通性好、盈利稳定的股票的市盈率才有参考价值。**因为流通性低的股票的价格会受到交易的影响，几万元的买卖交易就会使股票价格暴涨或是暴跌，导致你无法以市价来买到这支股票。\n同样的，**一个企业收益不稳定也不能使用市盈率来进行估值。**比如一些夕阳产业，企业的盈利是逐渐减少的，这会导致市盈率增加。这就是市盈率陷阱。还有一些周期性行业，拿证券行业举例，牛市时，企业盈利增加，市盈率突然减少，但这并不意味着低估值，这也是市盈率陷阱的表现。除了证券行业外还有钢铁、煤炭、航空、航运等行业。一般前文所说的宽基指数都是可以用市盈率来估值的。\n盈利收益率 盈利收益率 (EP) = 1 / 市盈率 = 公司盈利 (E) / 公司市值 (P)\n盈利收益率反映了如果我们把一家公司买下来，那么这家公司在一年中所带来的收益率。\n盈利收益率越高，公司市值越低，表示公司被低估。盈利收益率的适用场景和市盈率相同。\n市净率 市净率 (PB) = 公司市值 (P) / 公司净资产 (B)\n市净率反映的是每股股价与每股净资产的比率，也就是账面价值。\n影响市净率的因素：\n  净资产收益率 (REO)\n净资产收益率 = 净利润 / 净资产。代表着企业通过运作自己的资产产生了多大的收益，能够衡量企业的运作效率。收益越大REO就越高，运作效率也就越高。\n  资产的价值稳定性\n有的企业资产会随着时间而增值，有的企业资产会贬值。白酒时间越长价格越高，但是像电子产品，家用电器这些就会随着时间而贬值。总之，资产价值越稳定，市净率有效性越高。\n  无形资产\n无形的资产指的是企业的品牌营造、声誉好坏、工程师的能力等等。如果一个公司主要靠无形资产，那么市净率的参考价值不大。比如律师事务所、广告公司、互联网公司等等。\n  负债大增或亏损\n从公式上看，市净率与净资产呈负相关。如果公司的负债增加或营业亏损，也就意味着净资产减少，那么市净率就会波动。\n  总结来说就是有形资产较多并且资产价值稳定性高的行业比较适合使用市净率来进行估值，比如前文介绍过的强周期行业。还有就是在经纪危机时，企业的收益不稳定时，这时市盈率会突然发生变化，那么就可以用市净率来辅助估值。\n股息率 股息率 = 过去一年的公司现金分红 / 公司总市值\n分红率 = 过去一年的公司现金分红 / 公司总净利润，分红率是公司预先设置好的，是一个标准，代表了每年净收益的百分之多少用来分红\n 股息率与盈利收益率之间的关系：\n\t股息率 = 股息 / 市值\n\t分红率 = 股息 / 盈利 ===》 股息率 = 盈利收益率 * 分红率\n\t盈利收益率 = 盈利 / 市值\n 市值代表了股价，股价越低，股息率也就越高。除此之外，因为分红率是固定的，所以股息率与盈利收益率呈正相关。\n股息是净利润的一部分，如果一个公司的净利润在增长，那么其股息也在增长。所以你无需关注股价的高低，只要手里有这支股票就能够长期获得股息带来的现金流。\n盈利收益率法挑选指数基金 在盈利收益率高的时候开始定投，低的时候结束定投。\n那么多高算高、多低算低呢？\n格雷厄姆认为满足两个条件就算高：一是盈利收益率大于10%，二是盈利收益率要大幅度高于同期无风险利率。\n在中国，无风险利率可以参考10年国债收益率，2022年10年期国债收益率在2.5到3之间，远远低于10%。所以可以理解为，当盈利收益率大于10%的时候开始定投，低于10%时停止定投。\n当盈利收益率低于6.4%时，就需要分批卖出基金。 6.4%是来自债券基金的平均收益率。当指数基金带来的收益不足债券基金的收益时，显然债券基金会是更好的选择。\n 为什么我们要分批卖出而不是一次性卖出呢？\n这主要是为了分散风险，分批卖出的风险更低。比如说，我们可以把手中持有的基金总份额分成10份，每次卖出1份，分10次卖掉，通过这种方式就可以进一步分散风险。\n 书中举例说明了在中国股市和香港股市使用盈利收益率法来购买指数基金所获得的年收益率是惊人的。\n使用上证50和红利这两个指数基金从2004-2015年进行回测，结果显示上证50的年复合收益率为29.27%，红利为29.9%，可以说是相当高了。以恒生指数为例，在2008-2009年时出现了盈利收益率高于10%，带来的年复合收益率为39%。虽然如此高的收益率很大原因是因为过去几十年中国经济发展快速，但是即便发展速度放慢，使用这种方法进行定投所带来的年复合收益率还是相当可观的。\n 美联储是美国联邦储蓄系统，是美国最重要的金融机构。美联储有一个对股票市场的估值模型：FED模型，它是用美股的盈利收益率除以美国十年期国债利率。\n早在20世纪90年代，美联储就发布过非常多的分析报告，指出FED模型对美股收益有一定的预测作用。\n盈利收益率/十年期国债利率，这个数值越高，就代表股市相对债券市场的投资价值越高、未来股市的投资收益也会越高。这个数值越低，就代表股市相对债券市场的投资价值越低、未来股市的投资收益也会越低。\n 盈利收益率法的局限和适合品种\n这种方法进行估值只适用于流通性好、盈利稳定的指数。比如上证红利、中证红利、上证50、基本面50、上证50AH优选、央视50、恒生指数、恒生中国企业指数等。其中H股和恒生指数比较特殊，由于基金公司需要将人民币换成港币进行购买同时港股通需要缴纳比较高的分红税，所以恒生指数和H股指数需要将其原本的盈利收益率 * 0.9作为最终参考的盈利收益率。\n博格公式法挑选指数基金 指数基金之父约翰·博格提出的伯格公式法\n影响指数基金收益的三大因素 博格提出决定股市长期回报的三个关键因素为初始投资时的股息率、投资期内的市盈率变化和投资期内的盈利增长率。\n我们一个一个来说，首先股票的收益是由股价变化所带来的收益和分红收益组成。\n影响分红的因素就是股息率，这是第一个因素。\n根据市盈率的公式可以得出市值(也就是股价P) = 市盈率 (PE) * 公司净资产 (也就是盈利E)，如果股价增长只需市盈率或盈利增长或是两者同时增长，这是第二和第三个因素。\n博格公式：指数基金的收益公式 指数基金未来年复合收益率 = 指数基金投资初期的股息率 + 指数基金每年的市盈率变化率 + 每年的盈利变化率\n如何使用博格公式 我们的目的是要火的尽可能高的收益率，所以从公式上来看\n第一个参数股息率。一般来说，基金越是低估 (指数基金的价格低于指数基金的内在价格)，股息率越高。所以我们需要在股息率较高时买入。\n第二个参数市盈率变化率。一般来说，市盈率的变化是在某个范围之间来回波动。我们需要知道指数基金的历史市盈率变化范围，如果当前市盈率在历史上来看处于较低的位置，那么未来市盈率大概率是要上涨的。所以应该在市盈率处于历史低位时买入。\n第三个参数是盈利变化率。通常情况下，只要国家经济长期发展，盈利就会上涨，只不过是上涨的速度不一样罢了，但是长期来看都是上涨的。\n盈利收益率和博格公式的关系 由于股息率 = 分红率 * 盈利收益率，分红率一般上期不变，所以股息率较高时也就意味着盈利收益率较高，值得买入。\n市盈率 = 1 / 盈利收益率，所以当盈利收益率大于10%，市盈率小于10，处于历史低位。\n博格公式的变种 前面提到过，当企业收益不稳定时，市盈率就失去了其价值。这时我们可以用博格公式的变种来计算。\n指数基金未来年复合收益率 = 指数基金每年市净率变化率 + 指数基金每年净资产变化率\n相对于博格公式，其变种去掉了指数基金投资初期的股息率，并把市盈率换成了市净率。去掉股息率是因为股息率与分红率相关，既然公司的收益已经不稳定了，那自然也就不大可能再去分红，所以股息率也就没有作用了。\n使用博格公式的前提是公司盈利不稳定或是金融危机导致的市盈率激增从而使市盈率失去参考价值以及企业收益虽然减少但企业依然盈利这三种情况。\n对于长期亏损的公司，估值比较困难，所以应该趁早放弃。。。\n总结 总结一下上面所讲的方法，按照盈利可以将指数基金分为：\n 盈利稳定的指数（价值指数） 盈利呈高速增长态势的指数（成长指数） 盈利不稳定或有周期性变化但没有长期亏损记录的指数（周期指数） 长期亏损的指数（困境指数）   对于第一种可以直接用盈利收益率法来判断； 对于第二种可以使用博格公式，在市盈率处于历史低位时进行投资； 第三种可以使用博格公式变种，在市净率处于历史低位时进行投资； 第四种放弃投资  第五章 如何买卖指数基金：懒人定投法 什么是定投 定投的好处 定投的资金门槛低，开始定投不需要非常大的金额，大多数指数基金只需要一百元就可以开始定投\n投资时机没有限制，只需要每个月拿出工资的一部分用来投资指数基金\n定投可以分摊成本，如果你在净值为1元的时候买入了1000元，然后又在0.5元的时候买入了1000元，那么平均下来相当于你在0.67元的时候买入了2000元\n如何制定定投策略 定投策略包含何时定投，每次投资多少钱合适。\n作者指出按周或是按月定投差别不大，每周或每月的第几天投差别也不大，所以这完全根据自己的需求来定，只要确定了日期，那么就坚持定投下去。\n投资金额应该是每月结余的一半比较合适，如果你每月出去所有开销后还剩下4000元，那么可以将2000用于购买指数基金。你不能将剩余的所有钱全部投资到指数基金中，这样如果以后需要用钱，你就会被迫卖出一些指数基金。\n场内基金和场外基金的对比\n由于国内股市的收盘时间是下午3点，所以指数基金当日的收益也是在3点之后计算，当日的净值就是收盘时的净值。如果在当天3点之前申购指数基金，那么净值按照当日的净值计算，如果在下午3点之后申购，那么净值按照下一个交易日的收盘净值来计算。所以如果想要申购指数基金，最好是在下午3点之前进行申购。\n如何计算定投的年复合收益率 一次性投资收益率 一次性投资的收益率 = 收益 / 本金 * 100%\n如果一次性买了某个指数基金1万元，几年后全部卖出获得1.6万元，那么一次性投资收益率就是6000 / 10000 * 100% = 60%\n定投的总收益率 定投的总收益率 = (期末总资金 - 投入总本金) / 投入总本金\n定投的年复合收益率 将每月定投的资金数从上到下列出来，将最后的总资产写在最后一列，像下面这样\n然后使用excel中的IRR公式来计算，IRR（B2:B9），即可得到月复合收益率\n年复合收益率 = [(1 + 月复合收益率) ^ 12] - 1 * 100%\n提高定投收益的5个小技巧 省下就是赚到：降低交易基金的费用 从6个费用来说，分别是申购赎回费、买卖佣金、销售服务费、印花税、分红税和所得税\n申购赎回费 场内基金主要是买卖，场外基金是申购和赎回，虽然场内基金也可以申购赎回但是门槛较高。\n申购费是交易平台定的，赎回费与持有时间长短有关，持有时间越长，赎回费用越低。\n买卖佣金 场内基金会收取买卖佣金，不同的证券公司收取的买卖佣金也不同。\n销售服务费 如果场外基金频繁交易那么会不断收取申购赎回费，所以就出现了C类基金。这种基金不收取申购赎回费，但是会每年收取一定的销售服务费。\n不过如果不是非常频繁的交易，不需要买C类基金。\n印花税 当卖出股票时需要交一定的印花税。不过现在的政策是场内基金不需要交印花税。\n分红税 目前政策是基金分红不需要交税，但是如果指数基金的成分股进行分红就需要缴纳一定比例的分红税。分红税与指数基金持有成分股的时间长短有关。\n所得税 目前国内基金交易不需要交所得税。\n 针对以上费用的几个小技巧：\n（1）尽量选择费率比较低的场外和场内渠道。\n（2）不要过于频繁交易，以免产生较高的费用。\n（3）成立1年以上的指数基金，在分红税上会更有优势一些。\n 正确处理基金分红，能让长期收益上一个台阶 分红会随着企业的利润上涨而增加，同时企业每年都会拿出固定的份额来分红。\n分红后虽然会出现分红除权，也就是指数基金净值下跌，但是不必担心，后面还会进行分红填权，恢复净值。\n 在指数基金的低估区域，分红适合再投入；而当指数基金不低估的时候，分红可以投入到其他低估的品种上。这样就能把指数基金的分红充分利用起来，获得更高的长期收益。\n 定投的频率选择 从收益上来说，定投时间越短，周和月定投的收益差距就越大，时间越长，差距就越小，5-7年的差距不到1%，可以忽略。\n从心理上来说，如果你感觉这次定投距离下次定投的时间太长，那就选择按周定投。如果没什么感觉就按月定投。\n凭感觉判断买入时机并不是一个好的选择，因为你很容易受到其他因素的影响，这样反而导致一些错误的投资时机。\n定期不定额的投资方法 定投其实并不意味着每次投资的金额都要一样，一方面每月剩余的闲钱可能不同，另一方面有些指数基金估值变高时就需要减少或停止投资。\n如果当前的估值处于市场低位，那么就应该增加定投金额。对于不同的估值公式，计算投资金额的方法如下：\n 对于盈利收益率法，每月定投的金额 = 首次低估时的定投资金 * ( 当月的盈利收益率 / 首次定投时的盈利收益率 ) ^ n 对于博格公式法，每月定投的金额 = 首次低估时的定投资金 * ( 首次的市盈率 / 当月的市盈率 ) ^ n 对于博格公式的变种， 每月定投的金额 = 首次低估时的定投资金 * ( 首次的市净率 / 当月的市净率 ) ^ n  这里的n是一个放大器，从公式上说n越大，每月定投的金额就越大，收益也就越高。所以这个n是根据自身情况设定的，一般来说n = 1的收益就很不错了，所以一般将n确定为1。\n年龄与投资所能承担的风险相关，用100 - 年龄得到的就是适合投入指数基金的流动资金比例，如果你是22岁，那么你可以用每月工资的78%，或是流动资产的78%来进行定投。对于家庭来说可以计算平均年龄来进行定投，将资金分为若干份，用第一份进行定投，省下的买入货币基金或是债券基金，以后的每个月从货币基金中拿出一份来定投指数。\n第六章 构建属于自己的定投计划 构建属于自己的定投计划 1. 梳理自己的现金流 将自己每月的收入和支出分门别类的记下来，这样就能知道自己在哪些方面的开销较大，哪些方面的开支能够减少，对自己的收入和支出做到心中有数。在开销方面有以下3个小建议：\n 避免面子消费，把钱花在刀刃上 买必须用的东西，而不是可能用的上的东西 避免冲动消费  2. 挑选好基金 挑选处于低估值的基金\n3. 构建定投计划 确定在哪里买，定投的时间和频率\n4. 定期检查优化 在定投过程中做好记录（定投日期、指数基金品种、买入或卖出、指数基金价格、估值等信息），不断优化改进定投策略\n5. 行动起来 将计划列好并写下来，让自己更加清晰\n三个定投计划实例 1. 养老定投计划 这种计划的特点和养老金类似，前期只投入，当资金积累到足够产生源源不断的现金流，也就是每年的收益足以支持生活所需要的资金时，开始取用。\n这种计划适合选择高股息率的指数基金进行定投，因为分红是不受股价涨跌影响的。还有一点需要注意的是每年取出的资金量不能超过总市值的4%，这样能够长期取出。我们可以按照这个标准来指定定投计划。比如打算每年取出1万元用于生活资金，那么前期定投的指数基金需要达到25万的总市值。\n （1）确定每月投入到养老定投计划中的资金量。\n（2）挑选高股息率的指数基金，例如红利指数基金。\n（3）确定定投日、定投渠道等。再根据个人的需求，决定定投的年限（比如还有多少年退休，大约何时会需要取用资金等）。在此之前进行定投，资金只进不出，达到一定年限后，基金每年的分红收益就可以用来支付生活的相应开支。如果基金没有分红，则可以每次取不超过4%的基金份额卖出获得现金，这样也不会影响长期取用。\n（4）遵循指数基金的投资策略，在指数基金处于低估、值得投资的时候，开始我们的定投计划。\n 2. 加薪定投计划 对于年轻的上班族来说，努力工作是增加收入的最佳也是最根本的途径。你无法用投资使你的收入在短期内获得巨大的增长，相较而言，努力提升自己获得加薪更加容易。\n对于加薪定投计划有三个重点：\n 钱少也要存，节流为先 区分想要和必需 越早开始投资越好，但不要使用短期确定的开支  总结来讲就是想尽一切办法省钱，然后将剩下的钱按照比例投入指数基金当中\n （1）每月将可支配收入的60%用于定投指数基金（年轻人风险承受能力更强一些，可以多投入一些资金到指数基金中）。平时注意开源节流，将省下的小钱存入到货币基金中，每个月定投的时候一起投入。\n（2）挑选盈利收益率较高的指数基金。\n（3）确定定投日、定投渠道等。\n（4）遵循指数基金投资策略，当盈利收益率大于10%时，每个月1号进行定投；盈利收益率小于10%、大于6.4%时，停止定投，这部分计划定投的钱可以投入到货币基金或债券基金里；当盈利收益率小于6.4%时，将当时手中持有的基金份额分成10份，每个月卖出一份。\n 3. 子女教育定投计划 这项计划与养老定投和加薪定投都不同，主要用于子女上学或是辅导班等用途，这就要求需要使用时一定可以马上变现取出，并且一般使用时间是可以预见的，比如何时上幼儿园、小学等等。\n （1）确定教育定投计划的每月定投金额。\n（2）挑选高盈利收益率的指数基金。\n（3）确定定投日、定投渠道等。再根据孩子上学需要用钱的时间，确定定投的年限。\n（4）遵循盈利收益率法策略来定投。\n 第七章 做好家庭资产配置 货币基金：余额宝 货币基金是一个打理短期资金的工具，收益率要比银行的利率高，同时拥有较好的安全性合流动性。\n所有货币基金的单位净值都是1，也就是说申购10000元，就相当于买入了10000份货币基金。\n七日年化收益率和每万份基金单位收益是货币基金的两个收益指标：\n 七日年化收益率是指按照最近7天的收益来算的年化收益率 每万份收益是指每一万份货币基金一天所带来的收入  对于货币基金来说，比收益率更加重要的是其安全性和流动性，总的来说，你需要选择一只成立时间较长且没有亏损记录的、流通性好的、赎回期短的、申购门槛低的货币基金。\n货币基金的三个小技巧   避免周末和节假日前一天进行申购，下午3点前操作\n货币基金从T+1天起开始计算收益，所以如果是周五购买的话就需要等到下周一才开始计算收益。下午3点后购买同理。\n  同一家基金公司的货币基金与股票基金或者债券基金之间可以相互转换，不再收取申购费用，时间上也比先赎回原基金在申购新基金要短\n  在信用卡还款期之前用还款金额购买货币基金，个人感觉没什么用，来回折腾收益不大。\n  债券基金怎么买 货币基金只能购买397天以内的债券基金，但是债券基金没有限制。债券基金的收益比货币基金高，周期比货币基金时间长，同时风险也比货币基金大。货币基金看作是现金的替代品，债券基金就可以看作是定期存款的替代品。除此之外债券基金在申购和赎回时都会收取一定的费用。\n债券价格与银行利率呈负相关，利率越高，债券价格越低，收益率也低，利率越低，债券价格越高，收益率也高。\n债券基金的作用   可以作为没有低估值指数基金时的投资产品\n在牛市中后期没有低估值的指数基金能够投资时，可以选择债券基金来作为替代品。债券基金的表现与股市表现也呈现负相关性，股市好的时候债券就会差一些，股市差的时候债券就好一些。\n  中短期 ( 1 - 3年 ) 资金打理\n  作为资产配置来降低资产组合的波动\n当股市低迷时，债券基金表现较好，能够减少配置的波动，但同时也降低了收益\n  债券基金怎么投资 利率低位选短期，利率高位选长期 越是长期的债券基金受利率的影响越大，在利率较高时，债券基金收益较差，这时候需要选择长期债券基金，在利率较低时，债券基金收益较高，这时候就选择短期的债券基金。\n可以根据过去十年的国债利率的中位数来判断，当利率大于中位数时说明利率较高，当利率小于中位数时说明利率较低。\n随时可以投资，出现浮亏可以加仓低位买入 债券基金的波动较小，如果出现亏损的情况，可以适当继续买入来拉低成本。\n债券基金的品种有哪些 短期债券基金 大成景安短融A（000128）、嘉实超短债（070009）和融通通源短融A（000394）\n短期基金基本不收取申购赎回费，但会收取一定的销售服务费，一般为每年0.3%，按日计算，持有几天交几天，方便赎回。\n中长期债券基金 中长期债券基金可选范围较大，主要选取大的基金公司的、历史业绩好的、收益较稳定的基金，并且在利率较高时开始投资即可。\n总结   家庭资产配置中可以投资指数基金、债券基金和货币基金。指数基金的投资比例为100 - 家庭成员的平均年龄，剩下的可以投资债券基金和货币基金。\n  指数基金适合使用3到5年不用的闲钱来投入，债券基金适合使用1到3年内使用的钱来投入，货币基金主要使用平时零用钱进行投入。\n  当出现牛市后，指数基金的估值就会偏高，这时就不再适合继续持有指数基金，可以将指数基金卖掉继续投入低估值的指数基金或者债券基金中，如果利率过低，债券基金也不适合投资，那就投入到货币基金或者其他理财产品中。\n  第八章 长期投资的心理建设 下金蛋的鹅 寻找自己的鹅 “鹅”有很多种，低估值高分红的指数基金是鹅，有利息的银行理财也是鹅，可以往外出租的房子也是鹅。\n不同人熟悉的“鹅”也不一样，我们需要寻找自己熟悉的鹅，这样才能照顾好它，这就是“能力圈”。\n看好自己的鹅，不要放手 巴菲特卖出资产有三种情况：\n（1）基本面恶化：鹅下不出金蛋了。（国家宏观经济下降）\n（2）过于昂贵：有人愿意出大价钱买我们手里的鹅，价钱远比鹅能产出的金蛋多得多。（估值过高）\n（3）有更好的品种：手里的鹅卖出，可以买到另一只能下更多金蛋的鹅。（估值更低的品种，比较复杂）\n当你想要卖出资产时，先问问自己这三种情况有没有满足，我是不是正在杀掉自己的鹅\n复利效应：拥有更多的鹅 我们可以利用工作所得来买鹅，当鹅下了足够多的金蛋后，还可以用金蛋再买来下蛋的鹅，如此往复，这就是复利效应。\n寻找物美价廉的瘦鹅 如果能够买到一只便宜的瘦鹅，那么当瘦鹅恢复健康后，也能够获得不错的收益\n这样做前提有两个：第一，瘦鹅要足够便宜；第二，不能让瘦鹅饿死，要撑到恢复健康那一天\n指数基金的复利从哪里来 指数基金的复利体现在一下三点\n 低估值买入，高估值卖出 企业盈利再投入 指数基金分红再投入  一般来说后两点不可兼得，因为当企业盈利较好时说明市场处于高估值状态，此时分红再投入的效果较差，当企业盈利较差时，说明市场比较寒冷，处于低估值，这时是买入的好机会。\n买入低估值品种，为什么还会下跌 **短期来看指数基金的涨跌与估值的关系并不大，而是受供求关系影响的。**比如新闻爆出海水收到污染，大家都去抢食盐，于是食盐涨价，此时食盐的价格高出它的实际价值，处于高估，但是只要大家都去抢购食盐，那么食盐的价格就不会下降，这就是在受供求关系的影响。\n当股市上涨，持有股票的人不想卖，新入场的人都想买，这是供小于求，就会导致股价越来越高；同理当股市下跌时，持有的人都卖，但是大家都没人买，供过于求，导致加速下跌。\n有恒产者有恒心 只有耐得下性子来长期持有，才能真正收获\n","date":"2022-11-20T00:00:00Z","image":"https://WangZichen99.github.io/img/2022/11/cold_city.jpg","permalink":"https://WangZichen99.github.io/p/indexfundinvestmentguide/","title":"指数基金定投指南读书笔记"},{"content":"《小狗钱钱》读书笔记 前言  并非困难使我们放弃，而是因为我们放弃，才显得困难。\n 第一章 白色的拉布拉多犬  你自己必须真的有‘想要变得富有’这个愿望，所以你必须找到10个‘想要变得富有’的理由。\n 明确目标，找到支持你继续下去的动力。否则你可能过几天新鲜感消失之后，又会回到以前的生活轨迹上。\n第二章 梦想储蓄罐和梦想相册  第一，我建议你拿一本相册作为你的梦想相册。\n如果你只是抱着试试看的心态，那么你只会以失败告终，你会一事无成。‘尝试’纯粹是一种借口，你还没有做，就已经给自己想好了退路。不能试验，你只有两个选择——做或者不做。\n第二件你可以做的事，就是每天看几遍相册。成功的人之所以成功，就是因为他们一直梦想着自己成功的那一天，不停地想象着自己实现了理想时的情形。\n第三件事就是准备一个梦想储蓄罐，定期往里面放一些钱，直到足够完成梦想。\n 如果你有一个梦想，你需要时常关注你的梦想，给自己鼓励，并坚持为梦想努力付出直到梦想实现，这就是梦想储蓄罐和梦想相册的作用。太多人知道了做法之后没有实际行动，就像上面说的：你只有两个选择——做或者不做。\n第三章 达瑞，一个很会挣钱的男孩  你的自信程度决定了你是否相信自己的能力，是否相信你自己。假如你根本不相信你能做到的话，那么你就根本不会动手去做，而假如你不开始去做，那么你就什么也得不到。\n准备一个本子，给它取名叫‘成功日记’，然后把所有做成功的事情记录进去。你最好每天都做这件事，每次都写至少5条你的个人成果，任何小事都可以。开始的时候也许你觉得不太容易，可能会问自己，这件或那件事情是否真的可以算作成果。在这种情况下，你的回答应该是肯定的。\n第一，为别人解决一个难题，那么你就能赚到许多钱；第二，把精力集中在你知道的、能做的和拥有的东西上。\n 有些人不去做是因为没有足够的自信，他们问自己：我能行吗？我能做到吗？然后给自己否定的答案。\n增强自信的方法是记录成功日记，过一段时间就会发现，其实我们并没有自己想的那么糟糕，我们其实还不错，对吧！\n在美国，送报员将报纸放在花园的信箱里，冬天人们需要离开温暖的房屋到花园里拿报纸。每天将信箱中的报纸送上门就解决了这个问题，并且能够获取一些报酬。\n当你知道这个例子后，你应该想的是我周围有哪些可以解决的问题，而不是像\u0026quot;我们这没法送报纸\u0026quot;这种你根本无法做到的事情。\n将目光放眼于你能够做的事情上，你才能开始。\n第四章 堂兄的挣钱之道  你最好想清楚你喜欢做什么，然后再考虑你怎么用它来挣钱。我就是这样想出派送面包这项服务的。我喜欢骑自行车，而现在我可以边骑车边挣钱，这种感觉太美妙了。我每天都要敲几户人家的门，问他们要不要我送面包上门。\n 认真寻找机会，把注意力放在你喜欢做的事情上会更容易些。一个好的挣钱之道是建立在快乐和兴趣之上的，如果你的工作无法让你感觉到任何快乐，那上班的时间对于你来说一定是难过的。\n 无论在什么时候都不能把希望只寄托在一份工作上，它持续的时间不会像你设想的那么长，所以你要立即寻找另一份替代的工作。\n Linkedln和PayPal的创始人Reid Hoffman有一个非常著名的职业规划理论：ABZ理论。一个人在任何情况下和任何时候都应该有3个计划：ABZ计划。\nA计划，是你正在从事的工作，也是能长期从事下去的工作，值得你持续投入，并可以获得安全感，并且这份工作，你个人还很满意。\nB计划是你业余时间给自己其他能力的培训，或者兴趣爱好或梦想。B计划是除了A以外，你愿意长期投入精力的一项属于自己的小事业，必要的时候，它可以升级为A。\nZ计划，即个人资产，是你的保障，也是你的退路。假设有一天你的A、B计划全部落空，你的Z计划，可以保证你在未来某一段时间内继续保持现有的生活品质，能给你一次从头再来的机会。\n这表明在任何时候你需要明白任何东西都不可能是一成不变的，你需要应对未知的风险，因此Plan B也是非常重要的。\n第五章 钱钱以前的主人  首先，在遇到困难的时候，仍然要坚持自己的想法。一切正常的时候，每个人都能做到这一点。只有当真正的困难出现时才能见分晓。只有少数人能坚定不移地贯彻自己的计划。那些非常成功的人，甚至有能力在他们最困难的时候作出最杰出的表现。\n 在熊市到来时你是否能坚持自己原来的计划继续买入，还是急于将手里的仓位卖掉及时止损。为什么有的人能够在困难到来时继续坚持，而有的人就被困难吓倒，所有人都想赚钱，但你只能赚到自己认知范围以内的钱，赚认知范围之外的钱就是在赌，即便你真的赚到了，在未来的某个时间你还会全部亏回去，所以更重要的一点就是去学习财务知识，提高财商，提高你的认知范围。\n 其次，困难总是在不断地出现。尽管如此，你每天还是要不间断地去做对你的未来意义重大的事情。你为此花费的时间不会超过10分钟，但是就是这10分钟会让一切变得不同。大多数人总是在现有的水平上停滞不前，就是因为他们没有拿出这10分钟。他们总是期望情况能向有利于自己的方向转变，但是他们忽视了一点，那就是他们首先必须改变自己。\n当你决定做一件事情的时候，你必须在72小时之内完成，否则你很可能永远不会再做了。\n 还是在说行动力的问题，当你了解了一个不错的建议以后， 是否开始按照它去执行是成败的关键，做与不做完全是两个不同的结果。\n也许你每天只需花很少的时间就能有所改变，但是很多人总是只看到眼前的情况，他们在坚持几天之后感觉没什么效果，便扔到一边再也不管，过了一段时间之后，和你一起开始的人获得了效果，刺激了你，这时你开始后悔、嫉妒，凭什么他就能成功了。足够的量变才能产生质变，量变是一点一点积累起来的，差距也是一点一点被拉开的。\n第六章 爸爸妈妈犯下的错误 书中对陷入负债危机的人的几点建议：\n 第一，欠债的人应当毁掉所有的信用卡。\n第二，在许可范围内按最低的分期付款数目标准支付。虽然按期还更多的贷款会减少需要偿还的利息，但同时也会让你手忙脚乱，不堪重负，你的收入来源经不起一点风险，因为只要你的收入减少或是没有收入，就会还不上贷款。\n第三，将扣除生活费后剩下的钱的一半存起来，剩下的一半用于支付消费贷款。最好根本不申请消费贷款。\n第四，减少支出。\n 这里面我想说一下第四点，也就是减少支出。\n看似是一个很简单的建议，但在双十一、商场促销打折时有些人还是会不自觉的买一些\u0026quot;垃圾\u0026quot;回家，这些垃圾被放到家中的某个角落，然后就再也没有使用过。\n富人和穷人的区别是富人最后购买奢侈品，而穷人总是先购买，并且富人使用现金流购买，而穷人使用基本收入购买。有的人中了彩票，但在很短时间内把钱挥霍一空，甚至背上负债。\n如果你在不那么富有的时候不懂得节制消费，过一种低欲望的生活，那么你永远不可能真的富有。\n第七章 在金先生家  从前有一个年轻的农夫，他每天的愿望就是从鹅笼里捡一个鹅蛋当早饭。有一天，他竟然在鹅笼里发现了一只金蛋。当然，一开始他不相信这是真的。他想，也许是有人在捉弄他。为了谨慎起见，他把金蛋拿去让金匠看，可是金匠向他保证说，这只蛋完完全全是纯金铸成的。于是，农夫就卖了这只金蛋，然后举行了一个盛大的庆祝会。第二天清晨，他起了一个大早，赶到鹅笼处一看，那里果真又放着一个金蛋。这样的情况延续了好几天。可是这个农夫是一个贪婪的人，他对自己的鹅非常不满意，因为鹅没法向他解释是怎么下出金蛋的，否则也许他自己就可以制造金蛋了。他还气呼呼地想，这只懒惰的鹅每天至少应该下两只金蛋，现在这样的速度太慢了。他的怒火越来越大，最后，他终于怒不可遏地把鹅揪出鹅笼，劈成了两半。从那以后，他再也得不到金蛋了。\n 永远不要杀死你的鹅，当你的鹅足够肥美，你的鹅下的金蛋就足够你花费了，但前提是你先要有一只鹅，这只鹅就是你的存款。\n你需要定期将收入存起来，然后养大你的鹅。书中写了一种分配方式，将50%的收入存起来变成鹅，40%放进梦想储蓄罐，10%用于日常开销。这种分配方式不可能适合所有人，只是一个例子，如果你暂时无法确定自己如何分配收入，那就多读书去找到适合自己的分配方式吧！\n注意存起来的钱是你的鹅，如果你动用了这笔钱就意味着你杀掉了自己养的鹅。\n第十二章 陶穆太太归来  金钱是中性的，既不好，也不坏。只有当钱属于某一个人的时候，它才会对这个人产生好的影响或者坏的影响。钱可以被用于好的用途，也可以被用于坏的用途。一个幸福的人有了钱会更幸福；而一个悲观忧虑的人，钱越多，烦恼就越多。\n金钱就像一个放大镜，它帮你更充分地展现出你本来的样子。好人可以用钱做很多好事。而如果你是盗贼，那你很可能会把钱挥霍在一些蠢事上。\n 第十三章 巨大的危机  每当你觉得有些事情不好办的时候，你可以做一件事，只要翻一翻成功日记，你就会从过去的事情中找到证据，相信自己未来也有能力完成任何事情。\n 第十四章 投资俱乐部 投资时需要注意几点：\n 1．应该把钱投资在安全的地方。\n2．我的钱应该下很多“金蛋”。\n3．我们的投资应该简单明了，而且易于操作。\n 第十六章 俱乐部的投资行动  挑选基金时的注意事项：\n  基金应该至少有10年历史。假如它在这么长时间内一直有丰厚的利润，那我们可以认为，未来它也会运作良好。\n  应该选择大型的跨国股票基金。这种基金在世界各地购买股票，以此分散风险，所以十分安全。\n  对基金的走势图进行比较。我们应该观察在过去10年间哪些基金的年终利润最好。\n   第十七章 爷爷奶奶害怕风险 72公式：\n72 / 年收益率 = 收益翻倍的时间 (年)\n72 / 通货膨胀率 = 金钱贬值一半的时间 (年)\n十年前的100块和现在的100块的价值是不等的，因为存在着通货膨胀，如果银行的利率低于通货膨胀率，那就意味着你存到银行的钱，其实是在贬值的。所以保留未来3~5年需要花费的钱放在银行，其余的钱应该做一些投资，让金钱为你工作赚钱。\n十八章 大冒险的结局  不要为失去的东西而忧伤，而要对拥有它的时光心存感激。\n 自力更生——写给成年人的后记  我们推崇一种聪明的、简朴的生活方式。也就是说，宁愿购买一件一流产品，也不要不停地买许多的二流产品。\n而且，不要仅仅因为一件产品的外观不再时髦而新产品正在流行，就不断追逐新鲜的东西。\n 《小狗钱钱2》读书笔记 如果说《小狗钱钱》是在讲如何赚钱、理财，那么《小狗钱钱2》更侧重于如何做人，这两者是分不开的。\n第二章 白色石头  3条准则：\n  你应该更自制、更谦虚，特别是要更加成熟一点儿，这首先就表现在说话不要总是冒冒失失的。\n不友善一直就是缺乏教养和内心脆弱的标志，而且也显得很愚蠢。尊重他人和对人有礼貌是成功的重要因素。如果有人不喜欢你，很大程度上是因为你表现得不够友好。这会损害一个人的声誉，所以你不能那么做。另外，彬彬有礼也可以让以前并不信任你的人接纳你。\n  不能总是抱怨命运的不公。\n在我们的生活中不是所有的事情都是公平的，不公平的情况很常见。但这并不意味着你就应该放弃，因为成功并不取决于你是否受到了公平的对待。\n  永远不要在背后说别人的坏话。\n嘲笑他人是一件令人遗憾的事情。当你把目光都集中在别人的错误和缺点上时，就自然会忽略他们身上闪光的一面。而一个人只有具备了审视美好事物的能力，世界对他来说才会变得更加美好。\n    “如果甜甜圈外面的圆圈象征着金钱及一切可以用来消费的东西，那么它中间的那个圆孔又代表着什么意思呢？”\n“甜甜圈中间的圆孔代表着人类的内心，可是这内心本身却是无形的。许多人并不关心自己的内心，就是因为看不到它。对于他们来说，只有看得见的成功才是重要的。但你如果想要变得幸福，就不能只重视物质上的成功，还必须培养自己具有优秀的内心。”\n“优秀的内心就是那些人们不能用金钱买到的东西，但缺少了它们人们就无法获得幸福。这个内心就是你的品格，谦虚、感恩、尊敬老人及同情弱者都属于一个人的优秀品格。培养优秀品格的前提是，你应该认识到自己并不是孤零零地生活着，而是与他人同在。因此，你应该助人为乐，要通过自己的努力使得世界在他人眼中变得更加美好。”\n“没有圆孔的甜甜圈也就不再是甜甜圈了。同样的道理，缺少优秀品格的人其本质也是空虚的。只考虑金钱的人是不会真正幸福的。”\n“人们必须懂得每个人都要担负对这个世界的职责。如果不那样做的话就只会是一事无成。只有当你意识到并且履行了那份职责，你才能找到属于你自己的那块白色石头。那块石头上写有你新的名字，而这名字就是一个全新的幸福生活的标志。”\n 第四章 论文  “失败者总是无法成功，那是因为他们习惯于放弃；胜利者最终总是成功，则是因为他们永不放弃。”\n 第六章 寄宿学校  “你是一个美国人，这没错，但它只是你的一个归属。除此之外你还应该是一个世界公民，这就是你的第二归属。如果我们认为自己只有维护一个国家的义务，很有可能会引发相互间的争执甚至战争。但如果我们把自己看作是一个世界公民的话，就能够更好地理解与支持对方。”\n 第十章 7条准则  友好亲和\n 我有一个强烈的愿望，希望其他人能够像我一样生活美好而幸福。 我不会伤害任何人。我克制自己，不介入任何争端。 我谦虚有礼，尊重他人。我并不是永远正确。  “如果有人想给你一些东西，但是你并不接收，那这个东西就还属于那个给予者。在遇到愤怒和仇恨时，如果我们不接受，它们就还是属于原来的人所有。“\n勇于承担\n 遇事我能自我抉择。我能自行判断对某种情况应该作何反应。 我不受不公平之事的影响，而是将注意力集中在我能做的事情、我知道的知识和我拥有的东西之上。 我把责任推托给别人的同时，也把相应的权利转交给了对方。  “一个橘子，不管你是用手捏还是用脚踩还是用榨汁机，它给予你的都是橘子汁“\n善待他人\n 我只称赞他人。如果确实无法称赞他人，那就最好什么都不说。 我尽量不批评他人。如果不得不批评，也要用非常礼貌和友善的方式。 我将注意力集中在他人的优点和闪光点上。  “当你只看到光明的时候，你就会成为光明；而当你只看到垃圾的时候，你就会成为垃圾。”\n帮助给予\n 我祝愿自己遇到过的所有人都能一切顺利。 我送给某人礼物，因为我想表达自己对他的好感。 最美好的事情莫过于帮助他人。我总是在想自己能够帮助谁，没有什么比这更令人快乐。  “当我心情不好的时候，我会去想一想此时能够帮助谁或者可以给谁带去欢乐。要是这样的话，自己也会感觉好一些。”\n感恩之心\n 我总是心怀感恩，哪怕是对看似寻常的事情。 即便遇到了困难，我还是会关注值得感激的事物。 我对身边的人都充满感激之情，并非常享受和他们共度的美好时光。  “幸福之人的秘密就是有能力辨别出奇迹发生的时刻并对此抱有感激之情。”\n勤学不辍\n 如果我骄傲自满，那无异于说自己不必再学任何东西了。因此我应该保持谦恭好学的态度。 我不仅要阅读好的书籍、写成功日记和知识笔记，还要尽可能多地向他人学习。 我不拿自己和别人比较，而是尽我所能做到最好。  “我总是不断地学习，这是因为我要成为我有能力成为的那种人。”\n”如果有一天你不再进步，从此以后你演奏的就只是同一首乐曲。”\n值得信赖\n 我能否成功总是取决于自身培养出的习惯。 如果我是一个非常自律的人，我就能比那些虽有天赋但却懒惰散漫的人获得更多的成功。 我总是很守时。我信守为他人作出的承诺。  “在我们的头脑中有两个人：其中一个侏儒想引诱我们打破原先的计划，而另一个巨人则要求我们信守对自己作出的承诺。”\n ","date":"2022-10-16T10:22:34+08:00","image":"https://WangZichen99.github.io/img/2022/10/autumn_forest.jpg","permalink":"https://WangZichen99.github.io/p/puppymoney/","title":"小狗钱钱读书笔记"},{"content":"富爸爸穷爸爸读书笔记 第一章 富人不为钱工作  你做出决定的速度越快，抓住机会的可能性就越大——当然是在别人做决定之前。\n实践或模拟，才能学得最好。\n从尝试和错误中学习变得越来越重要，而书籍学习在现实世界中越来越没价值，大学教育不再能保证一份工作。\n生活中的很多事情是我们无法控制的。我学会了专注于我所能控制的：我自己。如果事情必须改变，首先要改变的就是我自己。\n购买或创造提供现金流的资产能使你的钱为你工作。高薪工作只意味着两件事：你在为钱工作，你所支付的税收可能会增加。\n人们的生活永远被这两种感觉所控制：恐惧和贪婪。\n 第二章 为什么要教授财务知识  富人得到资产而穷人和中产阶级得到负债。\n资产是能把钱放进我口袋里的东西，不管我工作与否；负债是把钱从我口袋取走的东西。\n一个受过高等教育且事业有成的人，同时也可能是财务上的文盲。\n财富就是支撑一个人生存多长时间的能力，或者说，如果我今天停止工作，我还能活多久？\n只要我把支出控制在资产项能够产生的现金之下，我就会越来越富有，也会有越来越多的非劳动收入。\n打牢地基，地基就是财务知识，你需要学习足够的财务知识，然后靠这些知识来买入资产，如果你想不学习任何财务知识就可以致富，那件造出来的就是一座斜塔。\n 第三章 关注自己的事业  关注自己的事业而不是工作，事业能够让你在失去工作后依然保持稳定的收入。\n开始关注你自己的事业，在继续工作的同时购买一些房地产，不要买负债。\n为了财务安全，人们需要关注自己的事业。富人关心的焦点是资产而其他人关心的是收入。存在财务问题的人经常耗费一生为别人工作，其中许多人在他们不能工作时就变得一无所有。净资产并不是一个确定的东西，这主要是因为在你开始出售资产时，你还要为获得的收入缴税。一旦把1美元投入了资产项，就不要让它出来。你应该这么想：1美元进入了你的资产项，就成为了你的雇员。关于钱，最妙的就是让它可以一天24小时不间断工作，还能为你的子孙后代服务。一个重要的区别就是：富人最后才买奢侈品，而穷人和中产阶级会先买奢侈品。穷人和中产阶级用他们的血汗钱和本应该留给子孙的遗产来购买奢侈品。\n 第四章 税收的历史和公司的力量  如果你愿意投资，税法将有利于你。如果你只想花钱及购买债务，税法就不会给你任何空隙——你可能会缴纳尽可能多的税款。换句话说就是需要交税的东西都不是资产，你需要避开它。\n财商是由4个方面的专业知识构成的：\n  会计\n会计就是财务知识或解读数字的能力。如果你想建立一个自己的商业帝国，财务知识是非常重要的。你管理的钱越多就要越精确，否则这幢大楼就会倒塌。这需要左脑来处理，是细节的部分。财务知识能帮助你读懂财务报表，还能让你辨别一项生意的优势和劣势。\n  投资\n投资是钱生钱的科学。投资涉及策略和方案，这需要右脑来做，是属于创造的部分。\n  了解市场\n了解市场是供给与需求的科学。这要求了解受感情驱动的市场的\u0026quot;技术面\u0026quot;。市场的另一个因素是\u0026quot;基本面\u0026quot;，或者说是一项投资的经济意义。一项投资究竟有无意义最终取决于当前的市场状况。\n  法律\n法律利用一个具有会计、投资和市场运营的企业会使你的财富实现爆炸性的增长。了解减税优惠政策和公司法的人会比雇员和小业主更快致富。这就像一个人在走，而另一个人在飞，久而久之这种差距就大了。\n   第五章 富人的投资 即便在学校获得了优秀的成绩，那并不代表你赚钱的能力，也不代表你的财商，因为学校从不教你如何赚钱。学习财务知识才是重要的。\n 一般有两种类型的投资者：(1) 进行一揽子投资的人（比如财务计划师）；(2) 自己创造投资机会的人（职业投资者）。\n如果你想成为第二种投资者，你就必须提升3种主要技能：\n 第一，如何找到别人错失的机会； 第二，如何筹集资金； 第三，如何把精明的人组织起来并雇佣他们为你工作。  风险无处不在，要学会驾驭风险，别总想回避风险。\n 第六章 学会不为钱工作 工人付出最大努力以免于被解雇，而雇主提供最低工资以防止工人辞职。\n追逐能使自己学到知识的工作，尽管工资可能会降低，而不是看起来前景很好很安稳的工作。\n不断学习专业之外的技能，比如销售。专业化会使你的职业选择降低，如果找不到专业相关的工作，你将无法获得收入。\n在获得收入之前需要学会付出。付出，然后获得。\n第七章 克服困难 没有百发百中的世界冠军，也没有永远赚钱的投资人。失败是激励你的东西，不要被失败击倒。\n不让谣言和杞人忧天的怀疑加剧我们的恐惧和疑虑。在做出决定的时候，周围总有一些声音让你对自己的决定产生怀疑，当你顺从了这些声音，机会就从你手中溜走了。在遇到问题时想当然，就会被心里的忧虑所干扰，导致你一无所获，而是应该付出行动解决心中的疑虑；比如在购买房地产时，很多人不想自己修理房子的问题，那么就应该找到一个靠谱的物业来帮你管理你的房产；在股票市场你不想亏钱，那就应该为了盈利而投资，而不是为了避免损失而投资。\n克服懒惰，不要被花钱的负罪感所绑架，你应该多问自己如何才能支付起你想要的东西。\n先支付给自己，后支付给债务。\n时刻保持谦虚，be humble！\n第八章 开始行动  找一个超现实的理由——精神的力量：你需要明白自己为什么想要变得有钱，自己想要什么，不想要什么，这将在你无助的时候给你力量，使你坚持下去，渡过难关 每天作出选择——选择的力量：在确定目标后，你是选择虚心的学习投资知识，提高自己的财商，还是选择继续以自我感觉良好的方式去任劳任怨的工作，每个人都有选择的权利，不同的是选择的结果 慎重的选择朋友——关系的力量：如果你想变得富有，你需要结交有钱的朋友，从他们身上学到你应该做什么，同时富人掌握着普通人没有的信息。从你穷困潦倒的朋友身上你能够知道自己不应该做什么，他们过着小鸡式的生活，杞人忧天似的告诉你这样做有多么大的风险，如果你听从了他们的话，你也会变成小鸡式的人。在市场中，群众的感知是极其缓慢的，当大部分人开始看到赚钱的机会之后，富人早就已经赚到足够多的钱去寻找新的风口了，所以盲目跟随是最愚蠢的投资方式！！！ 掌握一种模式，然后再学习一种新的模式——快速学习的力量：学习不同领域的知识，学习不同的投资方法 首先支付自己——自律的力量：首先支付自己的意思是，首先将你的收入支付到你的投资中去，支付到你的资产中去，而不是首先支付你的负债或是买一些无关紧要的奢饰品。降低你的支出，才是积累财富最关键的地方，保持低欲望的生活。 给你的经纪人以优厚的报酬——好建议的力量：经纪人是专业性很高的职业，一个好的经纪人能让你的投资事半功倍，在选择经纪人时，你需要知道他究竟有多少资产，有的经纪人把自己吹的天花乱坠，但实际上他们根本没有什么资产。一个好的经纪人不仅能够帮你赚钱，同时还愿意教你，他们是你最大的资产，学会慷慨的对待你的经纪人，学会如何管理你的经纪人 做一个印第安给予者——无私的力量：当看到一个白人很冷时，印第安人会给他一条毯子，但是白人以为这是一个礼物，当印第安人要回毯子时，白人感到愤怒，印第安人感到失望。在投资中要清楚何时能够收回本钱，当你收回本钱后，就无需担心亏损 用资产来购买奢侈品——专注的力量：前面已经讲过，大部分穷人贫穷的根本原因是他们不懂得节制花钱，这就是为什么通常中了大奖的人会在很短时间内将这笔钱挥霍的一分不剩，穷人先购买奢侈品，而富人选择最后购买奢侈品。当你有欲望得到某些东西时，创造足够的资产去支付它，而不是直接去购买，成为金钱的主人，让金钱为你工作 对英雄的崇拜——神话的力量：榜样的力量是强大的，将什么样的人作为榜样，你就会成为什么样的人 先予后取——给予的力量：先付出，后回报  第九章：还想要更多吗？这里有一些要做的事情  停下你手里的活儿：在学习到新的财务知识后，你需要不断反思自己的投资方式，哪些是有效的，哪些是无效的 寻找新的思想：学习不同思想的书，并付出行动 找一些做过你想做的事情的人：请他们一起共进午餐，请教一些问题 参加辅导班、阅读和研讨会：还是不断学习，各种方式学习 提出多份报价：作为买家，大多数时候给出的报价都要远远高于商品的实际价格，学会报价还价、谈判拒绝是极其重要的 每月在某一地区慢跑、散步或驾车10分钟左右：这样做是为了发现周围的变化，发现投资的机会。一项交易想要盈利必须包括两个条件：廉价和变化 购买特价商品：交易盈利的第一点是廉价，只有买入廉价的资产才有赚钱的空间 关注适当的地方：还是说你应该学习 首先寻找要买进的人，然后才去找想卖出的人：先有需求，后有供给，这样你才能在交易中赚钱 考虑大生意：小规模的投资是开始，如果你想完成你财富自由目标，那就要寻找大规模的生意，特别是对于零售来说，大规模的生意利润更大 学习前人经验 行动的人总会击败不行动的人  ","date":"2022-10-15T15:48:50+08:00","image":"https://WangZichen99.github.io/img/2022/10/autumn_forest_mountain.jpg","permalink":"https://WangZichen99.github.io/p/richfatherpoorfather/","title":"富爸爸穷爸爸读书笔记"},{"content":"Redis 笔记 概述 Redis能干嘛  内存存储、持久化 高速缓存 发布订阅系统 地图信息分析 计时器、计数器（浏览量） \u0026hellip;  Windows安装Redis  下载地址：https://github.com/tporadowski/redis/releases 下载解压后打开redis-server.exe和redis-cli.exe  ​\t​\t输入ping测试连接，set设置key value，get获取  Linux安装Redis   下载安装包https://redis.io/download/\n  tar -zxvf redis-7.0.4.tar.gz 解压\n  yum install gcc-c++安装环境\n  进入redis解压目录make \u0026amp;\u0026amp; make install\n  redis默认安装目录：/usr/local/bin\n  redis默认不是后台启动，修改配置daemonize为yes\n启动redis服务：进入/usr/local/bin/，执行redis-server ../src/redis-7.0.4/redis.conf 客户端连接redis：redis-cli -p 6379 查看redis进程：ps -ef|grep redis 关闭redis服务：shutdown，exit    ​\t性能测试 redis-benchmark是一个压力测试工具\n 测试100个并发连接，100000个请求  redis-benchmark -h localhost -p 6379 -c 100 -n 100000    基础知识  默认16个数据库，默认使用第0个  1 2 3 4 5 6 7 8 9  select \u0026lt;dbid\u0026gt; #切换数据库 dbsize #查看数据库大小 keys * #查看数据库中所有key flushdb #清空当前数据库 flushall #清空所有数据库   Redis是单线程的  官方表示Redis是基于内存操作，CPU不是Redis的性能瓶颈，Redis的瓶颈是根据机器的内存和网路带宽，既然可以用单线程实现，就使用了单线程 单线程为什么还这么快？  误区1：高性能的服务器一定是多线程的 误区2：多线程一定比单线程效率高 对于Redis来说，所有数据全部放在内存中，对于内存系统来说不需要上下文切换，所以单线程比多线程效率更高      五大数据类型 Redis-Key 1 2 3 4 5 6 7 8 9  exists {key} #当前数据库是否存在某个key move {key} {db} #将key移动到数据库db中 expire {key} {seconds} #设置key的过期时间为seconds秒 ttl {key} #查看key的剩余过期时间 type {key} #查看key的类型   String (字符串) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  set {key} {value} get {key} {value} append {key} {value} #在key值中追加value，如果key不存在就相当于set key strlen {key} #查看key的长度 incr {key} #key值自增1 decr {key} #key值自减1 incrby {key} {increment} #key值自增increment decrby {key} {increment} #key值自减increment getrange {key} {start} {end} #截取key值的start到end setrange {key} {start} {value} #start开始替换key值为value setex {key} {seconds} {value} #设置key值为value，seconds秒后过期，setex (set with expire) setnx {key} {value} #如果key不存在，设置key值为value，setnx (set if not expire) mset {key1} {value1} {key2} {value2} #批量设置 mget {key1} {key2} #批量获取 msetnx {key1} {value1} {key2} {value2} #如果所有key都不存在，批量设置 mset {object}:{id}:{field} #key命名方式 getset {key} {value} #先获取key值，再设置key   List (列表) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  lpush {key} {value} #左插入value rpush {key} {value} #右插入value lrange {key} {start} {end} #获取从start到end的值 lpop {key} #移除list左侧的值 rpop {key} #移除list右侧的值 lindex {key} {index} #获取下标为index的值 llen {key} #获取list长度 lrem {key} {count} {value} #移除key中count个值为value的元素 ltrim {key} {start} {end} #从start到end截取list rpoplpush {source} {destination} #移除source中的右侧值插入destination中左侧 lset {key} {index} {item} #将list中下标为index的元素替换为item linsert {key} [before|after] {pivot} {element} #在第一个值为pivot的元素前或后面插入element   Set (集合)  集合中的元素不能重复  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  sadd {key} {members...} #向集合中添加元素 smembers {key} #查看集合中的元素 sismember {key} {member} #查看元素是否存在集合中 scard {key} #查看集合中的元素个数 srem {key} {member} #移除集合中的元素 srandmember {key} (count) #随机输出集合中的count个元素 spop {key} (count) #随机弹出集合中的count个元素 smove {source} {destination} {member} #将一个集合中的元素移动到另一个集合 sdiff {key} {key...} #查看多个集合与第一个集合的差集 sinter {key} {key...} #查看多个集合的交集 sunion {key} {key...} #查看多个集合的并集   Hash (哈希) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  hset {key} {field} {value} #设置键和值 hget {key} {field} #获取键的值 hmset {key} {field value...} #设置hash的多个键和值 hmget {key} {field...} #获取hash的多个键的值 hgetall {key} #获取hash的所有键和值 hdel {key} {field...} #删除键 hlen {key} #获取hash长度 hexists {key} {field} #判断hash的键是否存在 hkeys {key} #获取hash的所有键 hvals {key} #获取hash的所有值 hincrby {key} {field} {increment} #hash的键自增increment hsetnx {key} {field} {value} #如果hash中没有这个键就创建   Zset (有序集合)  一般用来做排行榜  1 2 3 4 5 6 7 8 9 10 11 12 13  zadd {key} {score} {value} #添加value zrange {key} {start} {end} #获取zset中的值 zrangebyscore {key} {min} {max} [withscores] #升序排列zset中score在min到max之间的元素，withscores表示打印份数 zrevrange {key} {start} {end} [withscores] #根据score降序排列zset中下标为start到end的元素 zrem {key} {member...} #移除zset中的某个元素 zcard {key} #获取集合中的个数 zcount {key} {min} {max} #获取分数在min到max之间的元素个数   三种特殊数据类型 Geospatial (地理位置)  一般用来进行附近好友的展示  1 2 3 4 5 6 7 8 9 10 11  geoadd {key} {longitude} {latitude} {member} #添加地理位置 geopos {key} {member...} #获取指定成员的位置信息 geodist {key} {member1} {member2} [m|km|mi|ft] #获取两个成员之间的绝对距离，单位：m（米）、km（千米）、mi（英里）、ft（英尺） georadius {key} {longitude} {latitude} {radius} [m|km|mi|ft] [withcoord|withdist] [count num] #获取圆形区域内的所有成员 withcoord返回成员经纬度，withdist返回距离圆心的直线距离 georadiusbymember {key} {member} {radius} [m|km|mi|ft] [withcoord|withdist] [count num] #获取圆形区域内的所有成员 geohash {key} {member...} #返回成员的hash值   Hyperloglog (基数统计)  一般用来进行用户访问统计。如果容错，可以使用hyperloglog，如果不容错，则使用set集合来存储用户id进行统计  1 2 3 4 5  pfadd {key} {element...} #添加元素 pfcount {key} #返回去重后的元素数量 pfmerge {distkey} {sourcekey...} #合并所有sourcekey并去重得到distkey   Bitmaps (位图)  统计用户信息（是否活跃、是否登录），365天打卡信息等  1 2 3 4 5  setbit {key} {offset} {value} #设置第offset位的值value getbit {key} {offset} #获取第offset位的值 bitcount {key} [start] [end] #从start到end计数   Redis事务  redis单条命令是原子性的，但是事务是不保证原子性的 redis事务没有隔离级别的概念  1  ------ 队列 命令1 命令2 命令3 执行 ------    所有命令在事务中没有直接被执行，只有发起执行命令的时候才会被执行  1 2 3 4 5 6 7  multi #开启事务 ... #命令入队 exec #执行事务 discard #放弃事务    编译型异常（代码有问题，命令有错），事务中所有命令都不会被执行\n运行时异常（1 / 0），错误命令抛出异常，其他命令正常执行\n Redis实现悲观锁乐观锁 悲观锁：\n 很悲观，认为什么时候都会出问题，做什么事情都要加锁  乐观锁：\n 很乐观，认为什么时候都不会出问题，所以不会上锁，更新数据的时候判断一下，是否有人修改过这个数据   获取version 更新的时候比较version  1 2 3  watch {key} #加乐观锁监视key，如果监视key的值和事务执行前key的值不一致就报错，无法执行事务 unwatch #解除监视 (解锁)，事务执行后会自动解锁   Jedis   导入依赖：\n1 2 3 4 5  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;redis.clients\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jedis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.3.0-m2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;     测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  public class JedisTest { @Test public void test() { Jedis jedis = new Jedis(\u0026#34;127.0.0.1\u0026#34;, 6379); jedis.flushDB(); // String相关命令测试  stringTest(jedis); // 事务测试  multiTest(jedis); } private void multiTest(Jedis jedis) { jedis.set(\u0026#34;hello\u0026#34;, \u0026#34;init\u0026#34;); jedis.watch(\u0026#34;hello\u0026#34;); //监视hello，如果值发生变化，事务不执行  jedis.set(\u0026#34;hello\u0026#34;, \u0026#34;before\u0026#34;); Transaction transaction = jedis.multi(); try { transaction.set(\u0026#34;multi\u0026#34;, \u0026#34;test\u0026#34;); // int i = 1 / 0; //运行时异常，错误命令抛出异常，其他命令正常执行  transaction.exec(); } catch (Exception e) { e.printStackTrace(); transaction.discard(); } finally { System.out.println(jedis.get(\u0026#34;multi\u0026#34;)); jedis.close(); } } private void stringTest(Jedis jedis) { System.out.println(jedis.ping()); System.out.println(jedis.set(\u0026#34;name\u0026#34;, \u0026#34;wzc\u0026#34;)); System.out.println(jedis.get(\u0026#34;name\u0026#34;)); System.out.println(jedis.exists(\u0026#34;name\u0026#34;)); System.out.println(jedis.keys(\u0026#34;*\u0026#34;)); System.out.println(jedis.append(\u0026#34;age\u0026#34;, \u0026#34;22\u0026#34;)); System.out.println(jedis.incrBy(\u0026#34;age\u0026#34;, 2)); System.out.println(jedis.strlen(\u0026#34;name\u0026#34;)); System.out.println(jedis.getrange(\u0026#34;name\u0026#34;, 0, -1)); System.out.println(jedis.setrange(\u0026#34;name\u0026#34;, 0, \u0026#34;robin\u0026#34;)); System.out.println(jedis.get(\u0026#34;name\u0026#34;)); System.out.println(jedis.mset(\u0026#34;play\u0026#34;, \u0026#34;game\u0026#34;, \u0026#34;climb\u0026#34;, \u0026#34;mountain\u0026#34;)); System.out.println(jedis.mget(\u0026#34;play\u0026#34;, \u0026#34;climb\u0026#34;)); } }     SpringBoot整合Redis  说明：在Spring2.X之后，原来使用的Jedis被替换为了Lettuce\nJedis采用直连，多线程操作不安全，解决方法是使用Jedis Pool连接池，BIO模式\nLettuce采用Netty，实例可以在多个线程中共享，不存在线程不安全的情况，NIO模式\n 源码分析：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  public class RedisAutoConfiguration { public RedisAutoConfiguration() { } @Bean @ConditionalOnMissingBean(name = {\u0026#34;redisTemplate\u0026#34;}) @ConditionalOnSingleCandidate(RedisConnectionFactory.class) //默认的RedisTemplate没有过多的设置，由于泛型不是\u0026lt;String, Object\u0026gt;，可以自己定义redisTemplate替换默认的  public RedisTemplate\u0026lt;Object, Object\u0026gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) { RedisTemplate\u0026lt;Object, Object\u0026gt; template = new RedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; } @Bean @ConditionalOnMissingBean @ConditionalOnSingleCandidate(RedisConnectionFactory.class) //由于String是Redis中最常使用的类型，所以单独提出来了一个template  public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) { StringRedisTemplate template = new StringRedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; } }     导入依赖\n1 2 3 4  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;     配置连接\n1 2 3 4  spring:redis:host:127.0.0.1port:6379    Redis.conf详解 配置文件位置：/usr/local/src/redis-7.0.4/redis.conf\n 配置文件中units对大小写不敏感  redis配置文件可以引用一些外部配置   绑定ip和端口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132  ################################## NETWORK ##################################### # By default, if no \u0026#34;bind\u0026#34; configuration directive is specified, Redis listens # for connections from all available network interfaces on the host machine. # It is possible to listen to just one or multiple selected interfaces using # the \u0026#34;bind\u0026#34; configuration directive, followed by one or more IP addresses. # Each address can be prefixed by \u0026#34;-\u0026#34;, which means that redis will not fail to # start if the address is not available. Being not available only refers to # addresses that does not correspond to any network interface. Addresses that # are already in use will always fail, and unsupported protocols will always BE # silently skipped. # # Examples: # # bind 192.168.1.100 10.0.0.1 # listens on two specific IPv4 addresses # bind 127.0.0.1 ::1 # listens on loopback IPv4 and IPv6 # bind * -::* # like the default, all available interfaces # # ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the # internet, binding to all the interfaces is dangerous and will expose the # instance to everybody on the internet. So by default we uncomment the # following bind directive, that will force Redis to listen only on the # IPv4 and IPv6 (if available) loopback interface addresses (this means Redis # will only be able to accept client connections from the same host that it is # running on). # # IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES # COMMENT OUT THE FOLLOWING LINE. # # You will also need to set a password unless you explicitly disable protected # mode. # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ bind 127.0.0.1 -::1 #绑定本地的IPV4和IPV6连接，::1代表IPV6地址 # By default, outgoing connections (from replica to master, from Sentinel to # instances, cluster bus, etc.) are not bound to a specific local address. In # most cases, this means the operating system will handle that based on routing # and the interface through which the connection goes out. # # Using bind-source-addr it is possible to configure a specific address to bind # to, which may also affect how the connection gets routed. # # Example: # # bind-source-addr 10.0.0.1 # Protected mode is a layer of security protection, in order to avoid that # Redis instances left open on the internet are accessed and exploited. # # When protected mode is on and the default user has no password, the server # only accepts local connections from the IPv4 address (127.0.0.1), IPv6 address # (::1) or Unix domain sockets. # # By default protected mode is enabled. You should disable it only if # you are sure you want clients from other hosts to connect to Redis # even if no authentication is configured. protected-mode yes #保护模式，默认开启 # Redis uses default hardened security configuration directives to reduce the # attack surface on innocent users. Therefore, several sensitive configuration # directives are immutable, and some potentially-dangerous commands are blocked. # # Configuration directives that control files that Redis writes to (e.g., \u0026#39;dir\u0026#39; # and \u0026#39;dbfilename\u0026#39;) and that aren\u0026#39;t usually modified during runtime # are protected by making them immutable. # # Commands that can increase the attack surface of Redis and that aren\u0026#39;t usually # called by users are blocked by default. # # These can be exposed to either all connections or just local ones by setting # each of the configs listed below to either of these values: # # no - Block for any connection (remain immutable) # yes - Allow for any connection (no protection) # local - Allow only for local connections. Ones originating from the # IPv4 address (127.0.0.1), IPv6 address (::1) or Unix domain sockets. # # enable-protected-configs no # enable-debug-command no # enable-module-command no # Accept connections on the specified port, default is 6379 (IANA #815344). # If port 0 is specified Redis will not listen on a TCP socket. port 6379 #端口设置 # TCP listen() backlog. # # In high requests-per-second environments you need a high backlog in order # to avoid slow clients connection issues. Note that the Linux kernel # will silently truncate it to the value of /proc/sys/net/core/somaxconn so # make sure to raise both the value of somaxconn and tcp_max_syn_backlog # in order to get the desired effect. tcp-backlog 511 # Unix socket. # # Specify the path for the Unix socket that will be used to listen for # incoming connections. There is no default, so Redis will not listen # on a unix socket when not specified. # # unixsocket /run/redis.sock # unixsocketperm 700 # Close the connection after a client is idle for N seconds (0 to disable) timeout 0 # TCP keepalive. # # If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence # of communication. This is useful for two reasons: # # 1) Detect dead peers. # 2) Force network equipment in the middle to consider the connection to be # alive. # # On Linux, the specified value (in seconds) is the period used to send ACKs. # Note that to close the connection the double of the time is needed. # On other kernels the period depends on the kernel configuration. # # A reasonable value for this option is 300 seconds, which is the new # Redis default starting with Redis 3.2.1. tcp-keepalive 300 # Apply OS-specific mechanism to mark the listening socket with the specified # ID, to support advanced routing and filtering capabilities. # # On Linux, the ID represents a connection mark. # On FreeBSD, the ID represents a socket cookie ID. # On OpenBSD, the ID represents a route table ID. # # The default value is 0, which implies no marking is required. # socket-mark-id 0     通用配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107  ################################# GENERAL ##################################### # By default Redis does not run as a daemon. Use \u0026#39;yes\u0026#39; if you need it. # Note that Redis will write a pid file in /var/run/redis.pid when daemonized. # When Redis is supervised by upstart or systemd, this parameter has no impact. daemonize yes #默认以守护进程方式运行 # If you run Redis from upstart or systemd, Redis can interact with your # supervision tree. Options: # supervised no - no supervision interaction # supervised upstart - signal upstart by putting Redis into SIGSTOP mode # requires \u0026#34;expect stop\u0026#34; in your upstart job config # supervised systemd - signal systemd by writing READY=1 to $NOTIFY_SOCKET # on startup, and updating Redis status on a regular # basis. # supervised auto - detect upstart or systemd method based on # UPSTART_JOB or NOTIFY_SOCKET environment variables # Note: these supervision methods only signal \u0026#34;process is ready.\u0026#34; # They do not enable continuous pings back to your supervisor. # # The default is \u0026#34;no\u0026#34;. To run under upstart/systemd, you can simply uncomment # the line below: # # supervised auto # If a pid file is specified, Redis writes it where specified at startup # and removes it at exit. # # When the server runs non daemonized, no pid file is created if none is # specified in the configuration. When the server is daemonized, the pid file # is used even if not specified, defaulting to \u0026#34;/var/run/redis.pid\u0026#34;. # # Creating a pid file is best effort: if Redis is not able to create it # nothing bad happens, the server will start and run normally. # # Note that on modern Linux systems \u0026#34;/run/redis.pid\u0026#34; is more conforming # and should be used instead. pidfile /var/run/redis_6379.pid #如果以守护进程方式运行，需要指定一个pid进程文件 # Specify the server verbosity level. # This can be one of: # debug (a lot of information, useful for development/testing) # verbose (many rarely useful info, but not a mess like the debug level) # notice (moderately verbose, what you want in production probably) # warning (only very important / critical messages are logged) loglevel notice #日志级别 # Specify the log file name. Also the empty string can be used to force # Redis to log on the standard output. Note that if you use standard # output for logging but daemonize, logs will be sent to /dev/null logfile \u0026#34;\u0026#34; #日志的文件名 # To enable logging to the system logger, just set \u0026#39;syslog-enabled\u0026#39; to yes, # and optionally update the other syslog parameters to suit your needs. # syslog-enabled no # Specify the syslog identity. # syslog-ident redis # Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7. # syslog-facility local0 # To disable the built in crash log, which will possibly produce cleaner core # dumps when they are needed, uncomment the following: # # crash-log-enabled no # To disable the fast memory check that\u0026#39;s run as part of the crash log, which # will possibly let redis terminate sooner, uncomment the following: # # crash-memcheck-enabled no # Set the number of databases. The default database is DB 0, you can select # a different one on a per-connection basis using SELECT \u0026lt;dbid\u0026gt; where # dbid is a number between 0 and \u0026#39;databases\u0026#39;-1 databases 16 #默认数据库数量 # By default Redis shows an ASCII art logo only when started to log to the # standard output and if the standard output is a TTY and syslog logging is # disabled. Basically this means that normally a logo is displayed only in # interactive sessions. # # However it is possible to force the pre-4.0 behavior and always show a # ASCII art logo in startup logs by setting the following option to yes. always-show-logo no #是否总是显示logo # By default, Redis modifies the process title (as seen in \u0026#39;top\u0026#39; and \u0026#39;ps\u0026#39;) to # provide some runtime information. It is possible to disable this and leave # the process name as executed by setting the following to no. set-proc-title yes # When changing the process title, Redis uses the following template to construct # the modified title. # # Template variables are specified in curly brackets. The following variables are # supported: # # {title} Name of process as executed if parent, or type of child process. # {listen-addr} Bind address or \u0026#39;*\u0026#39; followed by TCP or TLS port listening on, or # Unix socket if only that\u0026#39;s available. # {server-mode} Special mode, i.e. \u0026#34;[sentinel]\u0026#34; or \u0026#34;[cluster]\u0026#34;. # {port} TCP port listening on, or 0. # {tls-port} TLS port listening on, or 0. # {unixsocket} Unix domain socket listening on, or \u0026#34;\u0026#34;. # {config-file} Name of configuration file used. # proc-title-template \u0026#34;{title} {listen-addr} {server-mode}\u0026#34;     快照 (SNAPSHOTTING)\n与持久化相关，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94  ################################ SNAPSHOTTING ################################ # Save the DB to disk. # # save \u0026lt;seconds\u0026gt; \u0026lt;changes\u0026gt; [\u0026lt;seconds\u0026gt; \u0026lt;changes\u0026gt; ...] # # Redis will save the DB if the given number of seconds elapsed and it # surpassed the given number of write operations against the DB. # # Snapshotting can be completely disabled with a single empty string argument # as in following example: # # save \u0026#34;\u0026#34; # # Unless specified otherwise, by default Redis will save the DB: # * After 3600 seconds (an hour) if at least 1 change was performed # * After 300 seconds (5 minutes) if at least 100 changes were performed # * After 60 seconds if at least 10000 changes were performed # # You can set these explicitly by uncommenting the following line. # # save 3600 1 300 100 60 10000 # 如果一小时内至少有一次修改、五分钟内至少100次修改、一分钟内至少10000次修改则进行rdb持久化 # By default Redis will stop accepting writes if RDB snapshots are enabled # (at least one save point) and the latest background save failed. # This will make the user aware (in a hard way) that data is not persisting # on disk properly, otherwise chances are that no one will notice and some # disaster will happen. # # If the background saving process will start working again Redis will # automatically allow writes again. # # However if you have setup your proper monitoring of the Redis server # and persistence, you may want to disable this feature so that Redis will # continue to work as usual even if there are problems with disk, # permissions, and so forth. stop-writes-on-bgsave-error yes #如果持久化出错，是否继续工作 # Compress string objects using LZF when dump .rdb databases? # By default compression is enabled as it\u0026#39;s almost always a win. # If you want to save some CPU in the saving child set it to \u0026#39;no\u0026#39; but # the dataset will likely be bigger if you have compressible values or keys. rdbcompression yes #是否压缩rdb文件，需要消耗一些cpu资源 # Since version 5 of RDB a CRC64 checksum is placed at the end of the file. # This makes the format more resistant to corruption but there is a performance # hit to pay (around 10%) when saving and loading RDB files, so you can disable it # for maximum performances. # # RDB files created with checksum disabled have a checksum of zero that will # tell the loading code to skip the check. rdbchecksum yes #保存rdb文件时是否进行校验 # Enables or disables full sanitization checks for ziplist and listpack etc when # loading an RDB or RESTORE payload. This reduces the chances of a assertion or # crash later on while processing commands. # Options: # no - Never perform full sanitization # yes - Always perform full sanitization # clients - Perform full sanitization only for user connections. # Excludes: RDB files, RESTORE commands received from the master # connection, and client connections which have the # skip-sanitize-payload ACL flag. # The default should be \u0026#39;clients\u0026#39; but since it currently affects cluster # resharding via MIGRATE, it is temporarily set to \u0026#39;no\u0026#39; by default. # # sanitize-dump-payload no # The filename where to dump the DB dbfilename dump.rdb #rdb文件名 # Remove RDB files used by replication in instances without persistence # enabled. By default this option is disabled, however there are environments # where for regulations or other security concerns, RDB files persisted on # disk by masters in order to feed replicas, or stored on disk by replicas # in order to load them for the initial synchronization, should be deleted # ASAP. Note that this option ONLY WORKS in instances that have both AOF # and RDB persistence disabled, otherwise is completely ignored. # # An alternative (and sometimes better) way to obtain the same effect is # to use diskless replication on both master and replicas instances. However # in the case of replicas, diskless is not always an option. rdb-del-sync-files no #rdb文件是否删除同步锁 # The working directory. # # The DB will be written inside this directory, with the filename specified # above using the \u0026#39;dbfilename\u0026#39; configuration directive. # # The Append Only File will also be created inside this directory. # # Note that you must specify a directory here, not a file name. dir ./ #rdb文件保存目录     主从复制 (REPLICATION)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120  ################################# REPLICATION ################################# # Master-Replica replication. Use replicaof to make a Redis instance a copy of # another Redis server. A few things to understand ASAP about Redis replication. # # +------------------+ +---------------+ # | Master | ---\u0026gt; | Replica | # | (receive writes) | | (exact copy) | # +------------------+ +---------------+ # # 1) Redis replication is asynchronous, but you can configure a master to # stop accepting writes if it appears to be not connected with at least # a given number of replicas. # 2) Redis replicas are able to perform a partial resynchronization with the # master if the replication link is lost for a relatively small amount of # time. You may want to configure the replication backlog size (see the next # sections of this file) with a sensible value depending on your needs. # 3) Replication is automatic and does not need user intervention. After a # network partition replicas automatically try to reconnect to masters # and resynchronize with them. # # replicaof \u0026lt;masterip\u0026gt; \u0026lt;masterport\u0026gt; #配置主机的ip和端口 # If the master is password protected (using the \u0026#34;requirepass\u0026#34; configuration # directive below) it is possible to tell the replica to authenticate before # starting the replication synchronization process, otherwise the master will # refuse the replica request. # # masterauth \u0026lt;master-password\u0026gt; #配置主机的密码 # # However this is not enough if you are using Redis ACLs (for Redis version # 6 or greater), and the default user is not capable of running the PSYNC # command and/or other commands needed for replication. In this case it\u0026#39;s # better to configure a special user to use with replication, and specify the # masteruser configuration as such: # # masteruser \u0026lt;username\u0026gt; #配置主机的用户名 # # When masteruser is specified, the replica will authenticate against its # master using the new AUTH form: AUTH \u0026lt;username\u0026gt; \u0026lt;password\u0026gt;. # When a replica loses its connection with the master, or when the replication # is still in progress, the replica can act in two different ways: # # 1) if replica-serve-stale-data is set to \u0026#39;yes\u0026#39; (the default) the replica will # still reply to client requests, possibly with out of date data, or the # data set may just be empty if this is the first synchronization. # # 2) If replica-serve-stale-data is set to \u0026#39;no\u0026#39; the replica will reply with error # \u0026#34;MASTERDOWN Link with MASTER is down and replica-serve-stale-data is set to \u0026#39;no\u0026#39;\u0026#34; # to all data access commands, excluding commands such as: # INFO, REPLICAOF, AUTH, SHUTDOWN, REPLCONF, ROLE, CONFIG, SUBSCRIBE, # UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH, PUBSUB, COMMAND, POST, # HOST and LATENCY. # replica-serve-stale-data yes #当主机和从机之前断开连接后，从机是否继续向客户端提供查询服务；yes表示继续提供，no表示除了不涉及查询的命令可以执行，其他命令均返回提示信息 # You can configure a replica instance to accept writes or not. Writing against # a replica instance may be useful to store some ephemeral data (because data # written on a replica will be easily deleted after resync with the master) but # may also cause problems if clients are writing to it because of a # misconfiguration. # # Since Redis 2.6 by default replicas are read-only. # # Note: read only replicas are not designed to be exposed to untrusted clients # on the internet. It\u0026#39;s just a protection layer against misuse of the instance. # Still a read only replica exports by default all the administrative commands # such as CONFIG, DEBUG, and so forth. To a limited extent you can improve # security of read only replicas using \u0026#39;rename-command\u0026#39; to shadow all the # administrative / dangerous commands. replica-read-only yes #设置从节点只读命令 # Replication SYNC strategy: disk or socket. # # New replicas and reconnecting replicas that are not able to continue the # replication process just receiving differences, need to do what is called a # \u0026#34;full synchronization\u0026#34;. An RDB file is transmitted from the master to the # replicas. # # The transmission can happen in two different ways: # # 1) Disk-backed: The Redis master creates a new process that writes the RDB # file on disk. Later the file is transferred by the parent # process to the replicas incrementally. # 2) Diskless: The Redis master creates a new process that directly writes the # RDB file to replica sockets, without touching the disk at all. # # With disk-backed replication, while the RDB file is generated, more replicas # can be queued and served with the RDB file as soon as the current child # producing the RDB file finishes its work. With diskless replication instead # once the transfer starts, new replicas arriving will be queued and a new # transfer will start when the current one terminates. # # When diskless replication is used, the master waits a configurable amount of # time (in seconds) before starting the transfer in the hope that multiple # replicas will arrive and the transfer can be parallelized. # # With slow disks and fast (large bandwidth) networks, diskless replication # works better. repl-diskless-sync yes # When diskless replication is enabled, it is possible to configure the delay # the server waits in order to spawn the child that transfers the RDB via socket # to the replicas. # # This is important since once the transfer starts, it is not possible to serve # new replicas arriving, that will be queued for the next RDB transfer, so the # server waits a delay in order to let more replicas arrive. # # The delay is specified in seconds, and by default is 5 seconds. To disable # it entirely just set it to 0 seconds and the transfer will start ASAP. repl-diskless-sync-delay 5 # When diskless replication is enabled with a delay, it is possible to let # the replication start before the maximum delay is reached if the maximum # number of replicas expected have connected. Default of 0 means that the # maximum is not defined and Redis will wait the full delay. repl-diskless-sync-max-replicas 0 ...     安全 (SECURITY)\n1 2 3 4 5  config get requirepass #查看密码设置 config set requirepass 123456 #设置密码 auth 123456 #使用密码登录     客户端限制\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80  ################################### CLIENTS #################################### # Set the max number of connected clients at the same time. By default # this limit is set to 10000 clients, however if the Redis server is not # able to configure the process file limit to allow for the specified limit # the max number of allowed clients is set to the current file limit # minus 32 (as Redis reserves a few file descriptors for internal uses). # # Once the limit is reached Redis will close all the new connections sending # an error \u0026#39;max number of clients reached\u0026#39;. # # IMPORTANT: When Redis Cluster is used, the max number of connections is also # shared with the cluster bus: every node in the cluster will use two # connections, one incoming and another outgoing. It is important to size the # limit accordingly in case of very large clusters. # # maxclients 10000 #设置最大客户端数量 ############################## MEMORY MANAGEMENT ################################ # Set a memory usage limit to the specified amount of bytes. # When the memory limit is reached Redis will try to remove keys # according to the eviction policy selected (see maxmemory-policy). # # If Redis can\u0026#39;t remove keys according to the policy, or if the policy is # set to \u0026#39;noeviction\u0026#39;, Redis will start to reply with errors to commands # that would use more memory, like SET, LPUSH, and so on, and will continue # to reply to read-only commands like GET. # # This option is usually useful when using Redis as an LRU or LFU cache, or to # set a hard memory limit for an instance (using the \u0026#39;noeviction\u0026#39; policy). # # WARNING: If you have replicas attached to an instance with maxmemory on, # the size of the output buffers needed to feed the replicas are subtracted # from the used memory count, so that network problems / resyncs will # not trigger a loop where keys are evicted, and in turn the output # buffer of replicas is full with DELs of keys evicted triggering the deletion # of more keys, and so forth until the database is completely emptied. # # In short... if you have replicas attached it is suggested that you set a lower # limit for maxmemory so that there is some free RAM on the system for replica # output buffers (but this is not needed if the policy is \u0026#39;noeviction\u0026#39;). # # maxmemory \u0026lt;bytes\u0026gt; #最大内存设置 # MAXMEMORY POLICY: how Redis will select what to remove when maxmemory # is reached. You can select one from the following behaviors: # # volatile-lru -\u0026gt; Evict using approximated LRU, only keys with an expire set. # allkeys-lru -\u0026gt; Evict any key using approximated LRU. # volatile-lfu -\u0026gt; Evict using approximated LFU, only keys with an expire set. # allkeys-lfu -\u0026gt; Evict any key using approximated LFU. # volatile-random -\u0026gt; Remove a random key having an expire set. # allkeys-random -\u0026gt; Remove a random key, any key. # volatile-ttl -\u0026gt; Remove the key with the nearest expire time (minor TTL) # noeviction -\u0026gt; Don\u0026#39;t evict anything, just return an error on write operations. # # LRU means Least Recently Used # LFU means Least Frequently Used # # Both LRU, LFU and volatile-ttl are implemented using approximated # randomized algorithms. # # Note: with any of the above policies, when there are no suitable keys for # eviction, Redis will return an error on write operations that require # more memory. These are usually commands that create new keys, add data or # modify existing keys. A few examples are: SET, INCR, HSET, LPUSH, SUNIONSTORE, # SORT (due to the STORE argument), and EXEC (if the transaction includes any # command that requires memory). # # The default is: # # maxmemory-policy noeviction #内存到达上限之后的处理策略 # # 1.volatile-lru: 只对设置了过期时间的key进行LRU # 2.allkeys-lru: 删除lru算法的key # 3.volatile-random: 随机删除即将过期的key # 4.allkeys-random: 随机删除 # 5.volatile-ttl: 删除即将过期的 # 6.noeviction: 永不过期, 返回错误     AOF配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81  ############################## APPEND ONLY MODE ############################### # By default Redis asynchronously dumps the dataset on disk. This mode is # good enough in many applications, but an issue with the Redis process or # a power outage may result into a few minutes of writes lost (depending on # the configured save points). # # The Append Only File is an alternative persistence mode that provides # much better durability. For instance using the default data fsync policy # (see later in the config file) Redis can lose just one second of writes in a # dramatic event like a server power outage, or a single write if something # wrong with the Redis process itself happens, but the operating system is # still running correctly. # # AOF and RDB persistence can be enabled at the same time without problems. # If the AOF is enabled on startup Redis will load the AOF, that is the file # with the better durability guarantees. # # Please check https://redis.io/topics/persistence for more information. appendonly no #默认不开启aof模式，使用rdb方式持久化，大多数情况下rdb完全够用 # The base name of the append only file. # # Redis 7 and newer use a set of append-only files to persist the dataset # and changes applied to it. There are two basic types of files in use: # # - Base files, which are a snapshot representing the complete state of the # dataset at the time the file was created. Base files can be either in # the form of RDB (binary serialized) or AOF (textual commands). # - Incremental files, which contain additional commands that were applied # to the dataset following the previous file. # # In addition, manifest files are used to track the files and the order in # which they were created and should be applied. # # Append-only file names are created by Redis following a specific pattern. # The file name\u0026#39;s prefix is based on the \u0026#39;appendfilename\u0026#39; configuration # parameter, followed by additional information about the sequence and type. # # For example, if appendfilename is set to appendonly.aof, the following file # names could be derived: # # - appendonly.aof.1.base.rdb as a base file. # - appendonly.aof.1.incr.aof, appendonly.aof.2.incr.aof as incremental files. # - appendonly.aof.manifest as a manifest file. appendfilename \u0026#34;appendonly.aof\u0026#34; #aof文件名设置 # For convenience, Redis stores all persistent append-only files in a dedicated # directory. The name of the directory is determined by the appenddirname # configuration parameter. appenddirname \u0026#34;appendonlydir\u0026#34; #aof文件目录设置 # The fsync() call tells the Operating System to actually write data on disk # instead of waiting for more data in the output buffer. Some OS will really flush # data on disk, some other OS will just try to do it ASAP. # # Redis supports three different modes: # # no: don\u0026#39;t fsync, just let the OS flush the data when it wants. Faster. # always: fsync after every write to the append only log. Slow, Safest. # everysec: fsync only one time every second. Compromise. # # The default is \u0026#34;everysec\u0026#34;, as that\u0026#39;s usually the right compromise between # speed and data safety. It\u0026#39;s up to you to understand if you can relax this to # \u0026#34;no\u0026#34; that will let the operating system flush the output buffer when # it wants, for better performances (but if you can live with the idea of # some data loss consider the default persistence mode that\u0026#39;s snapshotting), # or on the contrary, use \u0026#34;always\u0026#34; that\u0026#39;s very slow but a bit safer than # everysec. # # More details please check the following article: # http://antirez.com/post/redis-persistence-demystified.html # # If unsure, use \u0026#34;everysec\u0026#34;. # appendfsync always #每次修改都同步，消耗性能 appendfsync everysec #每秒执行一次同步数据，如果服务器宕机可能会丢失数据 # appendfsync no #不同步     Redis持久化 Redis是内存数据库，为了防止断电易失。Redis默认采用RDB持久化方式。\nRDB 在指定的时间间隔内将内存中的数据集快照写入磁盘，恢复时直接将快照读入内存中。\n 步骤解读：\n Redis会单独创建(fork)一个子进程来进行持久化 子进程将内存中的数据写入临时的rdb文件(dump.rdb) 父进程则继续处理Redis客户端发送的指令 临时rdb生成完成后，将新的rdb文件替换之前持久化生成的文件，子进程结束  整个过程主进程不会进行任何IO操作，所以保证了性能，但缺点是最后一次持久化后的数据可能会丢失。\n RDB持久化触发情景：\n 满足配置文件中设置的save配置时 redis客户端发送save命令 退出redis服务(shutdown命令)时 执行flushall命令时  只要将rdb文件放在redis启动目录下，redis启动时会自动检查并读取rdb文件进行数据恢复\n查看redis启动目录：config get dir\n优点\n 适合大规模的数据恢复 对数据完成性要求不高，如果redis服务器在还不满足save配置的时候宕机，就会发生数据丢失  缺点\n 需要满足save配置的时间间隔才会触发rdb持久化 如果服务器宕机，最后一次持久化后修改的数据会丢失  AOF (Append Only File) 将所有命令记录下来（历史记录），恢复的时候就是把这个文件重新执行一遍。\n以日志的形式记录每个写命令，追加到日志结尾。\nredis启动后会读取该文件重新构建数据，也就是重新执行一遍日志中记录的所有写操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156  ############################## APPEND ONLY MODE ############################### # By default Redis asynchronously dumps the dataset on disk. This mode is # good enough in many applications, but an issue with the Redis process or # a power outage may result into a few minutes of writes lost (depending on # the configured save points). # # The Append Only File is an alternative persistence mode that provides # much better durability. For instance using the default data fsync policy # (see later in the config file) Redis can lose just one second of writes in a # dramatic event like a server power outage, or a single write if something # wrong with the Redis process itself happens, but the operating system is # still running correctly. # # AOF and RDB persistence can be enabled at the same time without problems. # If the AOF is enabled on startup Redis will load the AOF, that is the file # with the better durability guarantees. # # Please check https://redis.io/topics/persistence for more information. appendonly no #默认是不开启的，设置成yes为开启 # The base name of the append only file. # # Redis 7 and newer use a set of append-only files to persist the dataset # and changes applied to it. There are two basic types of files in use: # # - Base files, which are a snapshot representing the complete state of the # dataset at the time the file was created. Base files can be either in # the form of RDB (binary serialized) or AOF (textual commands). # - Incremental files, which contain additional commands that were applied # to the dataset following the previous file. # # In addition, manifest files are used to track the files and the order in # which they were created and should be applied. # # Append-only file names are created by Redis following a specific pattern. # The file name\u0026#39;s prefix is based on the \u0026#39;appendfilename\u0026#39; configuration # parameter, followed by additional information about the sequence and type. # # For example, if appendfilename is set to appendonly.aof, the following file # names could be derived: # # - appendonly.aof.1.base.rdb as a base file. # - appendonly.aof.1.incr.aof, appendonly.aof.2.incr.aof as incremental files. # - appendonly.aof.manifest as a manifest file. appendfilename \u0026#34;appendonly.aof\u0026#34; # For convenience, Redis stores all persistent append-only files in a dedicated # directory. The name of the directory is determined by the appenddirname # configuration parameter. appenddirname \u0026#34;appendonlydir\u0026#34; # The fsync() call tells the Operating System to actually write data on disk # instead of waiting for more data in the output buffer. Some OS will really flush # data on disk, some other OS will just try to do it ASAP. # # Redis supports three different modes: # # no: don\u0026#39;t fsync, just let the OS flush the data when it wants. Faster. # always: fsync after every write to the append only log. Slow, Safest. # everysec: fsync only one time every second. Compromise. # # The default is \u0026#34;everysec\u0026#34;, as that\u0026#39;s usually the right compromise between # speed and data safety. It\u0026#39;s up to you to understand if you can relax this to # \u0026#34;no\u0026#34; that will let the operating system flush the output buffer when # it wants, for better performances (but if you can live with the idea of # some data loss consider the default persistence mode that\u0026#39;s snapshotting), # or on the contrary, use \u0026#34;always\u0026#34; that\u0026#39;s very slow but a bit safer than # everysec. # # More details please check the following article: # http://antirez.com/post/redis-persistence-demystified.html # # If unsure, use \u0026#34;everysec\u0026#34;. # appendfsync always #每次修改追加一次，并同步到磁盘 appendfsync everysec #aof持久化策略，每秒钟追加一次，并同步到磁盘中 # appendfsync no #只追加到aof文件，不写入磁盘，交给操作系统去决定什么时候要写到磁盘 # When the AOF fsync policy is set to always or everysec, and a background # saving process (a background save or AOF log background rewriting) is # performing a lot of I/O against the disk, in some Linux configurations # Redis may block too long on the fsync() call. Note that there is no fix for # this currently, as even performing fsync in a different thread will block # our synchronous write(2) call. # # In order to mitigate this problem it\u0026#39;s possible to use the following option # that will prevent fsync() from being called in the main process while a # BGSAVE or BGREWRITEAOF is in progress. # # This means that while another child is saving, the durability of Redis is # the same as \u0026#34;appendfsync no\u0026#34;. In practical terms, this means that it is # possible to lose up to 30 seconds of log in the worst scenario (with the # default Linux settings). # # If you have latency problems turn this to \u0026#34;yes\u0026#34;. Otherwise leave it as # \u0026#34;no\u0026#34; that is the safest pick from the point of view of durability. no-appendfsync-on-rewrite no #当写入磁盘时由于大量IO操作，可能会阻塞主进程。如果设置为yes那么就不再写入磁盘中，而是交给操作系统决定何时写入磁盘，减少了IO操作，也就不会阻塞，但是数据可能丢失，因为没有及时写入磁盘中。默认为no，这样是安全的。 # Automatic rewrite of the append only file. # Redis is able to automatically rewrite the log file implicitly calling # BGREWRITEAOF when the AOF log size grows by the specified percentage. # # This is how it works: Redis remembers the size of the AOF file after the # latest rewrite (if no rewrite has happened since the restart, the size of # the AOF at startup is used). # # This base size is compared to the current size. If the current size is # bigger than the specified percentage, the rewrite is triggered. Also # you need to specify a minimal size for the AOF file to be rewritten, this # is useful to avoid rewriting the AOF file even if the percentage increase # is reached but it is still pretty small. # # Specify a percentage of zero in order to disable the automatic AOF # rewrite feature. auto-aof-rewrite-percentage 100 #当aof文件大小超过上一次重写的aof文件的百分之多少进行重写 auto-aof-rewrite-min-size 64mb #设置允许重写的最小文件大小。防止超过百分比后文件依然很小，这时如果没超过最小文件大小就不重写 # An AOF file may be found to be truncated at the end during the Redis # startup process, when the AOF data gets loaded back into memory. # This may happen when the system where Redis is running # crashes, especially when an ext4 filesystem is mounted without the # data=ordered option (however this can\u0026#39;t happen when Redis itself # crashes or aborts but the operating system still works correctly). # # Redis can either exit with an error when this happens, or load as much # data as possible (the default now) and start if the AOF file is found # to be truncated at the end. The following option controls this behavior. # # If aof-load-truncated is set to yes, a truncated AOF file is loaded and # the Redis server starts emitting a log to inform the user of the event. # Otherwise if the option is set to no, the server aborts with an error # and refuses to start. When the option is set to no, the user requires # to fix the AOF file using the \u0026#34;redis-check-aof\u0026#34; utility before to restart # the server. # # Note that if the AOF file will be found to be corrupted in the middle # the server will still exit with an error. This option only applies when # Redis will try to read more data from the AOF file but not enough bytes # will be found. aof-load-truncated yes # Redis can create append-only base files in either RDB or AOF formats. Using # the RDB format is always faster and more efficient, and disabling it is only # supported for backward compatibility purposes. aof-use-rdb-preamble yes # Redis supports recording timestamp annotations in the AOF to support restoring # the data from a specific point-in-time. However, using this capability changes # the AOF format in a way that may not be compatible with existing AOF parsers. aof-timestamp-enabled no   如果aof文件有错误，那么无法启动redis客户端，可以用redis-check-aof来修复aof文件，但是数据会有所缺失\n1  redis-check-aof --fix appendonly.aof   优点\n 每一次修改都追加，文件完整性好，但是性能消耗高 每秒同步一次，可能会丢失一秒的数据 从不同步，效率最高  缺点\n 相对于数据文件来说，aof文件要远远大于rdb文件，修复的速度也比rdb慢 因为aof本质上是追加写文件，是IO操作，所以aof运行效率也比rdb慢，所以redis默认就是rdb持久化  扩展\n 如果两种持久化同时开启，redis重启时会优先载入aof文件来恢复数据\n一般rdb用于备份redis数据，只在从服务器上进行备份，15分钟备份一次，也就是save 900 1\n Redis发布订阅 redis发布订阅是一种消息模式，发送者发送消息，订阅者接收消息\nredis客户端可以订阅任意数量的频道\n1 2 3 4 5 6 7 8 9 10 11  psubscribe pattern... #订阅一个或多个符合给定模式的频道 pubsub subcommand argument... #查看订阅与发布系统状态 publish channel message #将信息发送到指定频道 subscribe channel... #订阅一个或多个频道 punsubscribe pattern... #退订所有给定模式的频道 unsubscribe channel... #退订给定的频道   底层实现\n每个频道是一个字典，字典的键用来标识频道，字典的值是一个链表，链表中是该频道的所有订阅者\n使用场景\n 实时消息系统 实时聊天室 订阅公众号等  Redis主从复制 概念 主从复制是指将一台Redis服务器的数据复制到从节点的服务器上，其中主节点负责写数据，从节点负责读取数据。主从复制是单向的，有主节点到从节点。主节点可以有任意个从节点，而从节点只能有一个主节点。\n作用  数据备份：主从复制实现了数据的热备份 故障修复：当主节点出现问题可以使用从节点 负载均衡：主从复制加读写分离，写数据时请求主服务器，读数据时请求从服务器，可以分担服务器的访问压力 高可用基石：主从复制是哨兵模式和集群实施的基础  一般redis需要配置两从一主，只配置一台redis服务器有两个弊端：\n 从结构上来说，单个服务器可能宕机，并且所有请求访问一台服务器，压力太大 从容量上来说，单个服务器容量有限，一般单台redis服务器的最大内存使用量应该不超过20G  搭建环境 1 2 3 4 5 6 7 8 9 10 11 12 13 14  info replication #查看主从复制信息 # Replication role:master #角色 connected_slaves:0 #连接的从节点个数 master_failover_state:no-failover master_replid:9a9ee312a4acaeb3ec299c0a9082833d116fe92d master_replid2:0000000000000000000000000000000000000000 master_repl_offset:0 second_repl_offset:-1 repl_backlog_active:0 repl_backlog_size:1048576 repl_backlog_first_byte_offset:0 repl_backlog_histlen:0   在一台服务器上启动3个redis服务进程来模拟一主两从\n 复制出3个配置文件，并修改端口号、日志文件名称、dump文件名称、pid名称 使用不同的配置文件启动redis服务   配置从机\n1  slaveof host port #配置以host:port为主机     在主机上可以查看到从机的信息\n  除了通过命令配置主从之外还可以修改配置文件进行配置，这样是永久配置。具体看conf详解\n测试 当主机断开连接后，两台从机依然是从机的角色，主机重新连接后，依然可以写数据。\n当从机断开连接后再次重新连接，如果从机的角色为主机 (通过命令配置从机的方式重启后角色变为主机) ，则无法同步主机的数据，只要重新配置为从机就可以同步到主机上的所有数据；如果从机的角色还是从机 (修改配置文件的方式重启后依然为从机) ，则能够同步到宕机期间主机写入的数据。\n只要从机连接到主机，从机就会向主机发送sync同步命令，主机将数据文件传送给从机，进行一次全量同步。全量同步之后主机上的写操作都是增量同步给从机。\n第二种主从复制方法 如果主机宕机后，需要手动执行slaveof no one命令将一个从机设置为主机。当原来的主机重新连接后就会出现两个主机，还需要用slaveof ip porrt手动改为从机。\n哨兵模式 Redis2.8之后开始提供哨兵模式，当主服务器宕机后能够自动将一台从机切换为主机\n原理 哨兵是一个独立的进程，通过不断向所有redis服务器发送命令来判断各个redis服务器是否宕机\n当哨兵检测到主服务器宕机后，会自动将一台从服务器切换为主服务器，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让从服务器切换主机\n但是如果只有一个哨兵，哨兵进程也可能死掉，所以多哨兵模式就是防止一个哨兵挂掉\n如果主服务器宕机，哨兵1检测到之后不会马上重新选择主服务器，只是认为主服务器现在不可用，这个现象称为主观下线，如果还有其他哨兵也检测到主服务器不可用，达到一定数量之后，所有哨兵会投票选出一个从服务器来暂时充当主服务器，由某个哨兵发布消息通知服务器切换自己的主服务器。\n配置哨兵模式 哨兵配置文件为sentinel.conf\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370  # Example sentinel.conf # By default protected mode is disabled in sentinel mode. Sentinel is reachable # from interfaces different than localhost. Make sure the sentinel instance is # protected from the outside world via firewalling or other means. protected-mode no #被保护模式，默认关闭 # port \u0026lt;sentinel-port\u0026gt; # The port that this sentinel instance will run on port 26379 #哨兵运行端口 # By default Redis Sentinel does not run as a daemon. Use \u0026#39;yes\u0026#39; if you need it. # Note that Redis will write a pid file in /var/run/redis-sentinel.pid when # daemonized. daemonize no #守护进程默认关闭 # When running daemonized, Redis Sentinel writes a pid file in # /var/run/redis-sentinel.pid by default. You can specify a custom pid file # location here. pidfile /var/run/redis-sentinel.pid #开启守护进程后哨兵进程的pid文件 # Specify the log file name. Also the empty string can be used to force # Sentinel to log on the standard output. Note that if you use standard # output for logging but daemonize, logs will be sent to /dev/null logfile \u0026#34;\u0026#34; #日志文件 # sentinel announce-ip \u0026lt;ip\u0026gt; # sentinel announce-port \u0026lt;port\u0026gt; # # The above two configuration directives are useful in environments where, # because of NAT, Sentinel is reachable from outside via a non-local address. # # When announce-ip is provided, the Sentinel will claim the specified IP address # in HELLO messages used to gossip its presence, instead of auto-detecting the # local address as it usually does. # # Similarly when announce-port is provided and is valid and non-zero, Sentinel # will announce the specified TCP port. # # The two options don\u0026#39;t need to be used together, if only announce-ip is # provided, the Sentinel will announce the specified IP and the server port # as specified by the \u0026#34;port\u0026#34; option. If only announce-port is provided, the # Sentinel will announce the auto-detected local IP and the specified port. # # Example: # # sentinel announce-ip 1.2.3.4 # dir \u0026lt;working-directory\u0026gt; # Every long running process should have a well-defined working directory. # For Redis Sentinel to chdir to /tmp at startup is the simplest thing # for the process to don\u0026#39;t interfere with administrative tasks such as # unmounting filesystems. dir /tmp #哨兵sentinel的工作目录 # sentinel monitor \u0026lt;master-name\u0026gt; \u0026lt;ip\u0026gt; \u0026lt;redis-port\u0026gt; \u0026lt;quorum\u0026gt; # # Tells Sentinel to monitor this master, and to consider it in O_DOWN # (Objectively Down) state only if at least \u0026lt;quorum\u0026gt; sentinels agree. # # Note that whatever is the ODOWN quorum, a Sentinel will require to # be elected by the majority of the known Sentinels in order to # start a failover, so no failover can be performed in minority. # # Replicas are auto-discovered, so you don\u0026#39;t need to specify replicas in # any way. Sentinel itself will rewrite this configuration file adding # the replicas using additional configuration options. # Also note that the configuration file is rewritten when a # replica is promoted to master. # # Note: master name should not include special characters or spaces. # The valid charset is A-z 0-9 and the three characters \u0026#34;.-_\u0026#34;. sentinel monitor mymaster 127.0.0.1 6379 2 #quorum表示当多少个哨兵检测到主服务器宕机之后开始重新选择 # sentinel auth-pass \u0026lt;master-name\u0026gt; \u0026lt;password\u0026gt; # # Set the password to use to authenticate with the master and replicas. # Useful if there is a password set in the Redis instances to monitor. # # Note that the master password is also used for replicas, so it is not # possible to set a different password in masters and replicas instances # if you want to be able to monitor these instances with Sentinel. # # However you can have Redis instances without the authentication enabled # mixed with Redis instances requiring the authentication (as long as the # password set is the same for all the instances requiring the password) as # the AUTH command will have no effect in Redis instances with authentication # switched off. # # Example: # # sentinel auth-pass mymaster MySUPER--secret-0123passw0rd #哨兵连接主从的密码 # sentinel auth-user \u0026lt;master-name\u0026gt; \u0026lt;username\u0026gt; # # This is useful in order to authenticate to instances having ACL capabilities, # that is, running Redis 6.0 or greater. When just auth-pass is provided the # Sentinel instance will authenticate to Redis using the old \u0026#34;AUTH \u0026lt;pass\u0026gt;\u0026#34; # method. When also an username is provided, it will use \u0026#34;AUTH \u0026lt;user\u0026gt; \u0026lt;pass\u0026gt;\u0026#34;. # In the Redis servers side, the ACL to provide just minimal access to # Sentinel instances, should be configured along the following lines: # # user sentinel-user \u0026gt;somepassword +client +subscribe +publish \\ # +ping +info +multi +slaveof +config +client +exec on # sentinel down-after-milliseconds \u0026lt;master-name\u0026gt; \u0026lt;milliseconds\u0026gt; # # Number of milliseconds the master (or any attached replica or sentinel) should # be unreachable (as in, not acceptable reply to PING, continuously, for the # specified period) in order to consider it in S_DOWN state (Subjectively # Down). # # Default is 30 seconds. sentinel down-after-milliseconds mymaster 30000 #指定多少毫秒之后，如果主节点没有应答，哨兵就认为主节点下线，默认30秒 # IMPORTANT NOTE: starting with Redis 6.2 ACL capability is supported for # Sentinel mode, please refer to the Redis website https://redis.io/topics/acl # for more details. # Sentinel\u0026#39;s ACL users are defined in the following format: # # user \u0026lt;username\u0026gt; ... acl rules ... # # For example: # # user worker +@admin +@connection ~* on \u0026gt;ffa9203c493aa99 # # For more information about ACL configuration please refer to the Redis # website at https://redis.io/topics/acl and redis server configuration  # template redis.conf. # ACL LOG # # The ACL Log tracks failed commands and authentication events associated # with ACLs. The ACL Log is useful to troubleshoot failed commands blocked  # by ACLs. The ACL Log is stored in memory. You can reclaim memory with  # ACL LOG RESET. Define the maximum entry length of the ACL Log below. acllog-max-len 128 # Using an external ACL file # # Instead of configuring users here in this file, it is possible to use # a stand-alone file just listing users. The two methods cannot be mixed: # if you configure users here and at the same time you activate the external # ACL file, the server will refuse to start. # # The format of the external ACL user file is exactly the same as the # format that is used inside redis.conf to describe users. # # aclfile /etc/redis/sentinel-users.acl # requirepass \u0026lt;password\u0026gt; # # You can configure Sentinel itself to require a password, however when doing # so Sentinel will try to authenticate with the same password to all the # other Sentinels. So you need to configure all your Sentinels in a given # group with the same \u0026#34;requirepass\u0026#34; password. Check the following documentation # for more info: https://redis.io/topics/sentinel # # IMPORTANT NOTE: starting with Redis 6.2 \u0026#34;requirepass\u0026#34; is a compatibility # layer on top of the ACL system. The option effect will be just setting # the password for the default user. Clients will still authenticate using # AUTH \u0026lt;password\u0026gt; as usually, or more explicitly with AUTH default \u0026lt;password\u0026gt; # if they follow the new protocol: both will work. # # New config files are advised to use separate authentication control for # incoming connections (via ACL), and for outgoing connections (via # sentinel-user and sentinel-pass)  # # The requirepass is not compatible with aclfile option and the ACL LOAD # command, these will cause requirepass to be ignored. # sentinel sentinel-user \u0026lt;username\u0026gt; # # You can configure Sentinel to authenticate with other Sentinels with specific # user name.  # sentinel sentinel-pass \u0026lt;password\u0026gt; # # The password for Sentinel to authenticate with other Sentinels. If sentinel-user # is not configured, Sentinel will use \u0026#39;default\u0026#39; user with sentinel-pass to authenticate. # sentinel parallel-syncs \u0026lt;master-name\u0026gt; \u0026lt;numreplicas\u0026gt; # # How many replicas we can reconfigure to point to the new replica simultaneously # during the failover. Use a low number if you use the replicas to serve query # to avoid that all the replicas will be unreachable at about the same # time while performing the synchronization with the master. sentinel parallel-syncs mymaster 1 #这个配置项指定了在主备切换时最多可以有多少个slave同时对新的master进行同步，这个数字越小，完成主备切换的时间就越长。但是如果这个数字太大，就意味有多少个slave因为同步数据而不可用，一般应该保证每次只有一个slave处于不能处理命令请求的状态。 # sentinel failover-timeout \u0026lt;master-name\u0026gt; \u0026lt;milliseconds\u0026gt; # # Specifies the failover timeout in milliseconds. It is used in many ways: # # - The time needed to re-start a failover after a previous failover was # already tried against the same master by a given Sentinel, is two # times the failover timeout. # # - The time needed for a replica replicating to a wrong master according # to a Sentinel current configuration, to be forced to replicate # with the right master, is exactly the failover timeout (counting since # the moment a Sentinel detected the misconfiguration). # # - The time needed to cancel a failover that is already in progress but # did not produced any configuration change (SLAVEOF NO ONE yet not # acknowledged by the promoted replica). # # - The maximum time a failover in progress waits for all the replicas to be # reconfigured as replicas of the new master. However even after this time # the replicas will be reconfigured by the Sentinels anyway, but not with # the exact parallel-syncs progression as specified. # # Default is 3 minutes. # 故障转移的超时时间 failover-timeout 可以用在以下这些方面：  # 1. 同一个sentinel对同一个master两次failover之间的间隔时间。 # 2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。 # 3.当想要取消一个正在进行的failover所需要的时间。  # 4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向 master，但是就不按parallel-syncs所配置的规则来了 # 默认三分钟 # sentinel failover-timeout mymaster 180000 # SCRIPTS EXECUTION # # sentinel notification-script and sentinel reconfig-script are used in order # to configure scripts that are called to notify the system administrator # or to reconfigure clients after a failover. The scripts are executed # with the following rules for error handling: # # If script exits with \u0026#34;1\u0026#34; the execution is retried later (up to a maximum # number of times currently set to 10). # # If script exits with \u0026#34;2\u0026#34; (or an higher value) the script execution is # not retried. # # If script terminates because it receives a signal the behavior is the same # as exit code 1. # # A script has a maximum running time of 60 seconds. After this limit is # reached the script is terminated with a SIGKILL and the execution retried. # NOTIFICATION SCRIPT # # sentinel notification-script \u0026lt;master-name\u0026gt; \u0026lt;script-path\u0026gt; #  # Call the specified notification script for any sentinel event that is # generated in the WARNING level (for instance -sdown, -odown, and so forth). # This script should notify the system administrator via email, SMS, or any # other messaging system, that there is something wrong with the monitored # Redis systems. # # The script is called with just two arguments: the first is the event type # and the second the event description. # # The script must exist and be executable in order for sentinel to start if # this option is provided. # # Example: # # 配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。 # 对于脚本的运行结果有以下规则： # 若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10 # 若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。 # 如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。 # 一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。 # 通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本， # 这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件# 的类型，一个是事件的描述。 # 如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正 # 常启动成功。 # # sentinel notification-script mymaster /var/redis/notify.sh # CLIENTS RECONFIGURATION SCRIPT # # sentinel client-reconfig-script \u0026lt;master-name\u0026gt; \u0026lt;script-path\u0026gt; # # When the master changed because of a failover a script can be called in # order to perform application-specific tasks to notify the clients that the # configuration has changed and the master is at a different address. #  # The following arguments are passed to the script: # # \u0026lt;master-name\u0026gt; \u0026lt;role\u0026gt; \u0026lt;state\u0026gt; \u0026lt;from-ip\u0026gt; \u0026lt;from-port\u0026gt; \u0026lt;to-ip\u0026gt; \u0026lt;to-port\u0026gt; # # \u0026lt;state\u0026gt; is currently always \u0026#34;start\u0026#34; # \u0026lt;role\u0026gt; is either \u0026#34;leader\u0026#34; or \u0026#34;observer\u0026#34; #  # The arguments from-ip, from-port, to-ip, to-port are used to communicate # the old address of the master and the new address of the elected replica # (now a master). # # This script should be resistant to multiple invocations. # # Example: # # 客户端重新配置主节点参数脚本 # 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。 # 以下参数将会在调用脚本时传给脚本: # \u0026lt;master-name\u0026gt; \u0026lt;role\u0026gt; \u0026lt;state\u0026gt; \u0026lt;from-ip\u0026gt; \u0026lt;from-port\u0026gt; \u0026lt;to-ip\u0026gt; \u0026lt;to-port\u0026gt; # 目前\u0026lt;state\u0026gt;总是“failover”, # \u0026lt;role\u0026gt;是“leader”或者“observer”中的一个。  # 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的 # 这个脚本应该是通用的，能被多次调用，不是针对性的。 # # sentinel client-reconfig-script mymaster /var/redis/reconfig.sh # SECURITY # # By default SENTINEL SET will not be able to change the notification-script # and client-reconfig-script at runtime. This avoids a trivial security issue # where clients can set the script to anything and trigger a failover in order # to get the program executed. sentinel deny-scripts-reconfig yes # REDIS COMMANDS RENAMING (DEPRECATED) # # WARNING: avoid using this option if possible, instead use ACLs. # # Sometimes the Redis server has certain commands, that are needed for Sentinel # to work correctly, renamed to unguessable strings. This is often the case # of CONFIG and SLAVEOF in the context of providers that provide Redis as # a service, and don\u0026#39;t want the customers to reconfigure the instances outside # of the administration console. # # In such case it is possible to tell Sentinel to use different command names # instead of the normal ones. For example if the master \u0026#34;mymaster\u0026#34;, and the # associated replicas, have \u0026#34;CONFIG\u0026#34; all renamed to \u0026#34;GUESSME\u0026#34;, I could use: # # SENTINEL rename-command mymaster CONFIG GUESSME # # After such configuration is set, every time Sentinel would use CONFIG it will # use GUESSME instead. Note that there is no actual need to respect the command # case, so writing \u0026#34;config guessme\u0026#34; is the same in the example above. # # SENTINEL SET can also be used in order to perform this configuration at runtime. # # In order to set a command back to its original name (undo the renaming), it # is possible to just rename a command to itself: # # SENTINEL rename-command mymaster CONFIG CONFIG # HOSTNAMES SUPPORT # # Normally Sentinel uses only IP addresses and requires SENTINEL MONITOR # to specify an IP address. Also, it requires the Redis replica-announce-ip # keyword to specify only IP addresses. # # You may enable hostnames support by enabling resolve-hostnames. Note # that you must make sure your DNS is configured properly and that DNS # resolution does not introduce very long delays. # SENTINEL resolve-hostnames no # When resolve-hostnames is enabled, Sentinel still uses IP addresses # when exposing instances to users, configuration files, etc. If you want # to retain the hostnames when announced, enable announce-hostnames below. # SENTINEL announce-hostnames no # When master_reboot_down_after_period is set to 0, Sentinel does not fail over # when receiving a -LOADING response from a master. This was the only supported # behavior before version 7.0. # # Otherwise, Sentinel will use this value as the time (in ms) it is willing to # accept a -LOADING response after a master has been rebooted, before failing # over. SENTINEL master-reboot-down-after-period mymaster 0   启动哨兵redis-sentinel ./sentinel.conf\n如果主服务器宕机后重新连接，只能作为从服务器使用，因为主服务器已经选出\n优点\n 哨兵集群，基于主从复制，所以包含了主从复制的优点 主从可以自动切换，系统可用性更好 哨兵模式就是主从模式的升级，手动到自动，更加健壮  缺点\n redis不好在线扩容，集群容量一旦到达上限，在线扩容十分麻烦 实现哨兵模式的配置非常繁琐麻烦  Redis缓存穿透和雪崩 缓存穿透 概念 缓存穿透是指用户查询的数据在redis缓存中不存在，然后向数据库中查询也没有查到数据导致查询失败。这种现象发生很多次导致给数据库增加很大压力，这就是缓存穿透。比如在秒杀中，请求量剧增但是缓存没有命中导致服务器压力剧增。\n解决方案   布隆过滤器\n布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合就丢弃，避免了对底层数据库造成压力。\n  缓存空对象\n当数据库没有命中时，将空对象加到缓存中，同时设置一个过期时间，如果用户再查这个对象就会命中缓存，保护了底层数据库。\n但是这种方法会存在两个问题：\n 存储空值没有意义，并且会有越来越多没有意义的键 即使对空值设置了过期时间，如果原来没有值的对象被存到了数据库中就会导致一段时间缓存的值和数据库中的数据不一致的问题。  缓存击穿 概念 如果缓存中的某一个key非常热点，有大量的请求命中这个key，那么在这个key失效的瞬间，这些请求就会访问数据库，给数据库带来巨大的压力。\n解决方案   设置热点数据不过期\n不过期就会一直命中，但是可能会浪费空间\n  加互斥锁\n使用分布式锁，保证对于每个key同时只有一个线程去查询数据库，其他的线程没有获得分布式锁的权限，因此需要等待。这种方式将高并发的压力转移到了分布式锁上，对分布式锁的考验很大。\n  缓存雪崩 概念 缓存雪崩是指在某一个时间段缓存集中失效，或者是redis服务器宕机。原因是某些热点数据在同一时间被加入到缓存中并且过期时间也一致，这样就导致了在同一时间失效。服务器宕机带来的雪崩，其访问量是不可知的，所以有可能给数据库带来巨大的压力。\n解决方案   redis高可用\n增加redis服务器，搭建集群，高可用。\n  限流降级\n在缓存失效后，通过加锁或者队列来控制读数据库的线程数量，比如对同一个key只允许一个线程查询数据并写入缓存，其他线程只能等待。或者是将一些无关的服务停掉\n  数据预热\n在正式部署之前，将可能的热点数据全部访问一遍，使这些数据写入缓存。在即将发生大量并发请求前手动触发加载缓存，设置不同的过期时间，就能防止在某一时间同时失效的问题。\n    ","date":"2022-08-14T00:00:00Z","image":"https://WangZichen99.github.io/img/2022/11/autumn_forest.jpg","permalink":"https://WangZichen99.github.io/p/redisnote/","title":"Redis笔记"},{"content":"NginxNote 1、介绍   反向代理 （1）正向代理\n 在客户端配置代理服务器，通过代理服务器进行访问   （2）反向代理\n 客户端无需配置，将请求发送到反向代理服务器，反向代理服务器从真实服务器获取数据后返回到客户端。此时反向代理服务器和真实服务器被看做一个服务器，暴露的是反向代理服务器，隐藏了真实服务器的ip地址    负载均衡\n 将客户端的请求分发到不同服务器上     动静分离\n 使用不同的服务器解析动态页面和静态页面，加快解析速度，降低单个服务器的压力     2、安装Nginx  xshell连接linux操作系统  下载nginx 使用sudo -命令切换到root用户 安装编译工具及库文件yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel 安装PCRE 1 2  cd /usr/local/src wget http://downloads.sourceforge.net/project/pcre/pcre/8.45/pcre-8.45.tar.gz    解压tar -zxvf pcre-8.45.tar.gz 编译安装 1 2 3  cd pcre-8.45 ./configure make \u0026amp;\u0026amp; make install    查看版本pcre-config --version 上传nginx安装包并解压tar -zxvf nginx-1.22.0.tar.gz 编译安装  1 2 3  cd nginx-1.22.0 ./configure make \u0026amp;\u0026amp; make install   安装成功后，在/usr/local/nginx/sbin/下有nginx的启动脚本，启动nginx  1 2  cd /usr/local/nginx/sbin/ ./nginx   查看是否成功启动ps -ef|grep nginx  3、配置Nginx开放80端口 nginx配置文件位置在/usr/local/nginx/conf/nginx.conf中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  #开启防火墙 service firewalld start #重启防火墙 service firewalld restart #关闭防火墙 service firewalld stop #查看开放的端口号 firewall-cmd --list-all #设置添加http服务 firewall-cmd --add-service=http --permanent #设置开放的端口号, --permanent表示持久的 firewall-cmd --add-port=80/tcp --permanent #移除端口号 firewall-cmd --remove-port=80/tcp --permanent #重启防火墙 firewall-cmd --reload   在浏览器中输入linux的ip地址可以看到nginx的页面 4、Nginx常用命令  必须在/usr/local/nginx/sbin中执行命令   查看nginx版本号  1  ./nginx -v   启动nginx  1  ./nginx   安全退出nginx  1  ./nginx -s quit   关闭nginx  1  ./nginx -s stop   重新加载nginx  1  ./nginx -s reload   5、Nginx配置文件  nginx配置文件位置：/usr/local/nginx/conf/nginx.conf  5.1、配置文件组成部分 5.1.1、全局块  从配置文件开始到events块之前的内容，包含一些nginx服务器运行的配置命令，例如：用户组、worker process数、进程PID存放路径、日志路径等等  1  worker_process 1; 值越大，可支持的并发量越大，一般设置成CPU核心数或auto   5.1.2、events块  events块设置的是nginx服务器与用户的网络连接，例如：是否允许同时接收多个网络连接，每个worker_process支持的最大连接数等等，这部分配置对nginx的性能影响较大，在实际中应该灵活配置  1  worker_connections 1024; 每个worker process支持的最大连接数为1024   5.1.3、http块  配置最频繁的部分，例如：代理、缓存和日志等等，http块包括http全局块和server块   http全局块：包括文件引入、MIME-TYPE定义、日志定义、连接超时时间、单链接请求上限数等等 server块：和虚拟主机有密切关系，每个http块可以包含多个server块，每个server块就相当于一个虚拟主机，server块可以分为全局server块和location块，一个server块可以包含多个location块  全局server块：配置虚拟主机的监听配置和虚拟主机的名称及IP配置等等 location块：根据url对特定的请求做特定的处理，地址定向、数据缓存和应答控制等功能    6、Nginx反向代理   准备工作：安装tomcat\n  安装jdk\n1  yum install -y java-1.8.0-openjdk     查看是否安装成功\n1  java -version     查看jdk安装位置，默认路径为/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.332.b09-1.el7_9.x86_64/jre/bin/java\n1  find / -name \u0026#39;java\u0026#39;     创建文件夹\n1  mkdir /usr/local/tomcat     下载tomcat\n1  wget https://dlcdn.apache.org/tomcat/tomcat-9/v9.0.64/bin/apache-tomcat-9.0.64.tar.gz --no-check-certificate     解压\n1  tar -zxvf apache-tomcat-9.0.64.tar.gz     添加防火墙端口\n1  firewall-cmd --add-port=8080/tcp --permanent \u0026amp;\u0026amp; firewall-cmd --reload     启动tomcat\n1 2 3  cd apache-tomcat-9.0.64/bin/ ./startup.sh     访问8080端口查看\n    反向代理过程\n  nginx配置\n   注意：\n proxy_pass只是替换server_name:listen，location不会改变，所以如果proxy_pass上没有location，就会404 location ~ /user/ 表示使用正则匹配，并且区分大小写，如果url中包含user就响应 \u0026gt;    ~* 表示正则匹配，并且不区分大小写   - **=** 表示严格匹配，如果匹配成功则立即处理该请求\r  7、Nginx负载均衡  nginx配置    nginx负载均衡分配策略\n 轮询（默认）：每个请求按照时间顺序注意分配到不同服务器上，如果某一服务器挂掉，自动剔除改服务器 weight：权重默认为1，权重越高，分配到改服务器上的请求越多 ip_hash：每个请求按访问ip的hash结果分配，每个请求固定访问某一台服务器，可以解决session共享问题  fair（第三方）：按照后端响应时间分配，最短响应时间优先    8、Nginx动静分离   动静分离指将动态请求与静态请求分开，实现角度分为两种：\n 将静态文件放在单独的静态服务器上访问（主流方案） 2. 静态文件和动态文件放在同一个服务器上，通过location指定不同的后缀名实现静态文件的区分。通过expires参数设置浏览器缓存过期时间可以减少客户端与服务端之间的请求，过期时间由浏览器验证，到达过期时间后向服务端发送请求对比静态文件最后更新时间，如果有变化则从服务器获取最新静态文件，这种方法适合不经常变动的静态资源    nginx配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  location / { root /app/static/; autoindex on; } location /html/ { root /app/static/; index index.html index.htm; autoindex on; } location /img/ { root /app/static/; autoindex on; }     9、Nginx高可用  当反向代理服务器挂掉后会导致用户无法访问服务端，所以需要增加一台Nginx反向代理服务器来保证高可用    当主服务器挂掉后keepalived会检测到服务器状态，将虚拟ip映射到备用服务器上，保证客户端的正常访问\n  准备工作：\n  安装keepalived\n1 2 3 4 5  # yum安装keepalived yum install keepalived -y # 查看版本 keepalived -v     keepalived配置文件位置：/etc/keepalived/keepalived.conf\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  ! Configuration File for keepalived global_defs { #notification_email { # 通知邮件，一般不用 # acassen@firewall.loc # failover@firewall.loc # sysadmin@firewall.loc #} #notification_email_from Alexandre.Cassen@firewall.loc smtp_server 192.168.200.1 smtp_connect_timeout 30 router_id LVS_DEVEL # 标识本节点字符串 vrrp_skip_check_adv_addr vrrp_strict chk_http_port { # 检查主服务器状态执行脚本配置 script \u0026#34;/usr/local/src/nginx_check.sh\u0026#34; # 脚本位置 interval 2 # 执行脚本时间间隔 weight 2 } vrrp_garp_interval 0 vrrp_gna_interval 0 } vrrp_instance VI_1 { state MASTER # 主服务器为MASTER，备服务器为BACKUP interface ens33 # 网卡 virtual_router_id 51 # 主备服务器需要相同 priority 100 # 优先级，主服务器大于备服务器 advert_int 1 # MASTER和BACKUP节点之间的同步检查时间间隔，单位为秒 authentication { # 验证类型和验证密码 auth_type PASS auth_pass 1111 } virtual_ipaddress { # 虚拟IP地址池，可以多个IP 192.168.200.16 192.168.200.17 192.168.200.18 } }     nginx_check.sh\n1 2 3 4 5 6 7 8 9  #!/bin/bash  if [ `ps -C nginx --no-header |wc -l` -eq 0];then /usr/local/nginx/sbin/nginx sleep 2 if [ `ps -C nginx --no-header |wc -l` -eq 0];then killall keepalived # systemctl stop keepalived fi fi     启动keepalived\n1  systemctl start keepalived.service         通过ip a可以查看到虚拟ip\n  10、Nginx原理  nginx分为master进程和worker进程，其中worker进程可能有多个，当客户端发送请求后，master收到客户端的请求，所有的worker进程会争抢客户端的请求，然后进行发送到服务端处理 多个worker进程的好处：  在reload时，没有争抢请求的worker进程可以进行reload，有利于热部署 每个worker是独立的进程，如果某一个worker进程挂掉，其他worker还可以正常工作，worker进程的数量通常和服务器cpu数相等       worker发送请求占用了几个连接数？ \u0026gt; \u0026gt; 2个（静态请求）或4个（动态请求）\n  如果Nginx有一个master，四个worker，每个worker最大连接数为1024，那么最大并发数是多少？ \u0026gt; \u0026gt; 如果是静态请求，并发数为4（worker的数量） * 1024（worker最大连接数） / 2 \u0026gt; \u0026gt; 如果是动态请求，并发数为4 * 1024 / 4\n   ","date":"2022-07-24T00:00:00Z","image":"https://WangZichen99.github.io/img/2022/07/colorful_river.jpg","permalink":"https://WangZichen99.github.io/p/nginxnote/","title":"Nginx笔记"},{"content":"SpringBoot 1、原理初探 pom.xml\n spring-boot-dependencies：核心依赖，在父工程中 在引入springboot依赖时不需要指定版本就是因为有这个版本库  启动器\n  1 2 3 4  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;    启动器就是springboot的启动场景，会自动导入-web环境的所有依赖 springboot将所有的功能场景，都变成了一个个启动器 以后需要什么功能就直接添加启动器就可以了  主程序 @SpringBootApplication：标注这个类是一个springboot的应用\n@SpringBootConfiguration：@SpringBootConfiguration是springboot的配置，其底层还是@Configuration\n@EnableAutoConfiguration：自动配置注解（重要）\n@AutoConfigurationPackage：自动配置包\n@Import({Registrar.class})：导入自动配置包的注册类\n@Import({AutoConfigurationImportSelector.class})：导入了AutoConfigurationImportSelector选择器\n1 2 3 4  //获取自动配置的实体的方法 getAutoConfigurationEntry(AutoConfigurationMetadata, AnnotationMetadata) //方法中获取候选配置项 List\u0026lt;String\u0026gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);   1 2  //获取所有EnableAutoConfiguration注解的配置项返回 List\u0026lt;String\u0026gt; configurations = SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class, beanClassLoader);   1 2  //从META-INF/spring.factories\u0026#34;中获取项目资源和系统资源（遍历文件后封装成Properties） loadSpringFactories(ClassLoader)   spring-boot-autoconfigure.jar/META-INF/spring.factories文件中包含了所有springboot的自动配置\nspring.factories中的AutoConfiguration类都是容器中的一个组件，最后都加入到容器中 当满足了@ConditionalOnClass注解中的条件之后（就导入了对应的starter），自动配置才会生效 自动配置生效后，各个配置类就会向容器中添加各种组件，这些组件的属性值就是从对应的properties文件中 获取的，并且这些属性与yaml配置文件是绑定的。\n@ConfigurationProperties绑定配置文件中的配置\n自动配置就是springboot自动将spring.factories中的组件注入到容器中供用户直接使用\n 判断应用的类型是不是Web项目 查找并加载所有可用的初始化器，设置到initializers属性中 找出所有的应用程序监听器，设置到listener中 设置main方法的定义类，加载运行的主类  可以通过在配置文件中配置debug=true来查看哪些配置类生效了，哪些没有生效\n2、YMAL配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #键值对name:wzc#对象student:name:wzcage:22stu:{name: wzc, age:22}#行内写法#数组subject:- chinese- math- englishsub:[chinese, math, english]#行内写法  2.1、给属性赋值的几种方式  使用ymal  1 2 3 4 5 6 7 8 9 10 11 12 13 14  person:name:wzcage:22happy:truebirthday:1999/10/12map:hobby:playlist:- a- b- cdog:name:niuniuage:3  1 2 3 4 5 6 7 8 9 10 11 12  @Component @Data @ConfigurationProperties(prefix = \u0026#34;person\u0026#34;) public class Person { private String name; private Integer age; private Boolean happy; private Date birthday; private Map\u0026lt;String, Object\u0026gt; map; private List\u0026lt;Object\u0026gt; list; private Dog dog; }   @ConfigurationProperties注解会从配置文件中寻找和prefix同名的对象注入到容器中\n使用properties person.properties  1 2  name=wzc age=22   1 2 3 4 5 6 7 8 9 10 11 12 13 14  @Component @Data @PropertySource(\u0026#34;classpath:person.properties\u0026#34;) public class Person { @Value(\u0026#34;${name}\u0026#34;) private String name; @Value(\u0026#34;${age}\u0026#34;) private Integer age; private Boolean happy; private Date birthday; private Map\u0026lt;String, Object\u0026gt; map; private List\u0026lt;Object\u0026gt; list; private Dog dog; }   使用@PropertySource选择properties文件，然后使用spel表达式对属性进行赋值\n松散绑定\n在yml中的-后的字母默认是大写的，last-name对应着实体类中的lastName\nJSR303数据校验\n1 2 3  @Null @NotNull ...   2.2、多环境配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  spring:profiles:active:dev---spring:profiles:devserver:port:8080---spring:profiles:testserver:port:8081---spring:profiles:proserver:port:8082  3、web开发 3.1、静态资源 看源码：WebMvcAutoConfiguration.class\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  public class WebMvcAutoConfiguration { public void addResourceHandlers(ResourceHandlerRegistry registry) { /** * 第三种方式：自己配置spring.mvc.static-path-pattern */ if (!this.resourceProperties.isAddMappings()) { logger.debug(\u0026#34;Default resource handling disabled\u0026#34;); } else { Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl(); /** * 第一种方法：使用webjars引入静态资源，webjars会以maven的形式导入静态资源， * springboot会到maven包中的/META-INF/resources/webjars/目录下寻找静态资源 */ if (!registry.hasMappingForPattern(\u0026#34;/webjars/**\u0026#34;)) { this.customizeResourceHandlerRegistration(registry .addResourceHandler(new String[]{\u0026#34;/webjars/**\u0026#34;}) .addResourceLocations(new String[]{\u0026#34;classpath:/META-INF/resources/webjars/\u0026#34;}) .setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl)); } /** * 第二种方法：springboot会先从mvcProperties中获取staticPathPattern，默认值为/** * 然后会设置resourceLocations，默认值为\u0026#34;classpath:/META-INF/resources/\u0026#34;, * \u0026#34;classpath:/resources/\u0026#34;, \u0026#34;classpath:/static/\u0026#34;, \u0026#34;classpath:/public/\u0026#34; */ String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) { this.customizeResourceHandlerRegistration(registry .addResourceHandler(new String[]{staticPathPattern}) .addResourceLocations(WebMvcAutoConfiguration .getResourceLocations(this.resourceProperties.getStaticLocations())) .setCachePeriod(this.getSeconds(cachePeriod)) .setCacheControl(cacheControl)); } } } }   3.2 首页如何定制 看源码：WebMvcAutoConfiguration.class 3.3、Thymeleaf模板引擎  导入  1 2 3 4 5 6 7 8 9 10 11  \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.thymeleaf\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;thymeleaf-spring5\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.thymeleaf.extras\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;thymeleaf-extras-java8time\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;   将静态文件放在templates目录下  编写视图解析器  1 2 3 4 5 6 7  @Controller public class IndexController { @GetMapping(\u0026#34;/index\u0026#34;) public String index() { return \u0026#34;index\u0026#34;; } }   1 2 3 4  \u0026lt;!-- 所有的html元素都可以被thymeleaf接管，th:元素名 --\u0026gt; \u0026lt;p th:text=\u0026#34;${msg}\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;!-- 带转义的text --\u0026gt; \u0026lt;p th:utext=\u0026#34;${msg}\u0026#34;\u0026gt;\u0026lt;/p\u0026gt;   3.4、SpringMVC配置  自定义视图解析器  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  @Configuration public class MvcConfig implements WebMvcConfigurer { /** * 如果想自定义mvc的功能，实现mvc的组件，然后交给springboot会自动装配 * @return */ @Bean public ViewResolver getViewResolver() { return new ViewResolver(); } /** * 自动以视图解析器，实现ViewResolver接口 */ public static class ViewResolver implements org.springframework.web.servlet.ViewResolver { @Override public View resolveViewName(String s, Locale locale) throws Exception { return null; } } }   日期转换  默认yyyy/MM/dd\n视图跳转  如果需要扩展SpringMvc，官方建议在类上添加@Configuration注解，并实现WebMVCConfigurer接口，然后重写其中的方法\n3.5、员工管理系统 3.5.1、首页实现 使用视图跳转让thymeleaf接管\n1 2 3 4 5 6 7 8 9 10 11 12 13  @Configuration public class MvcConfig implements WebMvcConfigurer { /** * 视图跳转 */ @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\u0026#34;/\u0026#34;).setViewName(\u0026#34;index\u0026#34;); registry.addViewController(\u0026#34;/index\u0026#34;).setViewName(\u0026#34;index\u0026#34;); registry.addViewController(\u0026#34;/home\u0026#34;).setViewName(\u0026#34;index\u0026#34;); } }   在页面中url地址使用@{}\n3.5.2、国际化  建立三个properties文件分别配置页面上需要国际化的不同语言  修改html页面中对应的  中英文切换按钮，需要自定义LocaleResolver组件并注入到spring容器中  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public class LocalResolver implements LocaleResolver { /** * 解析请求 * @param request * @return */ @Override public Locale resolveLocale(HttpServletRequest request) { String language = request.getParameter(\u0026#34;lang\u0026#34;); if (!StringUtils.isEmpty(language)) { String[] split = language.split(\u0026#34;_\u0026#34;); return new Locale(split[0], split[1]); } return Locale.getDefault(); } @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) { } }   3.5.3、登录和登录拦截器 登录和退出接口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  @Controller public class LoginController { @PostMapping(\u0026#34;/login\u0026#34;) public String login(@RequestParam(\u0026#34;username\u0026#34;) String username, @RequestParam(\u0026#34;password\u0026#34;) String password, Model model, HttpSession httpSession) { if (StringUtils.isEmpty(username) || StringUtils.isEmpty(password)) { model.addAttribute(\u0026#34;msg\u0026#34;, \u0026#34;用户名或密码错误！\u0026#34;); return \u0026#34;index\u0026#34;; } httpSession.setAttribute(\u0026#34;loginUser\u0026#34;, username); return \u0026#34;redirect:/dashboard\u0026#34;; } @GetMapping(\u0026#34;/signOut\u0026#34;) public String signOut(HttpSession httpSession) { httpSession.removeAttribute(\u0026#34;loginUser\u0026#34;); return \u0026#34;index\u0026#34;; } }   用户可以直接访问dashboard页面，所以需要配置拦截器\n1 2 3 4 5 6 7 8 9 10 11  public class LoginInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { if (ObjectUtils.isEmpty(request.getSession().getAttribute(\u0026#34;loginUser\u0026#34;))) { request.setAttribute(\u0026#34;msg\u0026#34;, \u0026#34;没有权限，请先登录！\u0026#34;); request.getRequestDispatcher(\u0026#34;/index\u0026#34;).forward(request, response); return false; } return true; } }   MvcConfig中配置拦截器\n3.5.4、查询信息和CRUD 实际开发中通常将通用的前端代码提取出来。使用th:fragment\n在页面中替换代码片段th:replace\n循环遍历数据th:each\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  \u0026lt;table class=\u0026#34;table table-striped table-sm\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;id\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;lastName\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;email\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;gender\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;department\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;birthday\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;operation\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr th:each=\u0026#34;employee:${employees}\u0026#34;\u0026gt; \u0026lt;td th:text=\u0026#34;${employee.getId()}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td th:text=\u0026#34;${employee.getLastName()}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td th:text=\u0026#34;${employee.getEmail()}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td th:text=\u0026#34;${employee.getGender() == 0 ? \u0026#39;女\u0026#39; : \u0026#39;男\u0026#39;}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td th:text=\u0026#34;${employee.getDepartment()}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td th:text=\u0026#34;${#dates.format(employee.getBirthday(), \u0026#39;yyyy-MM-dd\u0026#39;)}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;button class=\u0026#34;btn btn-sm btn-primary\u0026#34;\u0026gt;edit\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;btn btn-sm btn-danger\u0026#34;\u0026gt;delete\u0026lt;/button\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt;   增删改\n新增表单\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  \u0026lt;form th:action=\u0026#34;@{/insertEmp}\u0026#34; th:method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;LastName\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; class=\u0026#34;form-control\u0026#34; name=\u0026#34;lastName\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Email\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;email\u0026#34; class=\u0026#34;form-control\u0026#34; name=\u0026#34;email\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Gender\u0026lt;/label\u0026gt; \u0026lt;div class=\u0026#34;form-check form-check-inline\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; class=\u0026#34;form-check-input\u0026#34; name=\u0026#34;gender\u0026#34; value=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;form-check-label\u0026#34;\u0026gt;man\u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-check form-check-inline\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; class=\u0026#34;form-check-input\u0026#34; name=\u0026#34;gender\u0026#34; value=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;form-check-label\u0026#34;\u0026gt;women\u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Department\u0026lt;/label\u0026gt; \u0026lt;select name=\u0026#34;department.id\u0026#34; id=\u0026#34;dept\u0026#34; class=\u0026#34;form-control\u0026#34;\u0026gt; \u0026lt;option th:each=\u0026#34;dept:${departments}\u0026#34; th:value=\u0026#34;${dept.getId()}\u0026#34;\u0026gt;[[${dept.getDepartName()}]]\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Birthday\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;date\u0026#34; class=\u0026#34;form-control\u0026#34; name=\u0026#34;birthday\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;btn btn-primary\u0026#34;\u0026gt;insert\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt;   修改表单\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  \u0026lt;form th:action=\u0026#34;@{/editEmp}\u0026#34; th:method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34; hidden\u0026gt; \u0026lt;label\u0026gt;Id\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; class=\u0026#34;form-control\u0026#34; name=\u0026#34;id\u0026#34; th:value=\u0026#34;${emp.getId()}\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;LastName\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; class=\u0026#34;form-control\u0026#34; name=\u0026#34;lastName\u0026#34; th:value=\u0026#34;${emp.getLastName()}\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Email\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;email\u0026#34; class=\u0026#34;form-control\u0026#34; name=\u0026#34;email\u0026#34; th:value=\u0026#34;${emp.getEmail()}\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Gender\u0026lt;/label\u0026gt; \u0026lt;div class=\u0026#34;form-check form-check-inline\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; class=\u0026#34;form-check-input\u0026#34; name=\u0026#34;gender\u0026#34; value=\u0026#34;1\u0026#34; th:checked=\u0026#34;${emp.getGender() == 1}\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;form-check-label\u0026#34;\u0026gt;man\u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-check form-check-inline\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; class=\u0026#34;form-check-input\u0026#34; name=\u0026#34;gender\u0026#34; value=\u0026#34;2\u0026#34; th:checked=\u0026#34;${emp.getGender() == 2}\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;form-check-label\u0026#34;\u0026gt;women\u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Department\u0026lt;/label\u0026gt; \u0026lt;select name=\u0026#34;department.id\u0026#34; id=\u0026#34;dept\u0026#34; class=\u0026#34;form-control\u0026#34;\u0026gt; \u0026lt;option th:each=\u0026#34;dept:${departments}\u0026#34; th:value=\u0026#34;${dept.getId()}\u0026#34; th:selected=\u0026#34;${emp.getDepartment() != null ? emp.getDepartment().getId() == dept.getId() : false}\u0026#34;\u0026gt;[[${dept.getDepartName()}]]\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Birthday\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;date\u0026#34; class=\u0026#34;form-control\u0026#34; name=\u0026#34;birthday\u0026#34; th:value=\u0026#34;${#dates.format(emp.getBirthday(), \u0026#39;yyyy-MM-dd\u0026#39;)}\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;btn btn-primary\u0026#34;\u0026gt;save\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt;   接口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  @Controller public class EmployeeController { @Autowired private EmployeeService employeeService; @Autowired private DepartmentDao departmentDao; @GetMapping(\u0026#34;/employees\u0026#34;) public String getEmployees(Model model) { model.addAttribute(\u0026#34;employees\u0026#34;, employeeService.getEmployees()); return \u0026#34;list\u0026#34;; } @GetMapping(\u0026#34;/insertPage\u0026#34;) public String insertPage(Model model) { model.addAttribute(\u0026#34;departments\u0026#34;, departmentDao.getDepartments()); return \u0026#34;add\u0026#34;; } @PostMapping(\u0026#34;/insertEmp\u0026#34;) public String insertEmployee(Employee employee) { employeeService.insertEmployee(employee); return \u0026#34;redirect:/employees\u0026#34;; } @GetMapping(\u0026#34;/editPage/{id}\u0026#34;) public String editPage(@PathVariable Integer id, Model model) { model.addAttribute(\u0026#34;departments\u0026#34;, departmentDao.getDepartments()); model.addAttribute(\u0026#34;emp\u0026#34;, employeeService.getEmployeeById(id)); return \u0026#34;edit\u0026#34;; } @PostMapping(\u0026#34;/editEmp\u0026#34;) public String editEmployee(Employee employee) { employeeService.editEmployee(employee); return \u0026#34;redirect:/employees\u0026#34;; } @GetMapping(\u0026#34;/deleteEmp/{id}\u0026#34;) public String deleteEmployee(@PathVariable Integer id) { employeeService.deleteEmployee(id); return \u0026#34;redirect:/employees\u0026#34;; } }   404页面处理\n4.1、JDBC 导包\n1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;   配置\n1 2 3 4 5 6  spring:datasource:username:rootpassword:123456url:jdbc:mysql://localhost:3306/mybatis?useUnicode=true\u0026amp;characterEncoding=utf-8\u0026amp;serverTimezone=Asia/Shanghaidriver-class-name:com.mysql.cj.jdbc.Driver  测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  @SpringBootTest class SpringbootStudyApplicationTests { @Autowired private DataSource dataSource; @Test void contextLoads() throws SQLException { System.out.println(dataSource.getClass()); Connection connection = dataSource.getConnection(); System.out.println(connection); connection.close(); } }   spring默认数据源：class com.zaxxer.hikari.HikariDataSource\nJdbcTemplate是spring已经配置好的模板，拿来即用\nCRUD\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  @RestController public class JdbcController { @Autowired private JdbcTemplate jdbcTemplate; @GetMapping(\u0026#34;/userList\u0026#34;) public List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; getUserList() { String sql = \u0026#34;select * from mybatis.user\u0026#34;; List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; mapList = jdbcTemplate.queryForList(sql); return mapList; } @GetMapping(\u0026#34;/addUser\u0026#34;) public String addUser() { String sql = \u0026#34;insert into mybatis.user(id, name, pwd) values (4, \u0026#39;小明\u0026#39;, \u0026#39;123456\u0026#39;)\u0026#34;; jdbcTemplate.update(sql); return \u0026#34;insert success\u0026#34;; } @GetMapping(\u0026#34;/updateUser/{id}\u0026#34;) public String updateUser(@PathVariable(\u0026#34;id\u0026#34;) String id) { String sql = \u0026#34;update mybatis.user set name = ?, pwd = ? where id = \u0026#34; + id; jdbcTemplate.update(sql, new Object[]{\u0026#34;小红\u0026#34;, \u0026#34;123456\u0026#34;}); return \u0026#34;update success\u0026#34;; } @GetMapping(\u0026#34;/deleteUser/{id}\u0026#34;) public String deleteUser(@PathVariable(\u0026#34;id\u0026#34;) String id) { String sql = \u0026#34;delete from mybatis.user where id = \u0026#34; + id; jdbcTemplate.update(sql); return \u0026#34;delete success\u0026#34;; } }   4.2、Druid 导包\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.23\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.17\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;   配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  datasource:username:rootpassword:123456url:jdbc:mysql://localhost:3306/mybatis?useUnicode=true\u0026amp;characterEncoding=utf-8\u0026amp;serverTimezone=Asia/Shanghaidriver-class-name:com.mysql.cj.jdbc.Drivertype:com.alibaba.druid.pool.DruidDataSource# 数据源配置initialSize:5minIdle:5maxActive:20maxWait:60000timeBetweenEvictionRunsMillis:60000minEvictableIdleTimeMillis:300000validationQuery:select 1 from dualtestWhileIdle:truetestOnBorrow:falsetestOnReturn:falsepoolPreparedStatements:true# 配置监控统计拦截的filters, stat: 监控统计, log4j: 日志记录, wall: 防御sql注入filters:stat, log4j, wallmaxPoolPreparedStatementPreConnectionSize:20userGLobalDataSourceStat:trueconnectionProperties:druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500  配置类注入bean及配置Druid监控页面\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  @Configuration public class DruidConfig { //注入bean  @ConfigurationProperties(prefix = \u0026#34;spring.datasource\u0026#34;) @Bean public DataSource druidDataSource() { return new DruidDataSource(); } //后台监控配置，相当于原来的web.xml  //因为SpringBoot内置了Servlet容器，所以没有web.xml，使用ServletRegistrationBean注入即可替代  @Bean public ServletRegistrationBean statViewServlet() { ServletRegistrationBean\u0026lt;StatViewServlet\u0026gt; bean = new ServletRegistrationBean(new StatViewServlet(), \u0026#34;/druid/*\u0026#34;); //配置账号密码  HashMap\u0026lt;String, String\u0026gt; initParam = new HashMap\u0026lt;\u0026gt;(); initParam.put(\u0026#34;loginUsername\u0026#34;, \u0026#34;admin\u0026#34;); initParam.put(\u0026#34;loginPassword\u0026#34;, \u0026#34;admin\u0026#34;); //允许访问用户  initParam.put(\u0026#34;allow\u0026#34;, \u0026#34;\u0026#34;); bean.setInitParameters(initParam); return bean; } }   4.2、整合Mybatis 导包\n1 2 3 4 5  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.spring.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   配置\n1 2 3  mybatis:type-aliases-package:com.wzc.springbootstudy.pojo#别名设置mapper-locations:classpath:mybatis/mapper/*.xml#mapper位置  xml、mapper、service、controller省略\n5、SpringSecurity AOP思想\nSpring Security是Spring Boot底层安全模块默认的技术选型，使用Spring Security只需要导入spring-boot-starter-security 并进行少量配置即可\n几个比较重要的类：\n WebSecurityConfigurerAdapter：自定义Security策略 AuthenticationManagerBuilder：自定义认证策略 @EnableWebSecurity：开启WebSecurity模式  SpringSecurity的两个主要目标是“认证（Authentication）”和“授权（Authorization）”\n导包\n1 2 3 4  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-security\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;   1 2 3 4 5  \u0026lt;!--thymeleaf整合spring security--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.thymeleaf.extras\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;thymeleaf-extras-springsecurity5\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;   自定义配置类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { /** * 授权 * @param http * @throws Exception */ @Override protected void configure(HttpSecurity http) throws Exception { //首页所有人都可以访问，特定的页面只有特定的角色才能访问  http.formLogin().loginPage(\u0026#34;/securityLogin\u0026#34;).loginProcessingUrl(\u0026#34;/login\u0026#34;).defaultSuccessUrl(\u0026#34;/security\u0026#34;).and()//没有权限访问自动进入登录页  .rememberMe().rememberMeParameter(\u0026#34;rememberMe\u0026#34;).and()//记住我功能，默认参数名为remember-me  .logout().logoutSuccessUrl(\u0026#34;/security\u0026#34;).and()//注销页面  .authorizeRequests() .antMatchers(\u0026#34;/security\u0026#34;).permitAll() .antMatchers(\u0026#34;/securityLevel1/**\u0026#34;).hasRole(\u0026#34;vip1\u0026#34;) .antMatchers(\u0026#34;/securityLevel2/**\u0026#34;).hasRole(\u0026#34;vip2\u0026#34;) .antMatchers(\u0026#34;/securityLevel3/**\u0026#34;).hasRole(\u0026#34;vip3\u0026#34;).and() .csrf().disable(); } /** * 认证 * @param auth * @throws Exception */ @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { //inMemoryAuthentication从内存中取数据，passwordEncoder密码编码规则，withUser添加用户  BCryptPasswordEncoder bCryptPasswordEncoder = new BCryptPasswordEncoder(); auth.inMemoryAuthentication().passwordEncoder(bCryptPasswordEncoder) .withUser(\u0026#34;wzc\u0026#34;).password(bCryptPasswordEncoder.encode(\u0026#34;123456\u0026#34;)).roles(\u0026#34;vip1\u0026#34;, \u0026#34;vip2\u0026#34;).and() .withUser(\u0026#34;admin\u0026#34;).password(bCryptPasswordEncoder.encode(\u0026#34;admin\u0026#34;)).roles(\u0026#34;vip1\u0026#34;, \u0026#34;vip2\u0026#34;, \u0026#34;vip3\u0026#34;).and() .withUser(\u0026#34;guest\u0026#34;).password(bCryptPasswordEncoder.encode(\u0026#34;123456\u0026#34;)).roles(\u0026#34;vip3\u0026#34;); } }   index.html\n1  xmlns:sec=\u0026#34;http://www.thymeleaf.org/extras/spring-security\u0026#34;   6、Shiro 6.1、快速开始 shiro架构中的几个对象：\n Subject：代表当前用户，与Subject的所有交互都会委托给SecurityManager SecurityManager：负责管理所有的Subject，是shiro的心脏，所有具体的交互都通过SecurityManager进行控制， 且负责进行认证、授权、会话、及缓存的管理 Authenticator：负责Subject认证逻辑 Authorizer：授权器，控制用户是否有权进行相应操作 Realm：安全试题数据源 SessionManager：管理Session生命周期 CacheManager：缓存控制器，管理用户、角色、权限等缓存 Cryptography：密码模块   导入依赖  1 2 3 4 5  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shiro\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shiro-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.6.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   添加配置文件ini  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  [users] # user \u0026#39;root\u0026#39; with password \u0026#39;secret\u0026#39; and the \u0026#39;admin\u0026#39; role root = secret, admin # user \u0026#39;guest\u0026#39; with the password \u0026#39;guest\u0026#39; and the \u0026#39;guest\u0026#39; role guest = guest, guest # user \u0026#39;presidentskroob\u0026#39; with password \u0026#39;12345\u0026#39; (\u0026#34;That\u0026#39;s the same combination on # my luggage!!!\u0026#34; ;)), and role \u0026#39;president\u0026#39; presidentskroob = 12345, president # user \u0026#39;darkhelmet\u0026#39; with password \u0026#39;ludicrousspeed\u0026#39; and roles \u0026#39;darklord\u0026#39; and \u0026#39;schwartz\u0026#39; darkhelmet = ludicrousspeed, darklord, schwartz # user \u0026#39;lonestarr\u0026#39; with password \u0026#39;vespa\u0026#39; and roles \u0026#39;goodguy\u0026#39; and \u0026#39;schwartz\u0026#39; lonestarr = vespa, goodguy, schwartz [roles] # \u0026#39;admin\u0026#39; role has all permissions, indicated by the wildcard \u0026#39;*\u0026#39; admin = * # The \u0026#39;schwartz\u0026#39; role can do anything (*) with any lightsaber: schwartz = lightsaber:* # The \u0026#39;goodguy\u0026#39; role is allowed to \u0026#39;drive\u0026#39; (action) the winnebago (type) with # license plate \u0026#39;eagle5\u0026#39; (instance specific id) goodguy = winnebago:drive:eagle5   quickstart.java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71  public class ShiroQuickStart { private static final transient Logger log = LoggerFactory.getLogger(ShiroQuickStart.class); public static void main(String[] args) { //通过ini配置文件获得SecurityManager实例  Factory\u0026lt;SecurityManager\u0026gt; factory = new IniSecurityManagerFactory(\u0026#34;classpath:shiro.ini\u0026#34;); SecurityManager securityManager = factory.getInstance(); SecurityUtils.setSecurityManager(securityManager); //获得当前用户对象  Subject currentUser = SecurityUtils.getSubject(); //Session使用  Session session = currentUser.getSession(); session.setAttribute(\u0026#34;someKey\u0026#34;, \u0026#34;aValue\u0026#34;); String value = (String) session.getAttribute(\u0026#34;someKey\u0026#34;); if (value.equals(\u0026#34;aValue\u0026#34;)) { log.info(\u0026#34;Retrieved the correct value! [\u0026#34; + value + \u0026#34;]\u0026#34;); } //用户登录  if (!currentUser.isAuthenticated()) { UsernamePasswordToken token = new UsernamePasswordToken(\u0026#34;lonestarr\u0026#34;, \u0026#34;vespa\u0026#34;); token.setRememberMe(true); try { currentUser.login(token); } catch (UnknownAccountException uae) { log.info(\u0026#34;There is no user with username of \u0026#34; + token.getPrincipal()); } catch (IncorrectCredentialsException ice) { log.info(\u0026#34;Password for account \u0026#34; + token.getPrincipal() + \u0026#34; was incorrect!\u0026#34;); } catch (LockedAccountException lae) { log.info(\u0026#34;The account for username \u0026#34; + token.getPrincipal() + \u0026#34; is locked. \u0026#34; + \u0026#34;Please contact your administrator to unlock it.\u0026#34;); } catch (AuthenticationException ae) { //unexpected condition? error?  } } //打印身份信息  log.info(\u0026#34;User [\u0026#34; + currentUser.getPrincipal() + \u0026#34;] logged in successfully.\u0026#34;); //校验角色  if (currentUser.hasRole(\u0026#34;schwartz\u0026#34;)) { log.info(\u0026#34;May the Schwartz be with you!\u0026#34;); } else { log.info(\u0026#34;Hello, mere mortal.\u0026#34;); } //校验权限  if (currentUser.isPermitted(\u0026#34;lightsaber:wield\u0026#34;)) { log.info(\u0026#34;You may use a lightsaber ring. Use it wisely.\u0026#34;); } else { log.info(\u0026#34;Sorry, lightsaber rings are for schwartz masters only.\u0026#34;); } if (currentUser.isPermitted(\u0026#34;winnebago:drive:eagle5\u0026#34;)) { log.info(\u0026#34;You are permitted to \u0026#39;drive\u0026#39; the winnebago with license plate (id) \u0026#39;eagle5\u0026#39;. \u0026#34; + \u0026#34;Here are the keys - have fun!\u0026#34;); } else { log.info(\u0026#34;Sorry, you aren\u0026#39;t allowed to drive the \u0026#39;eagle5\u0026#39; winnebago!\u0026#34;); } //注销  currentUser.logout(); System.exit(0); } }   6.1、Shiro登录拦截 编写配置类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  @Configuration public class ShiroConfig { /** * 创建自定义Realm对象 * @return */ @Bean public ShiroRealm shiroRealm() { return new ShiroRealm(); } /** * 创建SecurityManager对象 * @param shiroRealm * @return */ @Bean public DefaultWebSecurityManager defaultWebSecurityManager(ShiroRealm shiroRealm) { DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(shiroRealm); return securityManager; } /** * 创建ShiroFilterFactoryBean对象 * @param defaultWebSecurityManager * @return */ @Bean public ShiroFilterFactoryBean shiroFilterFactoryBean(DefaultWebSecurityManager defaultWebSecurityManager) { ShiroFilterFactoryBean factoryBean = new ShiroFilterFactoryBean(); factoryBean.setSecurityManager(defaultWebSecurityManager); /** * 添加shiro内置过滤器 * anon: 无需认证就可以访问 * authc: 必须认证了才能访问 * user: 必须拥有记住我才能访问 * perms: 拥有对某个资源的权限才能访问 * roles:拥有某个角色权限才能访问 */ Map\u0026lt;String, String\u0026gt; filterMap = new LinkedHashMap(); filterMap.put(\u0026#34;/shiro/add\u0026#34;, \u0026#34;authc\u0026#34;); factoryBean.setFilterChainDefinitionMap(filterMap);//设置内置过滤器  factoryBean.setLoginUrl(\u0026#34;/shiro/login\u0026#34;);//设置登录url  return factoryBean; } }   自定义Realm对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  public class ShiroRealm extends AuthorizingRealm { @Autowired UserService userService; /** * 授权 * @param principalCollection * @return */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) { System.out.println(\u0026#34;授权\u0026#34;); User user = (User) principalCollection.getPrimaryPrincipal(); //根据数据库中的权限进行授权  if (!StringUtils.isEmpty(user.getPerms())) { SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); info.addStringPermission(user.getPerms()); return info; } return null; } /** * 认证 * @param authenticationToken * @return */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException { System.out.println(\u0026#34;认证\u0026#34;); UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken; User user = userService.queryByUserName(token.getUsername()); if (ObjectUtils.isEmpty(user)) { throw new UnknownAccountException();//用户名不存在！  } //密码校验由shiro完成  return new SimpleAuthenticationInfo(user, user.getPwd(), user.getName());//第一个参数为授权方法中principalCollection.getPrimaryPrincipal()的值  } }   导入thymeleaf-extras-shiro\n1 2 3 4 5  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.theborakompanioni\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;thymeleaf-extras-shiro\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   配置Bean整合thymeleaf\n1 2 3 4 5 6 7 8 9 10 11  @Configuration public class ShiroConfig { /** * 创建ShiroDialect整合thymeleaf * @return */ @Bean public ShiroDialect shiroDialect() { return new ShiroDialect(); } }   1  \u0026lt;html xmlns:shiro=\u0026#34;http://www.pollix.at/thymeleaf/shiro\u0026#34;\u0026gt;   1 2 3 4 5 6 7 8 9  \u0026lt;div shiro:guest=\u0026#34;\u0026#34;\u0026gt; \u0026lt;a th:href=\u0026#34;@{/shiro/login}\u0026#34;\u0026gt;login\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div shiro:hasPermission=\u0026#34;\u0026#39;user:add\u0026#39;\u0026#34;\u0026gt; \u0026lt;a th:href=\u0026#34;@{/shiro/add}\u0026#34;\u0026gt;add\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div shiro:user=\u0026#34;\u0026#34;\u0026gt; \u0026lt;a th:href=\u0026#34;@{/shiro/logout}\u0026#34;\u0026gt;logout\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt;   7、Swagger  导入依赖  1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-swagger2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.9.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-swagger-ui\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.9.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;   编写配置类  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  @Configuration @EnableSwagger2 public class SwaggerConfig { @Value(\u0026#34;${swagger.enable}\u0026#34;) private Boolean enable; @Bean public Docket docket() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() // .apis(RequestHandlerSelectors.none()) //不扫描所有接口  // .apis(RequestHandlerSelectors.any()) //扫描所有接口  .apis(RequestHandlerSelectors.basePackage(\u0026#34;com.wzc.springbootstudy.controller\u0026#34;)) //扫描包下的api接口  // .apis(RequestHandlerSelectors.withClassAnnotation(RestController.class)) //扫描类上有RestController注解的接口  // .apis(RequestHandlerSelectors.withMethodAnnotation(GetMapping.class)) //扫描方法上有GetMapping注解的接口  // .paths(PathSelectors.ant(\u0026#34;/shiro/**\u0026#34;)) //扫描路径下的api接口  .build() .enable(enable); } private ApiInfo apiInfo() { return new ApiInfo( \u0026#34;Swagger document\u0026#34;, \u0026#34;description\u0026#34;, \u0026#34;v1.0\u0026#34;, \u0026#34;https://www.wzc.com\u0026#34;, new Contact(\u0026#34;wzc\u0026#34;, \u0026#34;https://www.wzc.com\u0026#34;, \u0026#34;714479133@qq.com\u0026#34;), \u0026#34;Apache 2.0\u0026#34;, \u0026#34;https://www.apache.org/licenses/LICENSE-2.0\u0026#34;, new ArrayList\u0026lt;\u0026gt;() ); } }   实体类中的注解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  @Data @ApiModel(\u0026#34;用户\u0026#34;) public class User implements Serializable { @ApiModelProperty(\u0026#34;id\u0026#34;) private Integer id; @ApiModelProperty(\u0026#34;用户名\u0026#34;) private String name; @ApiModelProperty(\u0026#34;密码\u0026#34;) private String pwd; @ApiModelProperty(\u0026#34;年龄\u0026#34;) private Integer age; @ApiModelProperty(\u0026#34;邮箱\u0026#34;) private String email; @ApiModelProperty(\u0026#34;权限\u0026#34;) private String perms; }   效果\n接口类中的注解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  @Api(tags = \u0026#34;用户控制器\u0026#34;) @RestController public class UserController { @Autowired private UserMapper userMapper; @ApiOperation(value = \u0026#34;获取用户列表\u0026#34;, notes = \u0026#34;需要注意的地方\u0026#34;) @GetMapping(\u0026#34;/queryUserList\u0026#34;) public List\u0026lt;User\u0026gt; queryUserList() { return userMapper.queryUserList(); } }   效果\n8、异步任务 启动类上添加enable注解，开启异步 异步方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  @Service public class AsyncService { @Async public void testAsync() { try { for (int i = 0; i \u0026lt; 10; i++) { System.out.println(i + 1); Thread.sleep(1000); } } catch (InterruptedException e) { e.printStackTrace(); } } }   9、邮件任务  导包  1 2 3 4  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-mail\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;   相关类：\n MailSenderAutoConfiguration MailProperties MailSenderJndiConfiguration  配置  1 2 3 4 5 6 7 8 9 10  mail:username:714479133@qq.compassword:keqpddottxodbcfghost:smtp.qq.com# qq邮箱需要开启加密验证properties:mail:smtp:ssl:enable:true  测试  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class Test { /** * 发送邮件 */ private void simpleMailSend() { SimpleMailMessage simpleMailMessage = new SimpleMailMessage(); simpleMailMessage.setSubject(\u0026#34;测试springboot邮件发送\u0026#34;); simpleMailMessage.setText(\u0026#34;测试\u0026#34;); simpleMailMessage.setFrom(\u0026#34;714479133@qq.com\u0026#34;); simpleMailMessage.setTo(\u0026#34;714479133@qq.com\u0026#34;); javaMailSender.send(simpleMailMessage); } /** * 发送复杂邮件 */ private void mimeMailSend() throws MessagingException { MimeMessage mimeMessage = javaMailSender.createMimeMessage(); MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMessage, true); mimeMessageHelper.setSubject(\u0026#34;测试复杂邮件发送\u0026#34;); mimeMessageHelper.setText(\u0026#34;\u0026lt;p\u0026gt;html格式正文\u0026lt;/p\u0026gt;\u0026#34;, true); mimeMessageHelper.addAttachment(\u0026#34;file1.jpg\u0026#34;, new File(\u0026#34;E:\\\\Code\\\\javaWorkSpace\\\\springboot-study\\\\note\\\\img.png\u0026#34;)); mimeMessageHelper.setFrom(\u0026#34;714479133@qq.com\u0026#34;); mimeMessageHelper.setTo(\u0026#34;714479133@qq.com\u0026#34;); javaMailSender.send(mimeMessage); } }   10、定时任务 启动类上添加@EnableScheduling注解开启定时任务\n1 2 3 4 5 6 7 8 9 10 11  @Service public class ScheduledService { /** * cron表达式：秒 分 时 日 月 周 */ @Scheduled(cron = \u0026#34;0 0 12 * * ?\u0026#34;) public void ScheduleTask() { System.out.println(\u0026#34;每天12点执行一次！\u0026#34;); } }   ","date":"2022-07-09T11:18:24+08:00","image":"https://WangZichen99.github.io/img/2022/07/nature_park.jpg","permalink":"https://WangZichen99.github.io/p/springbootnote/","title":"SpringBoot笔记"},{"content":"《认知觉醒》读书笔记 第一章 大脑——一切问题的起源 第一节 大脑：重新认识你自己 三层大脑\n  演进过程   爬行动物 本能脑   哺乳动物 情绪脑   人类 理智脑    三层大脑对比  本能脑 低级 强大 婴儿时期趋于完善（2岁） 神经元细胞数量多，距离心脏近 运行速度快 控制大脑能力强 更接近原始社会-生存-及时享乐、避难趋易、急于求成   情绪脑 低级 次强 青春期早期（12岁）   理智脑 高级 弱小 成年早期（22岁） 数量少，距离远 速度慢且耗能 控制大脑能力弱 更接近现代社会   结果\n 明知读书重要，却转身掏出手机 明知跑步有益，却两天没了下文 明知要事优先，却围绕琐事打转  大多数时候我们以为自己在思考，实则都是对自身行为和欲望的合理化\n成长是克服天性的过程\n提升理智脑 ≠ 削弱本能脑和情绪脑\n理智脑指挥，本能脑行动\n第二节 焦虑的根源 焦虑的形式：\n 完成焦虑：内在欲望太广或时间安排太紧从而无法做到从容 定位焦虑：将起步的自己与他人取得的成就相比 选择焦虑：选择太多，不知道如何抉择 环境焦虑：环境迫使 难度焦虑：不下决心认真对待难度大的事情，而在周围打转  焦虑的原因：\n 总结起来就是：相同时做很多事，又想立即看到效果（欲望与能力差距较大） 人的一切痛苦本质上都是对自己的无能的愤怒 ———— 王小波  graph TD A(想同时做很多事) -- B(急于求成) -- E(天性) C(想不怎么努力就看到效果) -- D(避难趋易) -- E(天性)  第三节 耐心者得天下 宏观上：\n  复利效应：   舒适区边缘   微观上：\n 学习过程与权重  过程：学习————思考————行动————改变 权重：改变 \u0026gt; 行动 \u0026gt; 思考 \u0026gt; 学习 人们在学习过程中总是看到自己学习了多少，而不是看到自己改变了多少 书中的一两个观点改变了我 \u0026gt; 我今天读书5个小时   平台期   拥有耐心：\n 接纳天性（缺乏耐心） 延迟满足（该有的享受一点也不会少，只不过不是现在，而是在完成该做的之后） 提升认知，看到事情的深层意义 享受高级乐趣（学习的乐趣，健身的乐趣）取代低级乐趣（玩手机）  第二章 潜意识——生命留给我们的彩蛋 第一节 人生是一场消除模糊的比赛 意识分层：潜意识负责生理系统，意识负责社会系统\n意识分层导致的问题：模糊\n产生模糊的原因：\n 处理信息速度不对等 意识难以左右潜意识，但潜意识可以左右意识  人们不愿消除模糊，因为消除模糊意味着走出舒适区，人们不愿做这种高耗能的事情，而总是在重复那些已经掌握的事情，从而导致自己无法进步。\n所有的困难只因为我们对其的认知模糊，这种模糊阻碍了我们，导致拖延、不愿面对问题， 如果我们能够在一开始就主动消除模糊，就不会徒增烦恼\n所有的痛苦都不会凭空消失， 唯一的办法就是在它们变得模糊，在它们进入潜意识前正视它、拆解它。\n选择模糊会导致行动力不足， 解决办法是：细化过程，建立一条单行道，消除选择\n第二节 顶级的成长竟然是“凭感觉” 潜意识代表感性，意识代表理性。意识虽然理智但处理速度较慢，潜意识虽然更接近原始思想，但速度极快。\n两者之前的速度差距造成了模糊的认知。潜意识已经察觉到的信息，意识却无法捕捉。\n所以先用感性选择，再用理性思考。在读书时读到触动的地方马上停下，询问自己为什么触动，用理性进行思考。\n这种感性选择理性思考的方法就是小事听从你的脑，大事听从你的心。\n第三章 元认知——人类的终极能力 第一节 成长慢，是因为你不会“飞” 元认知能力可以被定义为自我审视，主动控制，防止被潜意识左右的能力。\n成长中我们在学校学习的主要是学习、理解、记忆能力，而观察、反思、判断、选择这种元认知能力却非常少用，这就是为什么有的人在走出学校之后自控能力并不是很强的原因，元认知需要我们主动锻炼，就像锻炼肌肉一样，越用越强。\n那么如何主动开启元认知能力呢？\n秘诀就是停下几秒，给理智脑一点思考的时间去自我审视，主动控制。\n第二节 自控力：我们生而为人就是为了成为思维舵手 元时间的概念：元时间是在两件事情，两个阶段或者两种状态之间。\n例如下班回到家就是从通勤到家，这时选择拿起手机还是拿起书籍就是一种选择，元时间的选择会影响下个阶段，如果拿起了手机，那下个阶段就是什么都没做，如果选择了书籍，就正确的控制了自己。\n每个元时间都是锻炼元认知能力的好机会，抓住这些机会，审视自己，主动控制。\n模糊会影响元认知能力，在大脑对未来的时间充满模糊的时候就是行动力最弱的时候，解决办法就是消除模糊，思考需要做的事情，给它们排序，让大脑中的模糊变得清晰明确。\n所以总结起来就是对当下的时间，全天的安排，人生的目标都有清晰明确的认识，这才是成为思维舵手的关键。\n第四章 专注力——情绪和智慧的交叉地带 第一节 情绪专注：一招提振你的注意力 有时我们在做一件事，脑子里却想着另外一件事，这其实不是一心二用而是不专注的表现。\n我们可以将一件事分为行动上和感受上两部分。起初在做一件事情时两者是统一的，当这件事越来越熟悉，越来越熟练之后，所花费的注意力也就越少，这时就表现出了身体与内心分离的现象。\n分心的原因有两种：一种是觉得当下的事情太无聊，一种是觉得当下的事情太痛苦。\n不管哪种都是让思想逃避现实，去想象天马行空。思想可以回到过去也可以幻想未来，但就是不会回归当下。\n然而人生就是由无数个当下所组成的，如果没有专注力，如何把握好人生呢。\n克服分心的方法是收回感受，让它回到事情本身上来，比如：\n 跑步时悉心体会抬腿摆臂，呼吸吐纳和迎面的微风。 睡觉时感受身体的紧张与松弛。 吃饭时感受每一口饭菜的香甜，体会味觉从有到无的过程。  身心合一的过程不是专注当下而是享受当下。\n第二节 学习专注：深度沉浸是进化双刃剑的安全剑柄 弱者极易分心，被身旁的事物所打扰，无法学习。而强者却会主动的练习专注能力，去热闹的地方看书学习，这使他们拥有了随时随地进入深度阅读和思考状态的能力。\n深度沉浸的方法有以下几点：\n1. 定义明确的目标：\n比如练琴时，告诉自己连续三次不犯任何错误、以适当的速度弹奏完曲子。而不是“我要练琴半小时”这样宽泛的目标。 将大目标分解为小目标使其明确化。\n2. 极度专注：\n大脑在学习时有两种模式：意识层的专注模式和潜意识的发散模式。\n从名称上来解释专注模式是在一个固定的区域的思考，而发散模式就是不固定的区域的联想思考。\n当我们认真思考问题却找不到答案时，就需要发散模式帮助我们寻找答案，但是发散模式属于潜意识层面，想要使用发散模式就必须彻底关闭意识层面的专注模式。\n所以做法就是当我们无法想到答案时，先放弃思考而去做其他毫不相干的事情，彻底关闭意识，让潜意识的发散模式去寻找答案。\n3. 有效的反馈：\n任何事情都需要形成闭环来提高，如果只是一味的努力，而没有反馈就无法认识自己的不足，一直练习自己已经学会的地方，使自己一直处在舒适区。\n形成反馈可以通过反思，复盘来获得。\n4. 始终处在拉伸区：\n一味的重复已经掌握的事情毫无意义，并会使自己感到厌倦，而进入困难区会感到挫败，焦虑。唯一的办法就是在舒适区和困难区中间\n练琴的例子：\n今天只练第一节，后面的先不练（把大目标拆分成小目标）；\n然后只练刚才弹错的地方（在拉伸区练习）；\n只要能连续流畅地弹3遍不出错就算完成（目标具体清晰）；\n练习过程中，我会及时纠正她的指法和按键错误（及时有效的反馈）；\n这样，很快进入了专注状态（沉浸其中），不一会儿就把第一节弹得很好了。\n第五章 学习力——学习不是一味地努力 第一节 匹配：舒适区边缘，适用于万物的方法论 匹配自己的计划才是能让你坚持最久的计划。\n一开始就给自己定制一个宏伟的目标，往往会使自己难以坚持下去，极其痛苦。\n最好的方式是在舒适区外的拉伸区进行练习，当你适应了当前的拉伸区就可以试着再向外走一点，离舒适区再远一些。\n当我们下定决心开始学习时，便会盲目跟随优秀者的脚步，他看什么书我就看什么书，他做什么题目我也做什么题目。\n这种做法其实是非常不可取的，用匹配原则就可以知道其中的原因，别人的拉伸区可能是是你的困难区，这样你不仅无法进步，还会容易放弃，自我焦虑。\n主动匹配自己的拉伸区，适合自己的才是最好的。\n前文中提到的定义明确目标也符合匹配拉伸区的原则，当我们将困难区的大目标拆解成拉伸区的小目标，就更驱使我们做出行动，进入拉伸区。\n在拉伸区需要明确关注点，关注的不是那些无聊的、已经学会的，而是那些还没有掌握的、出错的地方，然后不断重复直到将拉伸区变为舒适区。\n距离我们太远的事物，我们通常无法把握，无论它们是令人痛苦的还是令人享受的。\n当我们突然有了大量的时间、金钱、等等，我们通常没有能力控制自己有效的利用这些。\n大量的时间和金钱意味着突然多出了很多选择，而做选择是及其困难耗能的事情，没有能力合理的处理就意味着将会顺从自己的天性去享乐。\n所以人生最理想的状态就是持续的获得与自己能力匹配的财富和自由，不用羡慕旁人，因为即便将他人的成就给你，自己也无法把握，因为不匹配。\n第二节 深度：深度学习，人生为数不多的好出路 现在随处可见“精品课”、“几日速成”、“干货分享”等字眼，这些所谓的速成干货都是浅度学习的方法。\n在进行浅层学习时，我们输入的是别人已经咀嚼过的知识，是一种快餐式的知识，并且只注重输入，好像看过了这些知识就已经全部掌握了，这是一种浅层的、低级的学习方法。\n而深度学习注重的是学习的输入和输出，输出指的是将学到的知识与现有的知识体系连接起来，将学到的知识用自己的知识去解释，使新的知识成为自己知识体系中的一部分，然后将这些知识传授或向他人讲解。\n如果发现自己不知道从何讲起或说不清楚，那么十有八九是自己还没有掌握这些知识。输入与输出将学习知识的过程形成闭环，学以致用，进行输出，而输出必然会带来新的输入形成反馈，如此循环往复，知识会越来越精确和深刻。\n进行深度学习的几个方法： 1. 学习第一手知识：\n别人讲的课程时经别人咀嚼过的、二手的、快餐式的知识，而那些原著或论文才是值的精读和细细品味的经典。\n2. 进行记录：\n有了知识的输入之后，输出才是检验知识是否吸收的标准，用自己的语言和理解解释学到的知识也是一种输出，这个过程就是在用自己原有的知识来解释新学到的知识，是缝补的过程。\n3. 反思生活：\n反思、自省其实也是输出的一种形式，反思的目的是为了获得反馈，帮助自己发现不足和生活中的底层关系，深度学习可以用于生活的方方面面。\n最后，深度学习并不意味着放弃浅度学习，而是以深度学习为主。不同的浅度学习的输入带给我更多元的信息，接触到更广的领域，但无论如何浅度学习只能带给你不一样的视角，深度学习的输出还是需要我们自己去体会，去践行。\n专注与深度学习，同时对其按学习保持开放，毕竟深度之下的广度才是有效的。\n第三节 关联：高手的“暗箱” 在学习任何知识时，找到触动自己的地方，然后停下来思考、关联，这些知识可以用在哪些地方，解释哪些事情。\n获取到的知识就像是一盘沙子，是没有规矩的、散落的，思考和关联就是将新学到的知识与大脑中的知识系统形成联系，成为自己的知识。\n大多数人总是孤立的看待事物，不思考事情之间的联系，其实只有当我们有了某些迫切需求，或是正在完成工作，或是想要发现某种原理，在这种情况下进行关联往往会使我们的收获更加丰硕。\n同时只关联自己所需要的，避免将精力浪费在不必关注或是与自己毫不相关的小事身上，也会使关联的效能大大提高。\n第四节 体系：建立个人认知体系其实很简单 之前总认为知识就是书本上的道理、哲理、方法，其实不然。在进入社会之后，知识变成了能够帮助我们在选择面前做出决策的东西， 也就是说知识不再是具体的内容，而是反映在日常的方方面面，变成了相对抽象的东西，而这个东西更像是认知。\n在知识变得抽象之后，再结合前面所学的匹配，不难发现，没有最权威、最确定的知识体系，只有最适合个人当前状态的认知体系。\n在学习任何知识时，其实只需要关注那些触动我们，让自己有感触的内容，无需追求所谓的完美。\n记录作者的文章结构、做思维导图、找各种各样的读书心得使得自己能将书中所讲的完完整整、及其精确的记录下来。其实这么做完全没有必要，对自己最有触动的才是自己最需要的，也是能让自己记忆最深刻的。这些知识处于拉伸区，而其他的观点或知识往往处于困难区，将书中所有的观点知识全部收集下来往往使得自己无法抓住重点，不知道哪个才是对自己最重要的。\n大部分人收集记录只是为了满足自己的心理，认为只要记录了就掌握了全部，自己就会越来越好，从不注重改变，前文说过学习的权重是以改变为首，即便书中的一两个观点使你触动并在生活中实际发生了改变，也要好过盲目的全盘照搬。\n构建个人认知体系就是只吸取他人认知体系中自己最触动的部分，将这些零散的、碎片的内容融合拼接到自己的认知体系中， 形成属于自己的、独一无二的认知体系。\n刚刚学到的新知识或者新的触动对自己的认知体系还没有连接紧密，如果不及时有效的加强这些触动与认知圈的联系，它们随时会消失不见，这些就是伪触动。\n强化伪触动在于加强它们与自己认知圈的联系，也就是用自己的语言解释这些触动，进而产生关联，或是时常使用、联想这些触动，践行新学的知识，也能够极大的帮助强化关联。\n第五节 打卡：莫迷恋打卡，打卡打不出未来 学习需要有明确的目标，这种目标应该是实际的、实用的。\n比如：学习英语的目标是为了与外国人交流，而不是每天背多少个单词。\n不能为了完成所谓的目标而学，要专注于学习的长远目标，而不是专注于学习的形式或是每天完成指定的计划而学。\n认知闭合需求是指当遇到一个模糊不清的问题时，总想着要找到问题的答案。\n也就是说当任务没有完成时，我们坐立不安，时刻惦记着还有事情没有完成，而当我们做完需要做的事情，做这件事的动机就会立即变成零。这就是打卡的过程，当没有打卡时，总想着还没有完成打卡，如果时间来不及，会敷衍了事，先打卡解决这件事情再说，而如果时间足够，在完成打卡目标之后也绝不会在多做一点，所谓学不到，假装一下；学到了，立即停止。\n任务心态，在做事情时总想着还有多少才能完成，这种心态放弃聚焦事情本身和做事情的过程，而是为了完成任务而去做，这种心态只会让自己处于焦急、紧张、忙碌之中，无法专注于事情本身，无法获得过程中的快乐。\n第六节 反馈：是时候告诉你什么是真正的学习了 只注重原理知识的学习，从不实战、实践和跳过原理的学习，以实战输出为主，这两种学习方法导致的结果截然不同。\n在学习时一般都会选择从基础的理论开始并一直专注于理论层面的学习，而少了真正重要的部分，实践即输出，缺少实践的学习是不完整的，也是难以产生兴趣的，于是学习往往是枯燥乏味的，这种学习方式只是强迫理智脑在进行工作，但理智脑的能力是弱小的。\n如果是以输出为主，会使本能脑和情绪脑参加工作，更容易找到实践的乐趣并对这种学习方式产生兴趣，以此来专注于学习提升； 其次输出作品或是解决问题会产生即时的反馈，有了反馈必然会获得强烈的成就感和继续行动的欲望，这就是作品意识。\n有了产出就有了反馈，有了力量。虽然跳过理论的学习并不是长久之计，只能帮助尽快入门，让本能脑和情绪脑快速的体会到兴趣， 但反馈是贯穿始终的金钥匙，抓住反馈就抓住了进步的秘诀。\n想想也是，在我上大学时，听老师在课堂上将书本上的知识，听的云里雾里，但是到了实践课程的时候，通过自己实际操作，之前学到的知识马上理解了其中的原理，有一种豁然开朗的感觉，同时也觉得实践要比理论学习有趣的多，成就感也更大，对于工科的专业来说更是这样。\n第七节 休息：你没成功，可能是因为太刻苦了 精力是会被消耗的，随着时间的流失，做事情的精力和专注力会越来越少。这时你想到的是我要有足够的意志力，于是咬牙坚持下去， 结果是自己觉得很累，很难坚持。\n实际上正确的做法是在意识到自己的精力不足时，主动休息，等精力充足后继续专注学习，如此循环往复。\n因为当精力不足以使自己继续专注与正在做的事情时就会进入一种低效、劳累、煎熬、痛苦的状态，想休息却在咬牙坚持，如此下去必然无法长期坚持，只会使自己更快的放弃。\n番茄工作法是一种有效的工作方式，先保持极度专注的工作25分钟，然后休息5分钟，如此反复进行，只要到达休息时间就要马上停止工作，不能因为感觉自己还能继续专注而延迟休息的时间，这种做法实际上会造成后续的工作处于精力不足的状态，造成更大的损失。需要注意的是在休息时尽可能的停下来休息和放松，而不是去做刷手机、看视频这种同样耗费精力的事情。\n第六章 行动力——没有行动世界只是个概念 第一节 清晰：一个观念，重构你的行动力 每天早上都会收获满满的精力，如果起床就去看手机、刷视频，就是把这些精力浪费在了毫无用处的地方。\n增强回路指的是重复的行动将增强下次行动的动力，好比两人发生矛盾，每次肢体上的冲突都会激化矛盾，升级暴力。\n把这个道理运用到注意力上就是说每次点击手机上的标题都会使自己产生更强的欲望，如此下去便掉进了陷阱里，直到将精力消耗殆尽，又会感叹自己什么都没有做，陷入自责之中。\n知道了这个概念之后我们可能还是会拿起手机不自觉地开始负向的增强回路，一个非常重要的原因是你的想法在大脑中依然是模糊的，前文提到过，模糊使得行动变得缓慢，因为大脑讨厌模糊的事情，所以想要在一开始就开启正向的增强回路，清晰力是十分重要的。\n那么如何增强清晰力呢？\n答案就是在前一天晚上花费10分钟的时间将第二天要做的事情写下来，同时在第二天早上再花10分钟回顾。\n将一页A5纸分为4个部分：待办事项、计划完成、实际完成和备注。\n将心中的事情写下来，清空大脑，让自己处于单行线中，无法选择。\n消除模糊是提升行动力的关键，在开始行动之前确保你已经想清楚接下来要做什么怎么做。\n第二节 “傻瓜”：这个世界会奖励那些不计得失的“傻瓜” 我们总想先看到结果，然后才愿意付出努力和行动。\n然而想先看到结果再行动的人往往永远无法看到结果，因为当自己想要做一件事情的时候，我们距离目标是很远的，不然我们也不会想去做这件事，这个时候我们的认知、我们的视野看不到结果，于是很多人在两三天之后便放弃了，坚持下来的人他们的认知不断提高，视野不断清晰，有一天他们看清了结果，收获了结果。\n你觉得学习英语没用，是因为你看不到需要英语的地方。当你认为一件事情没用时，是因为自己的认知水平尚浅，没有达到更高水平的认知层次。所以当我们光想不做、缺乏行动时，我们依然一事无成。\n没有成功过，也就无法知道做成一件事是多么不容易，还在做着不切实际的幻想，也就更不会成功，如此下去进入恶行循环。\n反过来说如果你真的做成了一件事情，明白这背后付出的努力，到会减弱你的欲望，使自己能够沉静下来做一件事。\n就像我自己在大学时准备期末考试一样，在我付出了努力获得了分数上的结果，在下一个期末考试我就很容易继续付出努力，这其实也有一点增强回路的意思。\n还有一点是非常重要的，那就是突破阈值。\n很多人会发现自己努力了一段时间之后，收效甚微、不见结果，这是由于你所作的努力还在阈值之下，所谓量变产生质变，没有量的积累也就无法突破阈值的限制，永远见不到质变。\n广告行业就存在这种阈值效应，广告量少时看不到效果，在超过阈值后才能看到其产生的效果。\n在设立目标后做傻瓜式的行动，这个世界才会更加简单。\n第三节 行动：“道理都懂，就是不做”怎么破解 这世界上有两种学习方式：技能学习和认知学习。\n技能学习指的是像骑车、跳舞、唱歌这些技能的学习，它们的特点是在知道如何做后还需要大量的练习才能掌握，仅凭一次认知无法形成有效的正反馈，只有在经过不断练习的刺激后，相关的神经元与原有的神经元产生强联系，才掌握了这项技能。\n而认知学习是诸如知识、道理这些认知层次的学习，这些知识仅凭一次了解就能产生正反馈，使我们自己感觉我们已经明白了这个道理，及时满足，这样人们自然就不会再去做大量的练习巩固神经元之间的联系，这是人类的天性使然。\n既然了解了两种学习方式的概念，就很容易想到破解问题的方法就是将认知学习看作是技能学习。\n每当你了解到一个观点或是道理后就对自己说“我并没有掌握它，我还需要大量的运用和练习，让神经元之间的联系加强”，这样能够使自己坦然的面对，而不是浮躁的幻想。\n除此之外还有两点是我们需要注意的：第一点是很多人在开始时感觉到困难，于是便开始怀疑自己，产生焦虑情绪。\n其实这是完全没有必要的，在开始时感觉困难很正常，因为神经元之间还没有产生强大的联系，如果做成任何事都非常容易的话，我们为什么要去做它呢，那世界岂不是枯燥乏味，还有什么挑战性可言呢。\n第二点是将注意力放在自己的改变上而不是其他的东西。\n前面的章节提到过学习是为了改变，改变才是最终目标，没有让你获得改变的学习都是无效的学习，与其焦虑的学习各种知识，不如专注于自己改变了多少，你会发现其实我们能做的很少，只要每天改变一点点就足以让我们获得进步。\n第七章 情绪力——情绪是多角度看问题的智慧 第一节 心智带宽：唯有富足，方能解忧 印度蔗民在收获之前是最拮据的时候，他们整日忧心忡忡，表现为缺乏耐心，急于求成，而这些问题在收获之后又会得到改善。\n作者提到稀缺会使人变得目光短浅，缺乏耐心，因为心智带宽在减少。\n心智带宽就是内心的容量。\n其实不只是稀缺会消耗心智带宽，在如今的社会中，一次考试、面试、约会都是消耗心智的事情。这些事会占据我们的内心，使我们原本平和的内心变得焦躁不安，产生焦虑情绪。特别是在这个快速的社会中，压力、诱惑、欲望无一不占据着心智。\n如何清理心智带宽呢，作者提出了几点：\n1. 保持环境觉知，理智选择：\n压力通常来源于我们周围的环境，主动觉察环境发现压力，理智选择。\n2. 保持目标觉知，少即是多：\n固定目标，将精力放在最重要的事情上，放弃不重要的琐事，少即是多。\n3. 保持欲望觉知，审视决策：\n欲望太满会自乱阵脚，写下你想做的事情，清理自己的欲望，才能从杂乱中走出来。\n4. 保持情绪觉知，谨慎决定：\n一个心智富足的人，也是一个平心静气的人，保持稳定的情绪，不要被情绪扰乱你的心智。\n5. 保持闲余觉知，自我设限：\n适当的闲余时光是好的，但是过多的闲余使人变得平庸，如果你的闲余太多也要学会给自己设限，适当稀缺一些闲余。\n第二节 单一视角：你的坏情绪，源于视角单一 世界是多维的，如果我们总是以单一的视角来观察这个世界，就会偏执的对待这个世界。\n我们都知道拍照的角度不同，拍出来的画面也会大不相同，其实每个人就像一个相机，以不同的视角来看待周边的事物、看待人生以及这个世界。\n如果我们拍出来的画面是不完整的、模糊的、阴暗的，那就应该向那些清晰的、阳光的、宏大的画面看齐，寻找他们的角度。\n有些人在绝境之处依然能够看到一线生机，有些人纵使一帆风顺可依然不觉幸福。\n如何拍出好看的照片这里有几点建议：\n1. 勤移动：\n这个角度拍出来的画面太大，那就站远一点，拍出来的画面太暗，那就站在有光的地方，勤移动才能找到最合适的角度。\n2. 善学习：\n不学习无法登高处，不学习无法入江河，学习是为了能够看到更多的角度。\n3. 要开放：\n开放的态度，客观的看待一切，如果带着有色眼镜去拍照片，那自然无法看到最美的角度。\n4. 寻帮助：\n在我们陷入单一视角无法脱身时，应该借助他人的多维视角克服单一视角的局限，帮我们看清问题。\n5. 多运动：\n有氧运动产生的多巴胺会帮助大脑主动从不同的角度思考。\n6. 常反思：\n反思就是在和自己对话，站在客观的角度上看待自己的言行。\n第三节 游戏心态：幸福的人，总是在做另外一件事 自我决定理论指出人类有三种天生的内在需求：自我需求、关系需求、能力需求。\n自我需求指的是有自我选择的权力，自己能做自己想做的事情；\n关系需求是拥有良好的人际关系，受到别人的爱与尊敬；\n能力需求是有独特的本领，能够为其他人创造自己的价值。\n其中自我需求对幸福感的影响是比较大的。我们都有这样的经历：不想工作却不得不工作，不想写作业却不得不写作业。这些违背了我们意愿的事情让我们感觉不到幸福，我们会不自觉的排斥这些事情。\n那么如何让这些事情变成顺从我们的自我需求的事情呢？\n秘诀就是告诉自己其实是在做另一件事情，比如：我不是在工作，我是在提升自己；我不是在洗衣服，我是在活动放松。\n虽然这看起来比较幼稚，其实这么做是为了告诉自己我并不是在做这件事情，而是在做另一件我愿意做的事情，这样做更加符合自我选择和自我意愿。\n满足自我意愿的内在动机有两种：为自己而做和为玩而做，为自己而做，是为了应对外部的压力和要求。为玩而做，是为了应对重复、枯燥的事情。\n在做一件事情时的感受如何取决于我们赋予这件事何种角度。将它看作负担，这件事便是负担，将它看作放松，这件事便是放松。\n这个世界的模样取决于我们看待它的角度。\n第八章 早冥读写跑，人生五件套——成本最低的成长之道 第一节 早起：无闹钟、不参团、不打卡，我是如何坚持早起的  芝加哥大学的克雷特曼与德门克在实验中发现，人的眼球会在睡觉的时候来回运动，他们根据这个运动规律发现了“快速眼动睡眠”（REM）和“非快速眼动睡眠”（Non-REM）规律。健康的成年人睡觉时大多是1.5小时快速眼动睡眠、1.5小时非快速眼动睡眠，两种模式不断切换，并且在最初的两个单位时间内，也就是睡着之后的前3小时中，会进行高质量的睡眠（深度非快速眼动睡眠等于熟睡），之后则是浅层非快速眼动睡眠与快速眼动睡眠的组合。根据这一规律，人在睡眠后的3小时、4.5小时、6小时、7.5小时这几个节点醒来，就会觉得神清气爽，精力充沛。这就解释了为什么有时候我们睡了很长时间，但醒来后还是精神不佳，原因就是醒来的时机不在睡眠节点上，而是在睡眠周期中。\n  中岛孝志说：“闹钟不会照顾你的睡眠周期，时间一到，就会把手伸进你的脑子里，让你的脑子发生一场大地震，潜意识会被搅得一团糟。因为你是被闹钟吵醒的，大脑深处其实还睡着，所以明明睡了8小时，可总会觉得没睡饱，整个人昏昏沉沉的。”\n 前一天晚上将第二天早上做什么尽可能详细的计划出来，包括起晚了应该做什么或是天气不好应该做什么等等。\n计划的越明确，执行力也就越强。\n第二节 冥想：终有一天，你要解锁这条隐藏赛道 人的大脑中有7个小球，它们代表了我们的脑力资源。\n也就是说如果我们全身心的去做一件事，就是这7个小球共同在工作，如果我们在工作而脑子里却想着今天晚上吃什么的时候，可能只有3个小球在工作，剩下的4个小球去思考今天晚上应该吃什么去了。\n这就是为什么有的人能够一直保持高效率的工作，有的人工作一会就会分神。\n好在大脑的7个小球是可以被训练的，借助恰当的方式可以让它们目标一致，共同协作。这种理想的训练方式就是冥想。\n在冥想过程中，我们仅需把注意力全部集中到呼吸上，也就是说，让7个小球同时做一件事，如果其中某个小球走神了，把它柔和的拉回来即可。\n坚持这种练习，每天持续15分钟以上，就能养成专注的习惯。将专注变成无意识的行为，在不冥想时也能自动抑制思维离散，控制涣散的精神。换句话说，7个小球都能在需要的时候为你所用。\n第三节 阅读：如何让自己真正爱上阅读 未来学家凯文·凯利指出想要快速成为一个行业的高手，最好的方法就是和行业专家交流，直接向他们请教。\n但这种机会是极少的，那怎么办呢？\n看书\n看书能够在极低的代价下学习专家的观点，这就是为什么读一本好书就像是和一位智者谈话了。\n脚步不能丈量的地方，文字可以；眼睛无法看到的地方，文字可以。\n文字可以穿越古今中外，书籍就是智者看待事物、做选择、决策的过程。\n 阅读是为了改变。很多人以为一本书只要读完，读书的过程就结束了。事实上，阅读只是整个过程的开始，阅读之后的思考、思考之后的实践比阅读本身更加重要（这里主要指非虚构类书籍）。很多人的阅读仅停留在表面，读的时候觉得这里好有道理、那里好有道理，读完之后就不闻不问了，然后迅速转移到下一本书中，这种满足于录入的阅读造成的一个直接后果便是，一段时间之后再去翻这本书就好像之前没有看过一样，所有的痕迹都烟消云散了。真正读好一本书，往往需要花费数倍于阅读的时间去思考和实践，并输出自己的东西——可能是一篇文章，也可能是养成一个习惯——这个过程比阅读本身要费力得多。\n 第四节 写作：谢谢你，费曼先生 费曼技巧：无论学习什么东西，都要努力琢磨它们究竟在讲什么，它们的实际意义是什么，然后用自己的话将其重新讲出来。\n用自己的话讲出来，就是用最简单的方法让其他人明白你想要表达的意思，写作也是这样。\n这样做就会很少提及新的名词和概念，通常我们用已经知道的事物来类比需要讲述的新概念，这就自然而然的将我们已有的认知将新的认知联系起来，构造神经元之间的通路。\n人类大脑中存在着感性和理性，感性比理性更加强大。这就是为什么人们在阅读或交流时更愿意听故事，而不是讲道理。\n聪明的做法是先用合适的故事引起感性的注意，然后传达想要说明的道理给理性，既满足了感性，有照顾了理性。\n用聊天式的话语来写作也是个不错的方法。\n在闲聊时人们的语气是放松的、平和的，使读者更容易接收，避免了以说教式的话语来教育读者。\n第五节 运动：灵魂想要走得远，身体必须在路上 有氧运动会使大脑产生新的神经元，但此时的神经元是一个空白的干细胞，还无法为我们所用。\n一个空白的干细胞要经过28天的生长，长出轴突和树突之后，才能真正发挥作用。\n研究表明在运动后的1-2个小时里从事高强度脑力劳动（如学习、写作等等）或是体力劳动（如跳舞、钢琴等等）会刺激神经元的生长。\n作者还指出好的运动方式是有氧运动 + 复杂运动（如太极、瑜伽、舞蹈等等），复杂运动会促使神经细胞之间连接的更加紧密。\n结语 一流的生活不是富有，而是觉知 这篇结语主要是在说每日反思的重要性以及如何开始每日反思。\n作者指出每日反思只是记录一天中最触动自己的事情，就算某一天中断或者实在没有什么触动也没有关系，还是那句话：将注意力集中在改变上。\n复盘的方式极为简单，通常只需3点：\n 描述经过——以便日后回顾时能想起当时的场景 分析原因——多问几个为什么，直到有深度的启发 改进措施——尽可能提炼出一个认知点或行动点  总结来说就是在某个场景，我为什么会做出这样的反应，这样做对不对，如果不对我应该如何做。\n","date":"2022-03-26T00:00:00Z","image":"https://WangZichen99.github.io/img/2022/04/oasis.jpg","permalink":"https://WangZichen99.github.io/p/cognitiveawaken/","title":"认知觉醒读书笔记"},{"content":"SpringMVC 1、SpringMVC执行原理  用户访问后首先被web.xml中的DispatchServlet拦截下来 DispatchServlet调用HandlerMapping处理器映射，HandlerMapping根据请求url查找Handler HandlerExecution根据url到springmvc-servlet.xml中查找控制器controller，并将解析后的信息传递给DispatchServlet HandlerAdapter为处理器适配器，按照特定的规则执行Handler Handler让具体的controller执行 controller将执行信息(ModelAndView)返回给HandlerAdapter HandlerAdapter将视图逻辑名或模型传递给DispatchServlet DispatchServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名 视图解析器ViewResolver将解析的逻辑视图名传给DispatchServlet DispatchServlet根据视图解析器解析的结果，调用具体的视图   web.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;!--注册DispatchServlet--\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;!--关联一个springmvc配置文件：【servlet-name】-servlet.xml--\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:springmvc-servlet.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;!--启动级别-1--\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;!--/匹配所有请求：（不包括.jsp）--\u0026gt; \u0026lt;!--/*匹配所有请求（包括.jsp）--\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;/web-app\u0026gt;   springmvc-servlet.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\u0026#34;/\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\u0026#34;/\u0026gt; \u0026lt;!--视图解析器：DispatcherServlet返回的ModelAndView--\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026#34; id=\u0026#34;internalResourceViewResolver\u0026#34;\u0026gt; \u0026lt;!--前缀--\u0026gt; \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/WEB-INF/jsp/\u0026#34;/\u0026gt; \u0026lt;!--后缀--\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.jsp\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;   HelloController.java (实现了Controller接口就成为了一个视图解析器，返回ModelAndView)\n1 2 3 4 5 6 7 8 9 10 11 12 13  public class HelloController implements Controller { @Override public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { //ModelAndView模型和视图  ModelAndView mv = new ModelAndView(); //封装对象放在ModelAndView中  mv.addObject(\u0026#34;msg\u0026#34;, \u0026#34;HelloSpringMVC\u0026#34;); //封装要跳转的视图放在ModelAndView中  mv.setViewName(\u0026#34;hello\u0026#34;); ///WEB-INF/jsp/hello.jsp  //返回ModelAndView  return mv; } }   在spring-servlet.xml中注册bean，id对应请求路径，class对应视图解析器\n1 2  \u0026lt;!--Handler--\u0026gt; \u0026lt;bean id=\u0026#34;/hello\u0026#34; class=\u0026#34;com.wzc.controller.HelloController\u0026#34;/\u0026gt;   2、使用注解开发 配置资源过滤问题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  \u0026lt;build\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/java\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/resources\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;/build\u0026gt;   web.xml注册DispatchServlet\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;!--注册DispatchServlet--\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;!--关联一个springmvc配置文件：【servlet-name】-servlet.xml--\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:springmvc-servlet.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;!--启动级别-1--\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;!--/匹配所有请求：（不包括.jsp）--\u0026gt; \u0026lt;!--/*匹配所有请求（包括.jsp）--\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;/web-app\u0026gt;   springmvc-servlet.xml配置文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xmlns:mvc=\u0026#34;http://www.springframework.org/schema/mvc\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\u0026#34;\u0026gt; \u0026lt;!--自动扫描包，让指定包下的注解生效，有IOC容器统一管理--\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.wzc.controller\u0026#34;/\u0026gt; \u0026lt;!--让Spring MVC不处理静态资源--\u0026gt; \u0026lt;mvc:default-servlet-handler/\u0026gt; \u0026lt;!--支持mvc注解驱动，在spring中一般采用@RequestMapping注解来完成映射关系， 要使RequestMapping注解生效必须向上下文注册DefaultAnnotationHandlerMapping和AnnotationMethodHandlerAdapter实例， 这两个实例分别在类级别和方法级别处理，annotation-driven配置帮助我们自动完成两个实例的注入--\u0026gt; \u0026lt;mvc:annotation-driven/\u0026gt; \u0026lt;!--视图解析器--\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026#34; id=\u0026#34;internalResourceViewResolver\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/WEB-INF/jsp/\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.jsp\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;   HelloController.java\n1 2 3 4 5 6 7 8 9 10 11 12  @Controller @RequestMapping(\u0026#34;/api\u0026#34;) public class HelloController { @RequestMapping(\u0026#34;/hello\u0026#34;) public String hello(Model model) { //封装数据  model.addAttribute(\u0026#34;msg\u0026#34;, \u0026#34;hello annotation\u0026#34;); //视图解析器解析WEB-INF/jsp/hello.jsp  return \u0026#34;hello\u0026#34;; } }   使用Spring MVC必须配置的三大件：处理器映射器、处理器配置器、视图解析器\n通常我们只需手动配置视图解析器，处理器映射器和处理器配置器只需要开启注解驱动即可，省去了大量的xml配置\n3、Controller和RestFul风格 3.1、实现Controller接口 1 2 3 4 5 6 7 8 9 10 11 12 13  public class HelloController implements Controller { @Override public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { //ModelAndView模型和视图  ModelAndView mv = new ModelAndView(); //封装对象放在ModelAndView中  mv.addObject(\u0026#34;msg\u0026#34;, \u0026#34;HelloSpringMVC\u0026#34;); //封装要跳转的视图放在ModelAndView中  mv.setViewName(\u0026#34;hello\u0026#34;); ///WEB-INF/jsp/hello.jsp  //返回ModelAndView  return mv; } }   缺点：一个controller中只能实现一个方法\n3.2、使用注解@Controller  开启自动扫描  1 2  \u0026lt;context:component-scan base-package=\u0026#34;com.wzc.controller\u0026#34;/\u0026gt;   在类上添加@Controller注解 在方法上添加@RequestMapping  3.3、@RequestMapping RequestMapping注解用于映射url到控制器类或一个特定的方法，可同时注解在类和方法上\n访问时的顺序是类/方法\n3.4、RestFul风格 RestFul风格可以通过不同的请求方式来实现不同的效果，比如：\n http://127.0.0.1/item/1————查询, GET http://127.0.0.1/item————新增, POST http://127.0.0.1/item————修改, PUT http://127.0.0.1/item————删除, DELETE  在SpringMVC中可以使用@PathVariable注解，让方法的参数值对应绑定到一个url模板变量上\n1 2 3 4 5 6 7 8 9  @Controller public class RestFulController { @RequestMapping(\u0026#34;/add/{a}/{b}\u0026#34;) public String add(@PathVariable(\u0026#34;a\u0026#34;) int a, @PathVariable(\u0026#34;b\u0026#34;) int b, Model model) { model.addAttribute(\u0026#34;msg\u0026#34;, a + b); return \u0026#34;restful\u0026#34;; } }   注解介绍：\n@GetMapping(\u0026quot;\\hello\u0026quot;)表示get请求\n@PostMapping(\u0026quot;\\hello\u0026quot;)表示post请求\n@PutMapping(\u0026quot;\\hello\u0026quot;)表示put请求\n@DeleteMapping(\u0026quot;\\hello\u0026quot;)表示delete请求\n使用路径变量的好处：\n 使路径变得更加简洁 获得参数更加方便  3.5、重定向和转发 通过SpringMVC实现重定向和转发，无需视图解析器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  @Controller public class ForwardAndRedirect { //转发一  @RequestMapping(\u0026#34;/ForwardAndRedirect/forward1\u0026#34;) public String forward1(Model model) { model.addAttribute(\u0026#34;msg\u0026#34;, \u0026#34;转发到restful.jsp\u0026#34;); return \u0026#34;/WEB-INF/jsp/restful.jsp\u0026#34;; } //转发二  @RequestMapping(\u0026#34;/ForwardAndRedirect/forward2\u0026#34;) public String forward2() { return \u0026#34;forward:/index.jsp\u0026#34;; } //重定向（重定向不走视图解析器，并且重定向不能访问WEB-INF下的内容）  @RequestMapping(\u0026#34;/ForwardAndRedirect/redirect\u0026#34;) public String redirect() { return \u0026#34;redirect:/index.jsp\u0026#34;; } }   3.6、SpringMVC参数接收 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  @Controller @RequestMapping(\u0026#34;/user\u0026#34;) public class UserController { @GetMapping(\u0026#34;/get\u0026#34;) public String get(@RequestParam(\u0026#34;username\u0026#34;) String name, Model model) { model.addAttribute(\u0026#34;msg\u0026#34;, name); return \u0026#34;/WEB-INF/jsp/restful.jsp\u0026#34;; } @GetMapping(\u0026#34;getUser\u0026#34;) public void getUser(User user) { System.out.println(user); } }   在使用实体类接收参数时，前端需要将参数名与实体类变量名称一一对应，否则无法接收到所传参数\n3.7、乱码问题 在post请求中，前端传递中文时会产生乱码问题\n方法一：使用过滤器解决乱码\n1 2 3 4 5 6 7 8  public class EncodingFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { servletRequest.setCharacterEncoding(\u0026#34;utf-8\u0026#34;); servletResponse.setCharacterEncoding(\u0026#34;utf-8\u0026#34;); filterChain.doFilter(servletRequest, servletResponse); } }   web.xml中配置filter\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;web-app\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;encodingFilter\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;com.wzc.filter.EncodingFilter\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;encodingFilter\u0026lt;/filter-name\u0026gt; \u0026lt;!--/不包括jsp页面--\u0026gt; \u0026lt;!--/*包括jsp页面--\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; \u0026lt;/web-app\u0026gt;   方法二：springmvc提供的编码过滤器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;web-app\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;encoding\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.CharacterEncodingFilter\u0026lt;/filter-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;encoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;utf-8\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;encoding\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; \u0026lt;/web-app\u0026gt;   4、JSON 4.1、Jackson  导包  1 2 3 4 5 6  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.11.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   使用方法  1 2 3 4 5 6 7 8 9 10 11 12  @Controller public class UserController { @GetMapping(\u0026#34;/getUser\u0026#34;) @ResponseBody public String getUser() throws JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); User user = new User(1, \u0026#34;王子琛\u0026#34;, 22); String result = mapper.writeValueAsString(user); return result; } }   乱码问题的解决方法： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;!--Json乱码问题解决--\u0026gt; \u0026lt;mvc:annotation-driven\u0026gt; \u0026lt;mvc:message-converters\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.http.converter.StringHttpMessageConverter\u0026#34;\u0026gt; \u0026lt;constructor-arg value=\u0026#34;UTF-8\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.http.converter.cbor.MappingJackson2CborHttpMessageConverter\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;objectMapper\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;failOnEmptyBeans\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/mvc:message-converters\u0026gt; \u0026lt;/mvc:annotation-driven\u0026gt;   @Controller和@RestController的区别：\n @Controller会走是解析器 @RestController会返回字符串 @ResponseBody是配合@Controller来使用，如果使用了@RestController就不需要了  返回日期类型\n1 2 3 4 5 6 7 8 9 10 11 12 13  @RestController public class UserController { @GetMapping(\u0026#34;/getDate\u0026#34;) public String getDate() throws JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); //不使用时间戳方式返回Date  mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //自定义文件格式  mapper.setDateFormat(new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;)); return mapper.writeValueAsString(new Date()); } }   封装工具类JsonUtil\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public class JsonUtil { public static String getJson(Object object) { return getJson(object, \u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); } public static String getJson(Object object, String format) { ObjectMapper mapper = new ObjectMapper(); mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); mapper.setDateFormat(new SimpleDateFormat(format)); try { return mapper.writeValueAsString(object); } catch (JsonProcessingException e) { e.printStackTrace(); } return null; } }   4.2、FastJson  导包  1 2 3 4 5 6  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.75\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   用法   java对象转Json字符串  JSON.toJSONString()   Json字符串转java对象  JSON.parseObject()   java对象转Json对象  JSON.toJSON()   JSON对象转java对象  JSON.parseJavaObject()    5、整合SSM  数据库  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  CREATEDATABASE`ssmbuild`;USE`ssmbuild`;CREATETABLE`books`(`bookID`INT(10)NOTNULLauto_incrementCOMMENT\u0026#39;id\u0026#39;,`bookName`VARCHAR(100)NOTNULLCOMMENT\u0026#39;书名\u0026#39;,`bookCounts`INT(11)NOTNULLCOMMENT\u0026#39;数量\u0026#39;,`detail`VARCHAR(200)NOTNULLCOMMENT\u0026#39;描述\u0026#39;,KEY`bookID`(`bookID`))ENGINE=INNODBDEFAULTCHARSET=utf8;INSERTINTO`books`(`bookID`,`bookName`,`bookCounts`,`detail`)VALUES(1,\u0026#39;Java\u0026#39;,1,\u0026#39;从入门到放弃\u0026#39;),(2,\u0026#39;MySQL\u0026#39;,10,\u0026#39;从删库到跑路\u0026#39;),(3,\u0026#39;Linux\u0026#39;,5,\u0026#39;从进门到进牢\u0026#39;);  导包和静态资源导出问题  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85  \u0026lt;project\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.25\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--数据库连接池c3p0--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.mchange\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;c3p0\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.5.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.5.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.5.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet.jsp\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jsp-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jstl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.75\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.16\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;*/src/main/java\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;*/src/main/resources\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt;   5.1、Mybatis层  mybatis-config.xml  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!--配置数据源，交给Spring去做--\u0026gt; \u0026lt;typeAliases\u0026gt; \u0026lt;package name=\u0026#34;com.wzc.pojo\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;package name=\u0026#34;com.wzc.mapper\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt;   Books  1 2 3 4 5 6 7 8 9  @Data @AllArgsConstructor @NoArgsConstructor public class Books { private int bookID; private String bookName; private int bookCounts; private String detail; }   BookMapper  1 2 3 4 5 6 7 8 9 10 11  public interface BookMapper { int addBook(Books book); int deleteBookById(@Param(\u0026#34;Id\u0026#34;) int id); int updateBook(Books book); Books queryBookById(@Param(\u0026#34;Id\u0026#34;) int id); List\u0026lt;Books\u0026gt; queryAllBook(); }   BookMapper.xml  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.wzc.com.wzc.controller.mapper.BookMapper\u0026#34;\u0026gt; \u0026lt;insert id=\u0026#34;addBook\u0026#34; parameterType=\u0026#34;Books\u0026#34;\u0026gt; insert into ssmbuild.books(bookID, bookName, bookCounts, detail) VALUES (#{bookID}, #{bookName}, #{bookCounts}, #{detail}) \u0026lt;/insert\u0026gt; \u0026lt;delete id=\u0026#34;deleteBookById\u0026#34; parameterType=\u0026#34;int\u0026#34;\u0026gt; delete from ssmbuild.books where bookID = #{id} \u0026lt;/delete\u0026gt; \u0026lt;update id=\u0026#34;updateBook\u0026#34; parameterType=\u0026#34;Books\u0026#34;\u0026gt; update ssmbuild.books set bookName = #{bookName}, bookCounts = #{bookCounts}, detail = #{detail} where bookID = #{bookId} \u0026lt;/update\u0026gt; \u0026lt;select id=\u0026#34;queryBookById\u0026#34; parameterType=\u0026#34;int\u0026#34; resultType=\u0026#34;Books\u0026#34;\u0026gt; select bookID, bookName, bookCounts, detail from ssmbuild.books where bookID = #{id} \u0026lt;/select\u0026gt; \u0026lt;select id=\u0026#34;queryAllBook\u0026#34; resultType=\u0026#34;Books\u0026#34;\u0026gt; select bookID, bookName, bookCounts, detail from ssmbuild.books; \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt;   BookService  1 2 3 4 5 6 7 8 9 10 11  public interface BookService { int addBook(Books book); int deleteBookById(@Param(\u0026#34;Id\u0026#34;) int id); int updateBook(Books book); Books queryBookById(@Param(\u0026#34;Id\u0026#34;) int id); List\u0026lt;Books\u0026gt; queryAllBook(); }   BookServiceImpl  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  public class BookServiceImpl implements BookService { private BookMapper bookMapper; public void setBookMapper(BookMapper bookMapper) { this.bookMapper = bookMapper; } @Override public int addBook(Books book) { return bookMapper.addBook(book); } @Override public int deleteBookById(int id) { return bookMapper.deleteBookById(id); } @Override public int updateBook(Books book) { return bookMapper.updateBook(book); } @Override public Books queryBookById(int id) { return bookMapper.queryBookById(id); } @Override public List\u0026lt;Books\u0026gt; queryAllBook() { return bookMapper.queryAllBook(); } }   5.2、Spring层 spring-dao.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;!--关联数据库配置文件--\u0026gt; \u0026lt;context:property-placeholder location=\u0026#34;classpath:database.properties\u0026#34;/\u0026gt; \u0026lt;!--连接池 dbcp：半自动化操作，不能自动连接 c3p0：自动化操作（自动化加载配置文件并自动设置到对象中） druid，hikari--\u0026gt; \u0026lt;bean id=\u0026#34;datasource\u0026#34; class=\u0026#34;com.mchange.v2.c3p0.ComboPooledDataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClass\u0026#34; value=\u0026#34;${jdbc.driver}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;jdbcUrl\u0026#34; value=\u0026#34;${jdbc.url}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;user\u0026#34; value=\u0026#34;${jdbc.username}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${jdbc.password}\u0026#34;/\u0026gt; \u0026lt;!--c3p0私有属性--\u0026gt; \u0026lt;property name=\u0026#34;maxPoolSize\u0026#34; value=\u0026#34;30\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;minPoolSize\u0026#34; value=\u0026#34;10\u0026#34;/\u0026gt; \u0026lt;!--关闭连接后不自动commit--\u0026gt; \u0026lt;property name=\u0026#34;autoCommitOnClose\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;!--获取连接超时时间--\u0026gt; \u0026lt;property name=\u0026#34;checkoutTimeout\u0026#34; value=\u0026#34;10000\u0026#34;/\u0026gt; \u0026lt;!--连接失败重试次数--\u0026gt; \u0026lt;property name=\u0026#34;acquireRetryAttempts\u0026#34; value=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--sqlSessionFactory--\u0026gt; \u0026lt;bean id=\u0026#34;sqlSessionFactory\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;datasource\u0026#34;/\u0026gt; \u0026lt;!--绑定Mybatis配置文件--\u0026gt; \u0026lt;property name=\u0026#34;configLocation\u0026#34; value=\u0026#34;classpath:mybatis-config.xml\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--配置dao接口扫描包，动态实现了dao接口可以注入到spring容器中--\u0026gt; \u0026lt;bean class=\u0026#34;org.mybatis.spring.mapper.MapperScannerConfigurer\u0026#34;\u0026gt; \u0026lt;!--注入sqlSessionFactory--\u0026gt; \u0026lt;property name=\u0026#34;sqlSessionFactoryBeanName\u0026#34; value=\u0026#34;sqlSessionFactory\u0026#34;/\u0026gt; \u0026lt;!--要扫描的dao包--\u0026gt; \u0026lt;property name=\u0026#34;basePackage\u0026#34; value=\u0026#34;com.wzc.mapper\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;   spring-service.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;!--扫描service下的包--\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.wzc.service\u0026#34;/\u0026gt; \u0026lt;!--声明式事务配置--\u0026gt; \u0026lt;bean id=\u0026#34;transactionManager\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DataSourceTransactionManager\u0026#34;\u0026gt; \u0026lt;!--注入数据源--\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;datasource\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--aop事务支持--\u0026gt; \u0026lt;/beans\u0026gt;   5.3、SpringMVC层 spring-mvc.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:mvn=\u0026#34;http://www.springframework.org/schema/mvc\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;!--注解驱动--\u0026gt; \u0026lt;mvn:annotation-driven/\u0026gt; \u0026lt;!--静态资源配置过滤--\u0026gt; \u0026lt;mvn:default-servlet-handler/\u0026gt; \u0026lt;!--扫描包：controller--\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.wzc.controller\u0026#34;/\u0026gt; \u0026lt;!--视图解析器--\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/WEB-INF/jsp/\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.jsp\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;   web.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;!--DispatchServlet--\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:applicationContext.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;!--乱码过滤--\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;encodingFilter\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.CharacterEncodingFilter\u0026lt;/filter-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;encoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;utf-8\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;encodingFilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; \u0026lt;!--Session--\u0026gt; \u0026lt;session-config\u0026gt; \u0026lt;session-timeout\u0026gt;15\u0026lt;/session-timeout\u0026gt; \u0026lt;/session-config\u0026gt; \u0026lt;/web-app\u0026gt;   applicationContext.xml\n1 2 3 4 5 6 7 8 9 10  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;import resource=\u0026#34;classpath:spring-dao.xml\u0026#34;/\u0026gt; \u0026lt;import resource=\u0026#34;classpath:spring-service.xml\u0026#34;/\u0026gt; \u0026lt;import resource=\u0026#34;classpath:spring-mvc.xml\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt;   6、拦截器 拦截器只会拦截controller中的方法，而不会拦截静态资源\n实现InterceptorHandler接口就可以自定义一个拦截器\n拦截器是AOP思想的具体应用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public class MyInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // return true为放行，return false为拦截  return HandlerInterceptor.super.preHandle(request, response, handler); } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { HandlerInterceptor.super.postHandle(request, response, handler, modelAndView); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { HandlerInterceptor.super.afterCompletion(request, response, handler, ex); } }   1 2 3 4 5 6 7  \u0026lt;!--拦截器配置--\u0026gt; \u0026lt;mvc:interceptors\u0026gt; \u0026lt;mvc:interceptor\u0026gt; \u0026lt;mvc:mapping path=\u0026#34;/**\u0026#34;/\u0026gt; \u0026lt;bean class=\u0026#34;com.wzc.config.MyInterceptor\u0026#34;/\u0026gt; \u0026lt;/mvc:interceptor\u0026gt; \u0026lt;/mvc:interceptors\u0026gt;   未登录用户拦截\nmain.jsp\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;首页\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;首页\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;${sessionScope.username}\u0026lt;/p\u0026gt; \u0026lt;a href=\u0026#34;${pageContext.request.contextPath}/user/logout\u0026#34;\u0026gt;注销\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   login.jsp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;登录\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form action=\u0026#34;${pageContext.request.contextPath}/user/login\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;label\u0026gt;用户名：\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34;\u0026gt; \u0026lt;label\u0026gt;密码：\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;pwd\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   LoginController\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  @Controller @RequestMapping(\u0026#34;/user\u0026#34;) public class LoginController { @GetMapping(\u0026#34;/main\u0026#34;) public String main() { return \u0026#34;main\u0026#34;; } @GetMapping(\u0026#34;/login\u0026#34;) public String login() { return \u0026#34;login\u0026#34;; } @PostMapping(\u0026#34;/login\u0026#34;) public String login(Login login, HttpServletRequest request) { request.getSession().setAttribute(\u0026#34;username\u0026#34;, login.getUsername()); return \u0026#34;main\u0026#34;; } @GetMapping(\u0026#34;/logout\u0026#34;) public String logout(HttpServletRequest request) { request.getSession().removeAttribute(\u0026#34;username\u0026#34;); return \u0026#34;login\u0026#34;; //如果要返回首页，需要写成return \u0026#34;redirect:/user/main\u0026#34;，否则需要点击两次注销才会被拦截  // 如果写成return \u0026#34;main\u0026#34;，返回的还是main.jsp，这时第一次点击注销时无法触发拦截器  } }   LoginInterceptor\n1 2 3 4 5 6 7 8 9 10 11  public class LoginInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //如果session中有username或者访问登录页面就放行  if (request.getSession().getAttribute(\u0026#34;username\u0026#34;) != null || request.getRequestURI().toLowerCase().contains(\u0026#34;login\u0026#34;)) { return true; } request.getRequestDispatcher(\u0026#34;/WEB-INF/jsp/login.jsp\u0026#34;).forward(request, response); return false; } }   7、文件上传与下载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  @RestController @RequestMapping(\u0026#34;/file\u0026#34;) public class FileController { @PostMapping(\u0026#34;/upload\u0026#34;) public String upload (@RequestParam(\u0026#34;file\u0026#34;)CommonsMultipartFile file, HttpServletRequest request) throws IOException { String filename = file.getOriginalFilename(); if (StringUtils.isEmpty(filename)) { return \u0026#34;redirect:/index.jsp\u0026#34;; } String path = request.getServletContext().getRealPath(\u0026#34;/upload\u0026#34;); File filepath = new File(path); if (!filepath.exists()) { filepath.mkdirs(); } //读写文件  try (InputStream inputStream = file.getInputStream(); FileOutputStream fileOutputStream = new FileOutputStream(new File(filepath, filename));) { int len = 0; byte[] buffer = new byte[1024]; while ((len = inputStream.read(buffer)) != -1) { fileOutputStream.write(buffer, 0, len); fileOutputStream.flush(); } } return \u0026#34;上传成功！\u0026#34;; } @PostMapping(\u0026#34;/upload1\u0026#34;) public String upload1 (@RequestParam(\u0026#34;file\u0026#34;)CommonsMultipartFile file, HttpServletRequest request) throws IOException { String path = request.getServletContext().getRealPath(\u0026#34;/upload\u0026#34;); File filepath = new File(path); if (!filepath.exists()) { filepath.mkdirs(); } //直接写文件  file.transferTo(new File(filepath + File.separator + file.getOriginalFilename())); return \u0026#34;上传成功！\u0026#34;; } @RequestMapping(\u0026#34;download\u0026#34;) public void download(HttpServletRequest request, HttpServletResponse response, String filename) throws UnsupportedEncodingException { //设置response响应头  response.reset(); response.setCharacterEncoding(\u0026#34;UTF-8\u0026#34;); response.setContentType(\u0026#34;multipart/form-data\u0026#34;); response.setHeader(\u0026#34;Content-Disposition\u0026#34;, \u0026#34;attachment;fileName=\u0026#34; + URLEncoder.encode(filename, \u0026#34;UTF-8\u0026#34;)); File file = new File(request.getServletContext().getRealPath(\u0026#34;/upload\u0026#34;), filename); try (FileInputStream fileInputStream = new FileInputStream(file); ServletOutputStream outputStream = response.getOutputStream()) { int len = 0; byte[] buffer = new byte[1024]; while ((len = fileInputStream.read(buffer)) != -1) { outputStream.write(buffer, 0, len); outputStream.flush(); } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } }   ","date":"2022-03-12T00:00:00Z","image":"https://WangZichen99.github.io/img/2022/04/beach.png","permalink":"https://WangZichen99.github.io/p/springmvcnote/","title":"SpringMVC笔记"},{"content":"Mybatis 1、第一个Mybatis程序 1.1、搭建环境 搭建数据库：\n1 2 3 4 5 6 7 8 9  CREATEDATABASE`mybatis`;USE`mybatis`;CREATETABLE`user`(`id`INT(20)NOTNULLPRIMARYKEY,`name`VARCHAR(30)DEFAULTNULL,`pwd`VARCHAR(30)DEFAULTNULL)ENGINE=INNODBDEFAULTCHARSET=utf8;  新建项目：\n 新建一个maven项目 删除src目录 导入maven依赖  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  \u0026lt;dependencies\u0026gt; \u0026lt;!--mysql驱动--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.25\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--mybatis--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.13\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.22\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;   1.2、创建一个模块  编写mybatis的核心配置文件  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;!--核心配置文件--\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;!--事务管理--\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;\u0026gt;\u0026lt;/transactionManager\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mybatis?userSSL=true\u0026amp;amp;useUnicode=true\u0026amp;amp;characterEncoding=utf-8\u0026amp;amp;serverTimezone=GMT%2B8\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;123456\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;!--每一个mapper.xml都需要在mybatis配置文件中注册--\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;com/wzc/dao/UserMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt;    编写mybatis的工具类  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  //sqlSessionFactory --\u0026gt; sqlSession public class MybatisUtils { private static SqlSessionFactory sqlSessionFactory; static { try { //使用Mybatis获取sqlSessionFactory对象  String resource = \u0026#34;mybatis-config.xml\u0026#34;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); } } public static SqlSession getSqlSession() { return sqlSessionFactory.openSession(); } }   1.3、编写代码  实体类  1 2 3 4 5 6 7 8  @Data @AllArgsConstructor @NoArgsConstructor public class User { private int id; private String name; private String pwd; }    Dao接口  1 2 3  public interface UserDao { List\u0026lt;User\u0026gt; userList(); }    mapper.xml  1 2 3 4 5 6 7 8 9 10  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.wzc.dao.UserDao\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;userList\u0026#34; resultType=\u0026#34;com.wzc.pojo.User\u0026#34;\u0026gt; select * from user; \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt;   1.4、测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  public class UserDaoTest { @Test public void test1() { //获取sqlSession对象  SqlSession sqlSession = MybatisUtils.getSqlSession(); try { //方法一：getMapper，推荐（不需要强转以及写错字符串）  UserDao mapper = sqlSession.getMapper(UserDao.class); List\u0026lt;User\u0026gt; userList = mapper.userList(); //方法二：不推荐使用  //List\u0026lt;User\u0026gt; userList = sqlSession.selectList(\u0026#34;com.wzc.dao.UserDao.userList\u0026#34;);  for (User user : userList) { System.out.println(user); } } finally { //关闭sqlSession  sqlSession.close(); } } }   2、CRUD 2.1 namespace namespace中的包名要和mapper接口的包名一致\n2.2、select 查询语句\n id：对应接口中的方法名 resultType：sql语句的返回值 parameterType：参数类型  1 2 3  \u0026lt;select id=\u0026#34;getUserById\u0026#34; parameterType=\u0026#34;int\u0026#34; resultType=\u0026#34;com.wzc.pojo.User\u0026#34;\u0026gt; select * from user where id = #{id}; \u0026lt;/select\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12  public class UserDaoTest { @Test public void userListTest() { try (SqlSession sqlSession = MybatisUtils.getSqlSession()) { UserDao mapper = sqlSession.getMapper(UserDao.class); List\u0026lt;User\u0026gt; userList = mapper.userList(); for (User user : userList) { System.out.println(user); } } } }   2.3、insert 1 2 3  \u0026lt;insert id=\u0026#34;addUser\u0026#34; parameterType=\u0026#34;com.wzc.pojo.User\u0026#34;\u0026gt; insert into user (id, name, pwd) values (#{id}, #{name}, #{pwd}); \u0026lt;/insert\u0026gt;   2.4、update 1 2 3  \u0026lt;update id=\u0026#34;updateUserById\u0026#34; parameterType=\u0026#34;com.wzc.pojo.User\u0026#34;\u0026gt; update user set name = #{name}, pwd = #{pwd} where id = #{id}; \u0026lt;/update\u0026gt;   2.5、delete 1 2 3  \u0026lt;delete id=\u0026#34;deleteUserById\u0026#34; parameterType=\u0026#34;int\u0026#34;\u0026gt; delete from user where id = #{id}; \u0026lt;/delete\u0026gt;   注意点：\n 增删改操作都需要提交事务：sqlSession.commit();  3、万能Map 当实体类中字段过多时，应当考虑使用Map\n1 2 3  public interface UserDao { int addUserMap(Map\u0026lt;String, Object\u0026gt; user); }   Map传递参数直接在sql中取出key即可\n4、模糊查询  传递带通配符的参数  1 2 3  public class UserDaoTest { List\u0026lt;User\u0026gt; userList = mapper.getUserLikeName(\u0026#34;%i%\u0026#34;); }   在sql中拼接通配符  1 2 3  \u0026lt;select id=\u0026#34;getUserLikeName\u0026#34; resultType=\u0026#34;com.wzc.pojo.User\u0026#34;\u0026gt; select * from user where name like concat(\u0026#39;%\u0026#39;, #{name}, \u0026#39;%\u0026#39;); \u0026lt;/select\u0026gt;   5、配置解析 5.1、核心配置文件  mybatis-config.xml  1 2 3 4 5 6 7 8 9 10 11 12 13  configuration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器）   5.2、环境配置（environments） Mybatis可以配置成适应多种环境，但是尽管可以配置多种环境，每个SqlSessionFactory实例只能选择一种环境\nMybatis默认的事务管理器就是JDBC\n5.3、属性（properties） 属性可以外部配置和动态替换，既可以在java属性文件中配置，也可以使用properties子元素指定\n编写配置文件db.properties\n1 2 3 4  driver=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/mybatis?userSSL=true\u0026amp;useUnicode=true\u0026amp;characterEncoding=utf-8\u0026amp;serverTimezone=GMT%2B8 #username=root #password=123456   在核心配置文件中引入\n1 2 3 4 5 6 7 8  \u0026lt;configuration\u0026gt; \u0026lt;!--引入外部配置文件--\u0026gt; \u0026lt;properties resource=\u0026#34;db.properties\u0026#34;\u0026gt; \u0026lt;!--优先读取property属性指定的配置，然后才读取外部配置文件覆盖同名属性--\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;123456\u0026#34;/\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/configuration\u0026gt;   优先读取property标签中的属性，然后读取外部配置文件中的属性并覆盖同名的属性\n5.4、类型别名（typeAliases）  类型别名是为java类型设置一个短的名字 存在的意义仅在于用来减少类完全限定名的冗余  1 2 3  \u0026lt;typeAliases\u0026gt; \u0026lt;typeAlias type=\u0026#34;com.wzc.pojo.User\u0026#34; alias=\u0026#34;User\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt;   也可以指定一个包名，Mybatis会在包名下面搜索需要的java bean，默认的别名为类名\n1 2 3 4  \u0026lt;typeAliases\u0026gt; \u0026lt;!--\u0026lt;typeAlias type=\u0026#34;com.wzc.pojo.User\u0026#34; alias=\u0026#34;User\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;package name=\u0026#34;com.wzc.pojo\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt;   5.5、设置（settings）  logImpl：指定Mybatis所用日志 cacheEnabled：全局开启或关闭缓存 lazyLoadingEnabled：全局懒加载开关  6、其他配置  typeHandler（类型处理器） objectFactory（类型工厂） plugins（插件）  mybatis-generator-core mybatis-plus 通用mapper    7、映射器（mappers） MapperRegistry：注册绑定Mapper文件\n方法一：【推荐使用】\n1 2 3 4  \u0026lt;!--每一个mapper.xml都需要在mybatis配置文件中注册--\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;com/wzc/mapper/UserMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt;   方法二：使用class文件绑定注册\n1 2 3  \u0026lt;mappers\u0026gt; \u0026lt;mapper class=\u0026#34;com.wzc.mapper.UserMapper\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt;   注意点：\n 接口和Mapper配置文件必须同名 接口和Mapper配置文件必须在同一个包下  方法三：使用扫描包进行注入\n注意点和方法二一样\n1 2 3  \u0026lt;mappers\u0026gt; \u0026lt;package name=\u0026#34;com.wzc.mapper\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt;   8、生命周期和作用域 生命周期和作用域是重要的，因为错误的使用会导致严重的并发问题\nSqlSessionFactoryBuilder：\n 一旦创建了SqlSessionFactory，就不再需要SqlSessionFactoryBuilder 局部变量  SqlSessionFactory：\n 可以理解为数据库连接池 一旦创建就应该在程序运行期间一直存在， 没有理由丢弃或重新创建一个实例（单例模式或静态单例模式实现） SqlSessionFactory的最佳作用域是应用作用域  SqlSession：\n 可以理解为连接池的一个请求 SqlSession实例不是线程安全的，所以不能被共享，最佳作用域是请求或方法作用域 用完之后需要关闭，释放资源  9、resultMap 结果集映射，解决数据库字段名与实体类属性名称不一致的问题\n1 2 3 4 5 6  \u0026lt;resultMap id=\u0026#34;UserMap\u0026#34; type=\u0026#34;User\u0026#34;\u0026gt; \u0026lt;!--column：数据库中的字段，property：实体类中的属性--\u0026gt; \u0026lt;result column=\u0026#34;id\u0026#34; property=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;name\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;pwd\u0026#34; property=\u0026#34;password\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt;   10、日志 10.1、日志工厂 Mybatis的settings中提供了日志配置的设置logImpl 支持的选项有：\n SLF4J LOG4J【掌握】 LOG4J2 JDK_LOGGING COMMONS_LOGGING STDOUT_LOGGING【掌握】 NO_LOGGING  STDOUT_LOGGING标准日志输出：\n1 2 3  \u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026#34;logImpl\u0026#34; value=\u0026#34;STDOUT_LOGGING\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt;   6.2、Log4j  先导入log4j的包  1 2 3 4 5  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.logging.log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.17.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   log4j.properties  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  # 将等级为DEBUG的日志输出到console和file这两个目的地 log4j.rootLogger=DEBUG,console # ,file # 控制台输出相关设置 log4j.appender.console=org.apache.log4j.ConsoleAppender log4j.appender.console.Target=System.out log4j.appender.console.Threshold=DEBUG log4j.appender.console.layout=org.apache.log4j.PatternLayout log4j.appender.console.layout.ConversionPattern=[%c]-%m%n # 文件输出相关设置 # log4j.appender.file=org.apache.log4j.RollingFileAppender # log4j.appender.file.File=输出文件路径 # log4j.appender.file.MaxFileSize=最大文件大小 # log4j.appender.file.Threshold=DEBUG # log4j.appender.console.layout=org.apache.log4j.PatternLayout # log4j.appender.console.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n # 日志输出级别 log4j.logger.org.mybatis=DEBUG log4j.logger.java.sql=DEBUG log4j.logger.java.sql.Statement=DEBUG log4j.logger.java.sql.ResultSet=DEBUG log4j.logger.java.sql.PreparedStatement=DEBUG   配置log4j日志实现  1 2 3  \u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026#34;logImpl\u0026#34; value=\u0026#34;LOG4J\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt;   简单使用\n 导入org.apache.log4j.Logger 获取日志对象  1  static Logger logger = Logger.getLogger(UserMapperTest.class);   日志级别  1 2 3  logger.info(\u0026#34;info: 进入了test2\u0026#34;); logger.debug(\u0026#34;debug: 进入了test2\u0026#34;); logger.error(\u0026#34;error: 进入了test2\u0026#34;);   7、分页 7.1、使用limit分页 1  select*fromuserlimitstartIndex,pageSize;  使用Mybatis实现分页，核心为sql\n 接口  1  List\u0026lt;User\u0026gt; userPage(Map\u0026lt;String, Integer\u0026gt; condition);   Mapper.xml  1 2 3  \u0026lt;select id=\u0026#34;userPage\u0026#34; parameterType=\u0026#34;map\u0026#34; resultMap=\u0026#34;UserMap\u0026#34;\u0026gt; select * from user limit #{startIndex}, #{pageSize}; \u0026lt;/select\u0026gt;   测试  1 2 3 4 5 6 7 8 9 10 11 12 13  @Test public void userPageTest() { try (SqlSession sqlSession = MybatisUtil.getSqlSession()) { UserMapper mapper = sqlSession.getMapper(UserMapper.class); Map\u0026lt;String, Integer\u0026gt; condition = new HashMap\u0026lt;\u0026gt;(); condition.put(\u0026#34;startIndex\u0026#34;, 1); condition.put(\u0026#34;pageSize\u0026#34;, 2); List\u0026lt;User\u0026gt; userList = mapper.userPage(condition); for (User user : userList) { System.out.println(user); } } }   7.2、RowBounds分页【不推荐使用】  接口  1  List\u0026lt;User\u0026gt; userRowBounds();   mapper.xml  1 2 3  \u0026lt;select id=\u0026#34;userRowBounds\u0026#34; resultMap=\u0026#34;UserMap\u0026#34;\u0026gt; select * from user; \u0026lt;/select\u0026gt;   测试  1 2 3 4 5 6 7 8 9  @Test public void userRowBoundsTest() { try (SqlSession sqlSession = MybatisUtil.getSqlSession()) { List\u0026lt;User\u0026gt; userList = sqlSession.selectList(\u0026#34;com.wzc.mapper.UserMapper.userRowBounds\u0026#34;, null, new RowBounds(1, 2)); for (User user : userList) { System.out.println(user); } } }   7.3、分页插件 pageHelper：https://pagehelper.github.io/docs/howtouse/\n8、使用注解开发  接口  1 2 3 4  public interface UserMapper { @Select(\u0026#34;select * from user\u0026#34;) List\u0026lt;User\u0026gt; userList(); }   配置文件中绑定接口  1 2 3  \u0026lt;mappers\u0026gt; \u0026lt;mapper class=\u0026#34;com.wzc.mapper.UserMapper\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt;   Mybatis实现流程\n8.1、注解CRUD 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public interface UserMapper { @Select(\u0026#34;select * from user\u0026#34;) List\u0026lt;User\u0026gt; userList(); //方法存在多个参数时，所有参数前面必须加上@Param注解  @Select(\u0026#34;select id, name, pwd as password from user where id = #{id}\u0026#34;) User getUserById(@Param(\u0026#34;id\u0026#34;) int id); @Insert(\u0026#34;insert into user(id, name, pwd) values(#{id}, #{name}, #{password})\u0026#34;) int addUser(User user); @Update(\u0026#34;update user set name = #{name}, pwd = #{password} where id = #{id}\u0026#34;) int updateUser(User user); @Delete(\u0026#34;delete from user where id = #{id}\u0026#34;) int deleteUser(@Param(\u0026#34;id\u0026#34;) int id); }   【注意：必须将接口绑定到配置文件中】\n关于@Param注解\n 基本类型或String类型需要添加@Param注解，引用类型不需要添加  9、Lombok  安装插件 导入jar包  1 2 3 4 5 6  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.22\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt;   在实体类上加注解  10、多对一处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  CREATETABLE`teacher`(`id`INT(10)NOTNULL,`name`VARCHAR(30)DEFAULTNULL,PRIMARYKEY(`id`))ENGINE=INNODBDEFAULTCHARSET=utf8;INSERTINTO`teacher`(`id`,`name`)VALUES(1,\u0026#39;张老师\u0026#39;);CREATETABLE`student`(`id`INT(10)NOTNULL,`name`varchar(30)DEFAULTNULL,`tid`INT(10)DEFAULTNULL,PRIMARYKEY(`id`),KEY`fktid`(`tid`),CONSTRAINT`fktid`FOREIGNKEY(`tid`)REFERENCES`teacher`(`id`))ENGINE=INNODBDEFAULTCHARSET=utf8;INSERTINTO`student`(`id`,`name`,`tid`)VALUES(1,\u0026#39;小明\u0026#39;,1);INSERTINTO`student`(`id`,`name`,`tid`)VALUES(2,\u0026#39;小李\u0026#39;,1);INSERTINTO`student`(`id`,`name`,`tid`)VALUES(3,\u0026#39;小赵\u0026#39;,1);INSERTINTO`student`(`id`,`name`,`tid`)VALUES(4,\u0026#39;小王\u0026#39;,1);  10.1、按照查询嵌套处理（子查询） 1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026lt;mapper namespace=\u0026#34;com.wzc.mapper.StudentMapper\u0026#34;\u0026gt; \u0026lt;resultMap id=\u0026#34;studentTeacher\u0026#34; type=\u0026#34;Student\u0026#34;\u0026gt; \u0026lt;result property=\u0026#34;id\u0026#34; column=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;name\u0026#34; column=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;!--对象：association，集合：collection--\u0026gt; \u0026lt;association property=\u0026#34;teacher\u0026#34; column=\u0026#34;tid\u0026#34; javaType=\u0026#34;Teacher\u0026#34; select=\u0026#34;selectTeacher\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;studentList\u0026#34; resultMap=\u0026#34;studentTeacher\u0026#34;\u0026gt; select * from student \u0026lt;/select\u0026gt; \u0026lt;select id=\u0026#34;selectTeacher\u0026#34; resultType=\u0026#34;Teacher\u0026#34;\u0026gt; select * from teacher where id = #{tid} \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt;   10.2、按照结果嵌套处理（联表查询） 1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;mapper\u0026gt; \u0026lt;resultMap id=\u0026#34;studentTeacher\u0026#34; type=\u0026#34;Student\u0026#34;\u0026gt; \u0026lt;result property=\u0026#34;id\u0026#34; column=\u0026#34;sid\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;name\u0026#34; column=\u0026#34;sname\u0026#34;/\u0026gt; \u0026lt;association property=\u0026#34;teacher\u0026#34; javaType=\u0026#34;Teacher\u0026#34;\u0026gt; \u0026lt;result property=\u0026#34;id\u0026#34; column=\u0026#34;tid\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;name\u0026#34; column=\u0026#34;tname\u0026#34;/\u0026gt; \u0026lt;/association\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;studentList\u0026#34; resultMap=\u0026#34;studentTeacher\u0026#34;\u0026gt; select s.id sid, s.name sname, t.id tid, t.name tname from student s left join teacher t on t.id = s.tid \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt;   11、一对多处理 一个老师教多个学生\n11.1、按结果嵌套（联表查询） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;mapper namespace=\u0026#34;com.wzc.mapper.TeacherMapper\u0026#34;\u0026gt; \u0026lt;!--按结果嵌套--\u0026gt; \u0026lt;resultMap id=\u0026#34;teacherStudent\u0026#34; type=\u0026#34;Teacher\u0026#34;\u0026gt; \u0026lt;result property=\u0026#34;id\u0026#34; column=\u0026#34;tid\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;name\u0026#34; column=\u0026#34;tname\u0026#34;/\u0026gt; \u0026lt;collection property=\u0026#34;students\u0026#34; ofType=\u0026#34;Student\u0026#34;\u0026gt; \u0026lt;result property=\u0026#34;id\u0026#34; column=\u0026#34;sid\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;name\u0026#34; column=\u0026#34;sname\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;tid\u0026#34; column=\u0026#34;stid\u0026#34;/\u0026gt; \u0026lt;/collection\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;getTeacher\u0026#34; resultMap=\u0026#34;teacherStudent\u0026#34;\u0026gt; select t.id tid, t.name tname, s.id sid, s.name sname, s.tid stid from teacher t left join student s on t.id = s.tid where t.id = #{id} \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt;   11.2、按查询嵌套 1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;mapper\u0026gt; \u0026lt;resultMap id=\u0026#34;teacherStudent\u0026#34; type=\u0026#34;Teacher\u0026#34;\u0026gt; \u0026lt;result property=\u0026#34;id\u0026#34; column=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;name\u0026#34; column=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;collection property=\u0026#34;students\u0026#34; column=\u0026#34;id\u0026#34; javaType=\u0026#34;ArrayList\u0026#34; ofType=\u0026#34;Student\u0026#34; select=\u0026#34;studentList\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;getTeacher\u0026#34; resultMap=\u0026#34;teacherStudent\u0026#34;\u0026gt; select * from teacher where id = #{id} \u0026lt;/select\u0026gt; \u0026lt;select id=\u0026#34;studentList\u0026#34; resultType=\u0026#34;Student\u0026#34;\u0026gt; select * from student where tid = #{id} \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt;   11.3、小结  关联-association【多对一】 集合-collection【一对多】 javaType：用来指定实体类中属性的类型 ofType：用来指定泛型的类型 注意点：  保证sql的可读性 多对一和一对多中，属性名和字段的问题    12、动态SQL 动态SQL就是根据不同的条件生成不同的SQL语句\n1 2 3 4 5 6 7  CREATETABLE`blog`(`id`bigintNOTNULLCOMMENT\u0026#39;博客id\u0026#39;,`title`varchar(100)NOTNULLCOMMENT\u0026#39;博客标题\u0026#39;,`author`varchar(30)NOTNULLCOMMENT\u0026#39;博客作者\u0026#39;,`create_time`datetimeNOTNULLCOMMENT\u0026#39;创建时间\u0026#39;,`views`intNOTNULLCOMMENT\u0026#39;浏览量\u0026#39;)ENGINE=InnoDBDEFAULTCHARSET=utf8;  实体类\n1 2 3 4 5 6 7 8  @Data public class Blog { private int id; private String title; private String author; private Date createTime; private int views; }   12.1、IF标签 1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;select id=\u0026#34;blogListByIf\u0026#34; parameterType=\u0026#34;Map\u0026#34; resultType=\u0026#34;Blog\u0026#34;\u0026gt; select * from blog \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;title != null\u0026#34;\u0026gt; and title like concat(\u0026#34;%\u0026#34;, #{title}, \u0026#34;%\u0026#34;) \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;author != null\u0026#34;\u0026gt; /*从第二个if开始必须要加and*/ and author like concat(\u0026#34;%\u0026#34;, #{author}, \u0026#34;%\u0026#34;) \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt;   12.2、choose（when, otherwise） 类似switch-case\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;select id=\u0026#34;blogListByChoose\u0026#34; parameterType=\u0026#34;Map\u0026#34; resultType=\u0026#34;Blog\u0026#34;\u0026gt; select * from blog \u0026lt;where\u0026gt; \u0026lt;choose\u0026gt; \u0026lt;when test=\u0026#34;title != null\u0026#34;\u0026gt; /*当一个choose前还有choose标签的时候第一个条件也要加and*/ and title like concat(\u0026#34;%\u0026#34;, #{title}, \u0026#34;%\u0026#34;) \u0026lt;/when\u0026gt; \u0026lt;when test=\u0026#34;author != null\u0026#34;\u0026gt; and author like concat(\u0026#34;%\u0026#34;, #{author}, \u0026#34;%\u0026#34;) \u0026lt;/when\u0026gt; \u0026lt;otherwise\u0026gt; /*前面都不执行时会执行otherwise*/ and views \u0026gt;= 1000 \u0026lt;/otherwise\u0026gt; \u0026lt;/choose\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt;   12.3、trim（where, set） 1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;update id=\u0026#34;updateBlog\u0026#34; parameterType=\u0026#34;Blog\u0026#34;\u0026gt; update blog \u0026lt;set\u0026gt; \u0026lt;if test=\u0026#34;title != null\u0026#34;\u0026gt; title = #{title}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;author != null\u0026#34;\u0026gt; author = #{author}, \u0026lt;/if\u0026gt; \u0026lt;/set\u0026gt; where id = #{id} \u0026lt;/update\u0026gt;   SQL片段\n 使用sql标签抽取公共的sql  1 2 3 4 5 6 7 8 9  \u0026lt;sql id=\u0026#34;ifSql\u0026#34;\u0026gt; \u0026lt;if test=\u0026#34;title != null\u0026#34;\u0026gt; and title like concat(\u0026#34;%\u0026#34;, #{title}, \u0026#34;%\u0026#34;) \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;author != null\u0026#34;\u0026gt; /*从第二个if开始必须要加and*/ and author like concat(\u0026#34;%\u0026#34;, #{author}, \u0026#34;%\u0026#34;) \u0026lt;/if\u0026gt; \u0026lt;/sql\u0026gt;   在需要的地方使用include引用  1 2 3 4 5 6  \u0026lt;select id=\u0026#34;blogListByIf\u0026#34; parameterType=\u0026#34;Map\u0026#34; resultType=\u0026#34;Blog\u0026#34;\u0026gt; select * from blog \u0026lt;where\u0026gt; \u0026lt;include refid=\u0026#34;ifSql\u0026#34;\u0026gt;\u0026lt;/include\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt;   注意点：\n 最好基于单表定义sql片段 不要存在where标签  12.4、foreach collection：要遍历集合的参数名 item：遍历项 open：起始追加 close：结尾追加 separate：分隔符\n1 2 3 4 5 6  \u0026lt;select id=\u0026#34;blogListByForeach\u0026#34; parameterType=\u0026#34;List\u0026#34; resultType=\u0026#34;Blog\u0026#34;\u0026gt; select * from blog where \u0026lt;foreach collection=\u0026#34;ids\u0026#34; item=\u0026#34;id\u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34; separator=\u0026#34;or\u0026#34;\u0026gt; id = #{id} \u0026lt;/foreach\u0026gt; \u0026lt;/select\u0026gt;   13、Mybatis缓存  Mybatis系统中定义了两级缓存：一级和二级缓存 默认情况下，只有一级缓存开启（sqlSession级别的缓存，也称为本地缓存） 二级缓存需要配置开启，也可以通过实现Cache接口实现（namespace级别的缓存，也称为全局缓存）  13.1、一级缓存 1 2 3 4 5 6 7 8 9 10 11 12 13 14  public class UserMapperTest { @Test public void test1() { try (SqlSession sqlSession = MybatisUtil.getSqlSession()) { /*一级缓存：sqlSession级别，第二次查询时从缓存中取结果，两次查询的结果相同*/ UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user1 = mapper.getUserById(1); User user2 = mapper.getUserById(1); System.out.println(user1); System.out.println(user2); System.out.println(user1 == user2); } } }   缓存失效情况：\n 增删改操作，可能会改变数据，所以会刷新缓存 查询不同的sql 查询不同的mapper 手动清除缓存（sqlSession.clearCache()）  小结：一级缓存是默认开启的，只在一次sqlSession中有效\n13.2、二级缓存 二级缓存工作机制：\n 当一次会话关闭后，一级缓存中的数据会被保存到二级缓存中，新会话从二级缓存中获取数据 不同的mapper对应不同的二级缓存  使用步骤：\n 开启二级缓存（默认就是开启的）  1 2  \u0026lt;!--开启二级缓存--\u0026gt; \u0026lt;setting name=\u0026#34;cacheEnabled\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt;   mapper.xml中添加cache标签  1 2  \u0026lt;!--在当前mapper中使用二级缓存，FIFO策略，每60秒刷新缓存，缓存空间大小512，只读--\u0026gt; \u0026lt;cache eviction=\u0026#34;FIFO\u0026#34; flushInterval=\u0026#34;60000\u0026#34; size=\u0026#34;512\u0026#34; readOnly=\u0026#34;true\u0026#34;/\u0026gt;   测试  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public class UserMapperTest { @Test public void test2() { try (SqlSession sqlSession1 = MybatisUtil.getSqlSession(); SqlSession sqlSession2 = MybatisUtil.getSqlSession()) { UserMapper mapper1 = sqlSession1.getMapper(UserMapper.class); UserMapper mapper2 = sqlSession2.getMapper(UserMapper.class); User user1 = mapper1.getUserById(1); System.out.println(user1); sqlSession1.close(); /*一级缓存关闭后，其中的数据会保存到二级缓存，再次查询从二级缓存中获取数据*/ User user2 = mapper2.getUserById(1); System.out.println(user2); System.out.println(user1 == user2); } } }   注意： 实体类需要实现Serializable接口序列化，否则会报NotSerializableException\n13.3、缓存原理  先看二级缓存中有没有 再看一级缓存中有没有 查询数据库   13.6、自定义缓存ehcache Ehcache是一种广泛使用的开源java分布式缓存，主要面向通用缓存\n 导包  1 2 3 4 5  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.caches\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-ehcache\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   配置文件指定使用ehcache  1  \u0026lt;cache type=\u0026#34;org.mybatis.caches.ehcache.EhcacheCache\u0026#34;/\u0026gt;   编写ehcache的配置文件  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;ehcache xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:noNamespaceSchemaLocation=\u0026#34;http://ehcache.org/ehcache.xsd\u0026#34; updateCheck=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;diskStore path=\u0026#34;./tmpdir/Tmp_EhCache\u0026#34;/\u0026gt; \u0026lt;defaultCache eternal=\u0026#34;false\u0026#34; maxElementsInMemory=\u0026#34;10000\u0026#34; overflowToDisk=\u0026#34;false\u0026#34; diskPersistent=\u0026#34;false\u0026#34; timeToIdleSeconds=\u0026#34;1800\u0026#34; timeToLiveSeconds=\u0026#34;259200\u0026#34; memoryStoreEvictionPolicy=\u0026#34;LRU\u0026#34;/\u0026gt; \u0026lt;cache name=\u0026#34;cloud_user\u0026#34; eternal=\u0026#34;false\u0026#34; maxElementsInMemory=\u0026#34;5000\u0026#34; overflowToDisk=\u0026#34;false\u0026#34; diskPersistent=\u0026#34;false\u0026#34; timeToIdleSeconds=\u0026#34;1800\u0026#34; timeToLiveSeconds=\u0026#34;1800\u0026#34; memoryStoreEvictionPolicy=\u0026#34;LRU\u0026#34;/\u0026gt; \u0026lt;/ehcache\u0026gt;   ","date":"2022-03-07T18:24:52+08:00","image":"https://WangZichen99.github.io/img/2022/03/lake.jpg","permalink":"https://WangZichen99.github.io/p/mybatisnote/","title":"Mybatis笔记"},{"content":"Spring学习笔记 1、介绍 1.1、导包 导入spring-webmvc和spring-jdbc\n1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;project\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.0.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.0.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/project\u0026gt;   1.2、优点   开源免费\n  轻量级、非入侵式\n  控制反转（IOC）、面向切面编程（AOP）\n  支持事务处理，对框架整合的支持\n  总结：Spring就是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架\n1.3、组成 1.4、拓展 在Spring官网有这个介绍：现代化的java开发，就是基于Spring的开发\nSpring Boot：Build Anything\nSpring Cloud：Coordinate Anything\nSpring Cloud Data Flow：Connect Everything\n  Spring Boot\n 一个快速开发的脚手架 基于Spring Boot可以快速的开发单个微服务 约定大于配置    Spring Cloud\n Spring Cloud是基于Spring Boot实现的    弊端：发展了太久之后就违背了原来的理念，配置十分繁琐\n2、IOC理论推导   UserDao接口\n  UserDaoImpl实现类\n  UserService业务接口\n  UserServiceImpl业务实现类\n  在之前的业务中，用户的需求可能会影响原来的代码，需要根据需求修改源代码，如果代码量十分大，修改一次的成本十分昂贵\n使用一个Set接口实现，已经发生了革命性的变化\n1 2 3 4 5 6  private UserDao userDao; //利用set进行动态实现值的注入 public void setUserDao(UserDao userDao) { this.userDao = userDao; }    之前，程序是主动创建对象，控制权在程序员手上 使用了set注入后，程序不再具有主动性，而是变成了被动的接收对象  这种思想，从本质上解决了问题，程序员不再管理对象的创建，系统的耦合性大大降低，可以更加专注于业务的实现，这是IOC的原型\nIoC本质 控制反转IoC（Inversion of Control），是一种设计思想，DI（依赖注入）是实现IoC的一种方法。\n没有IoC的程序中，我们使用面向对象编程，对象的创建与对象间的依赖关系完全硬编程在程序中，对象的创建由程序自己控制 控制反转后将对象的创建转移给第三方，获得依赖对象的方式反转了。\n控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器， 其实现方法是依赖注入（Dependency Injection，DI）\n3、Hello Spring  控制：谁来控制对象的创建，传统应用程序的对象是由程序本身控制创建的，使用Spring后，对象是由Spring创建的 反转：程序本身不创建对象，而变成被动的接收对象 依赖注入：就是利用set方法来进行注入的 IoC是一种编程思想，由主动的编程变成被动的接收  4、IoC创建对象的方式  使用无参构造创建对象（默认） 如果要使用有参构造创建对象  下标赋值  1 2 3  \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.wzc.pojo.User\u0026#34;\u0026gt; \u0026lt;constructor-arg index=\u0026#34;0\u0026#34; value=\u0026#34;wzc\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   类型（不建议使用）  1 2 3  \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.wzc.pojo.User\u0026#34;\u0026gt; \u0026lt;constructor-arg type=\u0026#34;java.lang.String\u0026#34; value=\u0026#34;wzc\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   参数名  1 2 3  \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.wzc.pojo.User\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;name\u0026#34; value=\u0026#34;wzc\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;     总结：在配置文件加载的时候，容器中管理的对象已经初始化了\n5、Spring配置 5.1、别名 1 2  \u0026lt;!--别名，可以通过别名获取对象--\u0026gt; \u0026lt;alias name=\u0026#34;user\u0026#34; alias=\u0026#34;userNew\u0026#34;/\u0026gt;   5.2、Bean的配置 1 2 3 4  \u0026lt;!--有参构造对象，name也可以取别名，可以取多个--\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.wzc.pojo.User\u0026#34; name=\u0026#34;user2, u2\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;name\u0026#34; value=\u0026#34;wzc\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   5.3、Import import一般用于团队开发，可以将多个配置文件，导入合并为一个\n如果项目中有多人开发，三个人使用不同的类开发，不同的类需要注册在不同的bean中， 可以利用import将所有人的beans.xml合并为一个总的，使用的时候，直接使用总的配置就可以\n6、依赖注入 6.1、构造器注入 前面已经说过\n6.2、Set方法注入【重点】  依赖注入：Set方法注入  依赖：bean对象的创建依赖于容器 注入：bean对象中的所有属性，由容器来注入 name属性值与类中的成员变量名以及set方法的参数名都无关, 只与对应的set方法名有关 如果通过set方法注入属性，那么Spring会通过默认的空参构造方法来实例化对象， 所以如果在类中写了一个带有参数的构造方法，一定要把空参数的构造方法写上， 否则spring没有办法实例化对象，导致报错。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  \u0026lt;bean id=\u0026#34;address\u0026#34; class=\u0026#34;com.wzc.pojo.Address\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;address\u0026#34; value=\u0026#34;北京\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;student\u0026#34; class=\u0026#34;com.wzc.pojo.Student\u0026#34;\u0026gt; \u0026lt;!--普通值注入: Spring会将name值的每个单词首字母转换成大写, 然后再在前面拼接上\u0026#34;set\u0026#34;构成一个方法名, 然后去对应的类中查找该方法,通过反射调用,实现注入--\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;wzc\u0026#34;/\u0026gt; \u0026lt;!--Bean注入--\u0026gt; \u0026lt;property name=\u0026#34;address\u0026#34; ref=\u0026#34;address\u0026#34;/\u0026gt; \u0026lt;!--数组注入--\u0026gt; \u0026lt;property name=\u0026#34;books\u0026#34;\u0026gt; \u0026lt;array\u0026gt; \u0026lt;value\u0026gt;活着\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;平凡的世界\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;你当像鸟飞往你的山\u0026lt;/value\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--List注入--\u0026gt; \u0026lt;property name=\u0026#34;hobbies\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;看书\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;打篮球\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;听音乐\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--Map注入--\u0026gt; \u0026lt;property name=\u0026#34;cards\u0026#34;\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry key=\u0026#34;身份证\u0026#34; value=\u0026#34;110154158754582057\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;银行卡\u0026#34; value=\u0026#34;1111 2222 3333 4444\u0026#34;/\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--Set注入--\u0026gt; \u0026lt;property name=\u0026#34;games\u0026#34;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;value\u0026gt;穿越火线\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;NBA2KOL2\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;QQ飞车\u0026lt;/value\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--null值注入--\u0026gt; \u0026lt;property name=\u0026#34;wife\u0026#34;\u0026gt; \u0026lt;null/\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--Properties注入--\u0026gt; \u0026lt;property name=\u0026#34;info\u0026#34;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;prop key=\u0026#34;学号\u0026#34;\u0026gt;1725840658\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;性别\u0026#34;\u0026gt;男\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;邮箱\u0026#34;\u0026gt;194829422@qq.com\u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;     6.3、拓展方式注入 使用p命名和c命名空间注入\n 导入xml约束  1 2  xmlns:p=\u0026#34;http://www.springframework.org/schema/p\u0026#34; xmlns:c=\u0026#34;http://www.springframework.org/schema/c\u0026#34;   注入  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:p=\u0026#34;http://www.springframework.org/schema/p\u0026#34; xmlns:c=\u0026#34;http://www.springframework.org/schema/c\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!--p命名空间注入（无参构造，set方法注入），可以直接注入属性的值--\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.wzc.pojo.User\u0026#34; p:name=\u0026#34;wzc\u0026#34; p:age=\u0026#34;22\u0026#34;/\u0026gt; \u0026lt;!--c命名空间注入（有参构造）--\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.wzc.pojo.User\u0026#34; c:name=\u0026#34;wzc\u0026#34; c:age=\u0026#34;22\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt;   测试  1 2 3 4 5 6 7  public class UserTest { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;userbeans.xml\u0026#34;); User user = context.getBean(\u0026#34;user\u0026#34;, User.class); System.out.println(user.toString()); } }   6.4、Bean的作用域  单例模式（Spring默认机制）  1  \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.wzc.pojo.User\u0026#34; c:name=\u0026#34;wzc\u0026#34; c:age=\u0026#34;22\u0026#34; scope=\u0026#34;singleton\u0026#34;/\u0026gt;   原型模式：每次从容器中get的时候都会产生一个新对象  1  \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.wzc.pojo.User\u0026#34; c:name=\u0026#34;wzc\u0026#34; c:age=\u0026#34;22\u0026#34; scope=\u0026#34;prototype\u0026#34;/\u0026gt;   其余的request、session、application这些只能在web开发中使用到  7、Bean的自动装配  自动装配是Spring满足bean依赖的一种方式 Spring会在上下文中自动寻找，并装配属性  在Spring中有三种装配方式\n 在xml中显示装配 在java中显示装配 隐式的自动装配【重要】  7.1、byName自动装配 1 2 3 4 5 6 7  \u0026lt;bean id=\u0026#34;dog\u0026#34; class=\u0026#34;com.wzc.pojo.Dog\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;cat\u0026#34; class=\u0026#34;com.wzc.pojo.Cat\u0026#34;/\u0026gt; \u0026lt;!--byName会自动在容器上下文中查找bean的id前加上\u0026#34;set\u0026#34;和对应属性的set方法名称相同的bean进行自动注入--\u0026gt; \u0026lt;bean id=\u0026#34;person\u0026#34; class=\u0026#34;com.wzc.pojo.Person\u0026#34; autowire=\u0026#34;byName\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;wzc\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   7.2、byType自动装配 1 2 3 4 5 6 7  \u0026lt;bean id=\u0026#34;dog\u0026#34; class=\u0026#34;com.wzc.pojo.Dog\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;cat\u0026#34; class=\u0026#34;com.wzc.pojo.Cat\u0026#34;/\u0026gt; \u0026lt;!--byType会自动在容器上下文中查找bean的类型和该对象属性类型相同的bean进行自动注入（必须保证全局唯一）--\u0026gt; \u0026lt;bean id=\u0026#34;person\u0026#34; class=\u0026#34;com.wzc.pojo.Person\u0026#34; autowire=\u0026#34;byType\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;wzc\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   7.3、constructor自动装配 1 2 3 4 5 6 7 8  \u0026lt;bean id=\u0026#34;dog\u0026#34; class=\u0026#34;com.wzc.pojo.Dog\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;cat\u0026#34; class=\u0026#34;com.wzc.pojo.Cat\u0026#34;/\u0026gt; \u0026lt;!--通过构造方法进行自动注入，Spring会匹配与构造方法参数类型一致的bean进行注入， 如果构造方法参数没有完全匹配则注入失败--\u0026gt; \u0026lt;bean id=\u0026#34;person\u0026#34; class=\u0026#34;com.wzc.pojo.Person\u0026#34; autowire=\u0026#34;constructor\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;wzc\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   小结：\n byName的时候，需要保证所有bean的id唯一 byType的时候，需要保证所有bean的class唯一  7.4、使用注解实现自动装配 要使用注解须知：\n 导入约束：context约束 配置注解的支持  1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;context:annotation-config/\u0026gt; \u0026lt;/beans\u0026gt;   @Autowired注解\n直接在属性上使用即可，也可以在set方法上使用\n科普：\n1 2 3 4  @Nullable 字段标记这个注解后，说明这个字段可以为null //如果定义了@Autowired的require属性为false，说明这个对象可以为空 @Autowired(require = false)   @Autowired默认使用byType方式注入，如果beans.xml中有多个type符合的bean， 则使用@Qualifier(value = \u0026ldquo;name\u0026rdquo;)注入id为name的bean\n1 2 3  @Autowired @Qualifier(value = \u0026#34;dog\u0026#34;) private Dog dog1;   @Resource注解\n1 2  @Resource(name = \u0026#34;cat1\u0026#34;) private Cat cat;   小结： @Autowired和@Resource的区别：\n @Autowired默认按照byType方式装配 @Resource默认按照byName方式装配  8、使用注解开发 在Spring4之后，要使用注解开发，必须保证aop的包导入了\n使用注解需要导入context约束，增加注解的支持\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.wzc\u0026#34;/\u0026gt; \u0026lt;context:annotation-config/\u0026gt; \u0026lt;/beans\u0026gt;     bean\n@Component：表示组件，放在类上表示这个类被Spring管理\n  属性如何注入\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  @Component //等价于\u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.wzc.pojo.User\u0026#34;/\u0026gt; public class User { @Value(\u0026#34;wzc\u0026#34;) //等价于\u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;wzc\u0026#34;/\u0026gt;  private String name; public String getName() { return name; } @Value(\u0026#34;wzc\u0026#34;) //等价于\u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;wzc\u0026#34;/\u0026gt;  public void setName(String name) { this.name = name; } }    衍生的注解\n@Component有几个衍生注解，我们在web开发中，会按照mvc三层架构分层\n dao：@Repository service：@Service controller：@Controller  这四个注解功能相同，代表将某个类注册到Spring容器中，装配bean\n  自动装配\n@Autowired\n@Resource\n  作用域\n@Scope(value = \u0026ldquo;prototype\u0026rdquo;)\n  小结\nxml与注解：\n xml更万能，适用于任何场合，维护简单方便 注解只能对当前类生效，维护相对复杂 xml一般用来管理bean，注解只负责属性的注入    9、使用java的方式配置Spring 所有配置由注解完成\n两种方法注入bean：\n @Component建立的对象通过getBean(\u0026ldquo;user\u0026rdquo;)获取 配置类中定义一个方法，使用@Bean注解声明，通过getBean(\u0026ldquo;getUser\u0026rdquo;)获取  实体类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  @Component() //第一种方法直接使用Component注解注入bean，通过getBean(\u0026#34;user\u0026#34;)来得到bean public class User { @Value(\u0026#34;wzc\u0026#34;) private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } }   配置类\n1 2 3 4 5 6 7 8 9  @Configuration //@Configuration代表这是一个配置类(第二种方法) @ComponentScan(\u0026#34;com.wzc.pojo\u0026#34;) //自动扫描com.wzc.pojo下的bean进行注入，这里注入的是user(与第一种方法配合使用) public class UserConfig { @Bean //注册一个Bean，相当于一个bean标签，这个方法的名字就是bean标签中的id，方法的返回值就是bean标签中的class，这里注入的是getUser  public User getUser() { return new User(); } }   测试类\n1 2 3 4 5 6 7 8 9 10 11 12 13  public class UserTest { @Test public void test1() { //如果使用配置类注入，使用AnnotationConfigApplicationContext来获取容器  ApplicationContext context = new AnnotationConfigApplicationContext(UserConfig.class); User user1 = context.getBean(\u0026#34;getUser\u0026#34;, User.class); User user2 = context.getBean(\u0026#34;user\u0026#34;, User.class); user1.setName(\u0026#34;test\u0026#34;); System.out.println(user1); System.out.println(user2); System.out.println(user1 == user2); //user1和user2不是同一个对象  } }   这种纯java的配置方式在SpringBoot中随处可见\n10、代理模式 代理模式是SpringAOP的底层实现\n代理模式的分类：\n 静态代理 动态代理  10.1、静态代理 角色分析：\n 抽象角色：一般会使用接口或者抽象类来解决 (租房) 真实角色：被代理的角色 (房东) 代理角色：代理真实角色，代理真实角色后，会做一些附属操作 (中介) 客户：访问代理对象 (客户)  代理模式的好处：\n 可以使真实角色的操作更加纯粹，不用关注一些公共的业务 公共业务交给代理角色，实现了业务的分工 公共业务发生扩展的时候，方便集中管理  缺点：\n 一个真实角色就会产生一个代理角色，代码量会翻倍  接口 (租房)\n1 2 3 4 5 6  //租房 public interface Rent { public void rent(); }   真实角色 (房东)\n1 2 3 4 5 6 7  public class Host implements Rent { @Override public void rent() { System.out.println(\u0026#34;房东要出租房子\u0026#34;); } }   代理角色 (中介)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  public class Proxy implements Rent { //要代理的角色  private Host host; public Proxy() { } public Proxy(Host host) { this.host = host; } @Override public void rent() { lookHouse(); host.rent(); signContract(); fee(); } /** * 看房(附属操作) */ public void lookHouse() { System.out.println(\u0026#34;中介带领看房\u0026#34;); } /** * 签合同(附属操作) */ public void signContract() { System.out.println(\u0026#34;签租赁合同\u0026#34;); } /** * 收中介费(附属操作) */ public void fee() { System.out.println(\u0026#34;收中介费\u0026#34;); } }   客户端访问代理角色\n1 2 3 4 5 6 7 8 9 10  public class Client { public static void main(String[] args) { //房东要租房子  Host host = new Host(); //代理中介帮房东租房子，代理会有一些附属操作  Proxy proxy = new Proxy(host); //找中介租房子  proxy.rent(); } }   10.2、静态代理加深理解 接口\n1 2 3 4 5 6 7 8 9  public interface UserService { public void insert(); public void delete(); public void update(); public void select(); }   真实角色\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public class UserServiceImpl implements UserService { @Override public void insert() { System.out.println(\u0026#34;增加用户\u0026#34;); } @Override public void delete() { System.out.println(\u0026#34;删除用户\u0026#34;); } @Override public void update() { System.out.println(\u0026#34;修改用户\u0026#34;); } @Override public void select() { System.out.println(\u0026#34;查询用户\u0026#34;); } }   代理角色\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  public class UserServiceProxy implements UserService { private UserServiceImpl userService; public void setUserService(UserServiceImpl userService) { this.userService = userService; } @Override public void insert() { log(\u0026#34;insert\u0026#34;); userService.insert(); } @Override public void delete() { log(\u0026#34;delete\u0026#34;); userService.delete(); } @Override public void update() { log(\u0026#34;update\u0026#34;); userService.update(); } @Override public void select() { log(\u0026#34;select\u0026#34;); userService.select(); } //日志输出(附属方法)  public void log(String msg) { System.out.println(\u0026#34;使用了\u0026#34; + msg + \u0026#34;方法\u0026#34;); } }   客户端\n1 2 3 4 5 6 7 8 9 10 11 12  public class Client { public static void main(String[] args) { //真实角色  UserServiceImpl userService = new UserServiceImpl(); //代理角色(添加日至输出)  UserServiceProxy userServiceProxy = new UserServiceProxy(); userServiceProxy.setUserService(userService); userServiceProxy.insert(); } }   10.3、动态代理  动态代理和静态代理角色一样 动态代理的代理类是自动生成的(通过反射)，不是直接写好的 动态代理分为两大类：基于接口的动态代理，基于类的动态代理  基于接口\u0026mdash;JDK动态代理 √ 基于类\u0026mdash;cglib java字节码实现\u0026mdash;javasist    需要了解两个类：Proxy：代理，InvocationHandler：调用处理程序\n接口\n1 2 3 4 5 6 7 8 9  public interface UserService { public void insert(); public void delete(); public void update(); public void select(); }   真实角色\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public class UserServiceImpl implements UserService { @Override public void insert() { System.out.println(\u0026#34;增加用户\u0026#34;); } @Override public void delete() { System.out.println(\u0026#34;删除用户\u0026#34;); } @Override public void update() { System.out.println(\u0026#34;修改用户\u0026#34;); } @Override public void select() { System.out.println(\u0026#34;查询用户\u0026#34;); } }   InvocationHandler动态代理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  public class ProxyInvocationHandler implements InvocationHandler { private Object target; //要代理的角色  public void setTarget(Object target) { this.target = target; } /** * 生成代理类 */ public Object getProxy() { return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(), this); } /** * 返回代理实例 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { log(method.getName()); Object result = method.invoke(target, args); return result; } /** * 附属方法：写日志 */ public void log(String msg) { System.out.println(\u0026#34;执行了\u0026#34; + msg + \u0026#34;方法\u0026#34;); } }   客户端\n1 2 3 4 5 6 7 8 9 10 11 12 13  public class Client { public static void main(String[] args) { //真实角色  UserServiceImpl userService = new UserServiceImpl(); //代理角色  ProxyInvocationHandler handler = new ProxyInvocationHandler(); //设置要代理的对象  handler.setTarget(userService); //动态生成代理类  UserService proxy = (UserService) handler.getProxy(); proxy.insert(); } }   动态代理的好处：\n 可以使真实角色的操作更加纯粹，不用关注一些公共业务 公共业务交给代理角色，实现了业务的分工 公共业务发生扩展的时候方便集中管理 一个动态代理类代理的是一个接口，一般就是对应的一类业务 一个动态代理可以代理多个类，只要是实现了同一个接口即可  11、AOP 11.1、什么是AOP AOP（Aspect Oriented Programming）意为：面向切面编程， 通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。 AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容， 是函数式编程的一种衍生范型。利用AOP业务逻辑的各个部分进行隔离， 从而使得各部分逻辑之间的耦合度降低，提高程序的可重用性，同时提高了开发效率\n11.2、AOP在Spring中的作用 提供声明事务，允许用户自定义切面\n理解： 切面：包含要切入的具体方法的类\n通知：切面中的某个具体方法\n切入点：具体在哪个类哪个方法进行切入\n11.3、使用Spring实现AOP 导包\n1 2 3 4 5 6 7  \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;   方式一：使用Spring的接口 前置通知和后置通知\n1 2 3 4 5 6 7 8 9 10 11 12 13  public class BeforeLog implements MethodBeforeAdvice { /** * 方法执行前操作 * @param method 要执行的目标对象的方法 * @param objects 方法参数 * @param o 目标对象 * @throws Throwable */ @Override public void before(Method method, Object[] objects, Object o) throws Throwable { System.out.println(o.getClass().getName() + \u0026#34;的\u0026#34; + method.getName() + \u0026#34;被执行\u0026#34;); } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14  public class AfterLog implements AfterReturningAdvice { /** * 方法执行后操作 * @param o 返回值 * @param method 要执行的目标对象方法 * @param objects 方法参数 * @param o1 目标对象 * @throws Throwable */ @Override public void afterReturning(Object o, Method method, Object[] objects, Object o1) throws Throwable { System.out.println(\u0026#34;执行了\u0026#34; + method.getName() + \u0026#34;方法，返回结果为\u0026#34; + o); } }   配置文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;com.wzc.service.UserServiceImpl\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;beforeLog\u0026#34; class=\u0026#34;com.wzc.log.BeforeLog\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;afterLog\u0026#34; class=\u0026#34;com.wzc.log.AfterLog\u0026#34;/\u0026gt; \u0026lt;!--方式一：使用原生接口配置AOP--\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;!--切入点：expression：表达式，execution(要执行的位置 包名.类名.方法名)--\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;pointcut\u0026#34; expression=\u0026#34;execution(* com.wzc.service.UserServiceImpl.*(..))\u0026#34;/\u0026gt; \u0026lt;!--执行环绕增强--\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026#34;beforeLog\u0026#34; pointcut-ref=\u0026#34;pointcut\u0026#34;/\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026#34;afterLog\u0026#34; pointcut-ref=\u0026#34;pointcut\u0026#34;/\u0026gt; \u0026lt;/aop:config\u0026gt; \u0026lt;/beans\u0026gt;   方式二：自定义类来实现AOP 自定义类\n1 2 3 4 5 6 7 8 9  public class CustomPointCut { public void beforeMethod() { System.out.println(\u0026#34;方法执行前\u0026#34;); } public void afterMethod() { System.out.println(\u0026#34;方法执行后\u0026#34;); } }   配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;com.wzc.service.UserServiceImpl\u0026#34;/\u0026gt; \u0026lt;!--方式二：自定义类--\u0026gt; \u0026lt;bean id=\u0026#34;customPointCut\u0026#34; class=\u0026#34;com.wzc.custom.CustomPointCut\u0026#34;/\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;!--自定义切面--\u0026gt; \u0026lt;aop:aspect ref=\u0026#34;customPointCut\u0026#34;\u0026gt; \u0026lt;!--切入点--\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;pointcut\u0026#34; expression=\u0026#34;execution(* com.wzc.service.UserServiceImpl.*(..))\u0026#34;/\u0026gt; \u0026lt;!--通知--\u0026gt; \u0026lt;aop:before method=\u0026#34;beforeMethod\u0026#34; pointcut-ref=\u0026#34;pointcut\u0026#34;/\u0026gt; \u0026lt;aop:after-returning method=\u0026#34;afterMethod\u0026#34; pointcut-ref=\u0026#34;pointcut\u0026#34;/\u0026gt; \u0026lt;/aop:aspect\u0026gt; \u0026lt;/aop:config\u0026gt; \u0026lt;/beans\u0026gt;   方式三：使用注解实现AOP 切面类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  /** * 通过注解实现AOP */ @Aspect //标注这个类为一个切面 public class AnnotationPointCut { @Before(\u0026#34;execution(* com.wzc.service.UserServiceImpl.*(..))\u0026#34;) public void beforeMethod() { System.out.println(\u0026#34;方法执行前\u0026#34;); } @AfterReturning(\u0026#34;execution(* com.wzc.service.UserServiceImpl.*(..))\u0026#34;) public void afterMethod() { System.out.println(\u0026#34;方法执行后\u0026#34;); } /** * 环绕增强中，可以通过ProceedingJoinPoint来获取处理切入的点 */ @Around(\u0026#34;execution(* com.wzc.service.UserServiceImpl.*(..))\u0026#34;) public void aroundMethod(ProceedingJoinPoint joinPoint) throws Throwable { System.out.println(\u0026#34;环绕前\u0026#34;); System.out.println(\u0026#34;signature：\u0026#34; + joinPoint.getSignature()); //获得签名(方法名全称)  joinPoint.proceed(); //执行方法  System.out.println(\u0026#34;环绕后\u0026#34;); } }   配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;com.wzc.service.UserServiceImpl\u0026#34;/\u0026gt; \u0026lt;!--方式三：注解实现AOP--\u0026gt; \u0026lt;bean id=\u0026#34;annotationPointCut\u0026#34; class=\u0026#34;com.wzc.custom.AnnotationPointCut\u0026#34;/\u0026gt; \u0026lt;!--开启注解支持--\u0026gt; \u0026lt;aop:aspectj-autoproxy/\u0026gt; \u0026lt;/beans\u0026gt;   12、整合Mybatis 步骤：\n 导入相关jar包  junit mybatis mysql spring相关 aop织入 mybatis-spring【new】   编写配置文件 测试  12.1、回忆Mybatis  编写实体类  1 2 3 4 5 6  @Data public class User { private int id; private String name; private String pwd; }   编写核心配置文件  mybatis-config.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;typeAliases\u0026gt; \u0026lt;package name=\u0026#34;com.wzc.pojo\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;\u0026gt;\u0026lt;/transactionManager\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mybatis?useUnicode=true\u0026amp;amp;characterEncoding=utf8\u0026amp;amp;useSSL=true\u0026amp;amp;serverTimezone=Asia/Shanghai\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;123456\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper class=\u0026#34;com.wzc.mapper.UserMapper\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt;   pom.xml\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;build\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/java\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;true\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;/build\u0026gt;   编写接口  1 2 3  public interface UserMapper { List\u0026lt;User\u0026gt; selectUser(); }   编写Mapper.xml  1 2 3 4 5 6 7 8 9 10  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.wzc.mapper.UserMapper\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;selectUser\u0026#34; resultType=\u0026#34;com.wzc.pojo.User\u0026#34;\u0026gt; select * from mybatis.user; \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt;   测试  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public class UserTest { @Test public void test1() throws IOException { String resources = \u0026#34;mybatis-config.xml\u0026#34;; InputStream in = Resources.getResourceAsStream(resources); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(in); SqlSession sqlSession = sessionFactory.openSession(true); UserMapper mapper = sqlSession.getMapper(UserMapper.class); List\u0026lt;User\u0026gt; userList = mapper.selectUser(); for (User user : userList) { System.out.println(user); } } }   12.2、整合Mybatis  编写数据源配置  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!--DataSource:使用Spring的数据源替换Mybatis的配置 c30p dbcp druid--\u0026gt; \u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DriverManagerDataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;com.mysql.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mybatis?useUnicode=true\u0026amp;amp;characterEncoding=utf8\u0026amp;amp;useSSL=true\u0026amp;amp;serverTimezone=Asia/Shanghai\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;123456\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--sqlSessionFactory--\u0026gt; \u0026lt;bean id=\u0026#34;sqlSessionFactory\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34;/\u0026gt; \u0026lt;!--绑定Mybatis配置文件--\u0026gt; \u0026lt;property name=\u0026#34;configLocation\u0026#34; value=\u0026#34;classpath:mybatis-config.xml\u0026#34;/\u0026gt; \u0026lt;!--\u0026lt;property name=\u0026#34;typeAliases\u0026#34; value=\u0026#34;com.wzc.pojo.User\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;property name=\u0026#34;mapperLocations\u0026#34; value=\u0026#34;classpath:com/wzc/mapper/*.xml\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--sqlSession--\u0026gt; \u0026lt;bean id=\u0026#34;sqlSession\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionTemplate\u0026#34;\u0026gt; \u0026lt;!--只能用构造器注入，因为没有set方法--\u0026gt; \u0026lt;constructor-arg name=\u0026#34;sqlSessionFactory\u0026#34; ref=\u0026#34;sqlSessionFactory\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;   sqlSessionFactory  1 2 3 4 5 6 7 8  \u0026lt;!--sqlSessionFactory--\u0026gt; \u0026lt;bean id=\u0026#34;sqlSessionFactory\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34;/\u0026gt; \u0026lt;!--绑定Mybatis配置文件--\u0026gt; \u0026lt;property name=\u0026#34;configLocation\u0026#34; value=\u0026#34;classpath:mybatis-config.xml\u0026#34;/\u0026gt; \u0026lt;!--\u0026lt;property name=\u0026#34;typeAliases\u0026#34; value=\u0026#34;com.wzc.pojo.User\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;property name=\u0026#34;mapperLocations\u0026#34; value=\u0026#34;classpath:com/wzc/mapper/*.xml\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   sqlSessionTemplate  1 2 3 4 5  \u0026lt;!--sqlSession--\u0026gt; \u0026lt;bean id=\u0026#34;sqlSession\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionTemplate\u0026#34;\u0026gt; \u0026lt;!--只能用构造器注入，因为没有set方法--\u0026gt; \u0026lt;constructor-arg name=\u0026#34;sqlSessionFactory\u0026#34; ref=\u0026#34;sqlSessionFactory\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   实现类，注入Spring  1 2 3 4 5 6 7 8 9 10 11 12 13 14  public class UserMapperImpl implements UserMapper { //原来所有操作都使用sqlSession来执行，现在使用sqlSessionTemplate  private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) { this.sqlSession = sqlSession; } @Override public List\u0026lt;User\u0026gt; selectUser() { return sqlSession.getMapper(UserMapper.class).selectUser(); } }   1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;import resource=\u0026#34;spring-dao.xml\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;userMapper\u0026#34; class=\u0026#34;com.wzc.mapper.UserMapperImpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;sqlSession\u0026#34; ref=\u0026#34;sqlSession\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;   测试  1 2 3 4 5 6 7 8 9 10 11  public class UserTest { @Test public void test2() throws IOException { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); UserMapperImpl userMapper = context.getBean(\u0026#34;userMapper\u0026#34;, UserMapperImpl.class); List\u0026lt;User\u0026gt; userList = userMapper.selectUser(); for (User user : userList) { System.out.println(user); } } }   13、声明式事务 13.1、回顾事务  把一组业务当成一个业务来做，要么都成功，要么都失败 事务在开发中十分重要，涉及到数据的一致性问题  事务的ACID原则：\n 原子性 一致性 隔离性  多个业务可能操作同一个资源，防止数据损坏   持久性  事务一旦提交，无论系统发生什么问题，结果都不会再被影响，被持久化的写到存储器中    13.2、Spring中的事务管理  声明式事务：AOP 编程式事务：需要在代码中进行事务的管理  mapper\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  public class UserMapperImpl implements UserMapper { //原来所有操作都使用sqlSession来执行，现在使用sqlSessionTemplate  private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) { this.sqlSession = sqlSession; } @Override public List\u0026lt;User\u0026gt; transaction() { sqlSession.getMapper(UserMapper.class).insertUser(new User(2, \u0026#34;admin\u0026#34;, \u0026#34;admin123\u0026#34;)); sqlSession.getMapper(UserMapper.class).deleteUser(2); return sqlSession.getMapper(UserMapper.class).selectUser(); } @Override public List\u0026lt;User\u0026gt; selectUser() { return sqlSession.getMapper(UserMapper.class).selectUser(); } @Override public int insertUser(User user) { return sqlSession.getMapper(UserMapper.class).insertUser(user); } @Override public int deleteUser(int id) { return sqlSession.getMapper(UserMapper.class).deleteUser(id); } }   配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xmlns:tx=\u0026#34;http://www.springframework.org/schema/tx\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd\u0026#34;\u0026gt; \u0026lt;!--DataSource:使用Spring的数据源替换Mybatis的配置 c30p dbcp druid--\u0026gt; \u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DriverManagerDataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;com.mysql.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mybatis?useUnicode=true\u0026amp;amp;characterEncoding=utf8\u0026amp;amp;useSSL=true\u0026amp;amp;serverTimezone=Asia/Shanghai\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;123456\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--sqlSessionFactory--\u0026gt; \u0026lt;bean id=\u0026#34;sqlSessionFactory\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34;/\u0026gt; \u0026lt;!--mapper文件位置--\u0026gt; \u0026lt;property name=\u0026#34;mapperLocations\u0026#34; value=\u0026#34;classpath:com/wzc/mapper/*.xml\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--sqlSession--\u0026gt; \u0026lt;bean id=\u0026#34;sqlSession\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionTemplate\u0026#34;\u0026gt; \u0026lt;!--只能用构造器注入，因为没有set方法--\u0026gt; \u0026lt;constructor-arg name=\u0026#34;sqlSessionFactory\u0026#34; ref=\u0026#34;sqlSessionFactory\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--配置声明式事务--\u0026gt; \u0026lt;bean id=\u0026#34;transactionManager\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DataSourceTransactionManager\u0026#34;\u0026gt; \u0026lt;constructor-arg ref=\u0026#34;dataSource\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--结合AOP实现事务的织入--\u0026gt; \u0026lt;!--配置事务通知--\u0026gt; \u0026lt;tx:advice id=\u0026#34;txAdvice\u0026#34; transaction-manager=\u0026#34;transactionManager\u0026#34;\u0026gt; \u0026lt;!--name: 给哪些方法配置事务，propagation: 配置事务的传播特性【new】--\u0026gt; \u0026lt;tx:attributes\u0026gt; \u0026lt;tx:method name=\u0026#34;selectUser\u0026#34; read-only=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;tx:method name=\u0026#34;insertUser\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt; \u0026lt;tx:method name=\u0026#34;updateUser\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt; \u0026lt;tx:method name=\u0026#34;deleteUser\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt; \u0026lt;tx:method name=\u0026#34;*\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt; \u0026lt;/tx:attributes\u0026gt; \u0026lt;/tx:advice\u0026gt; \u0026lt;!--配置事务切入--\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;txPrintCut\u0026#34; expression=\u0026#34;execution(* com.wzc.mapper.*.*(..))\u0026#34;/\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026#34;txAdvice\u0026#34; pointcut-ref=\u0026#34;txPrintCut\u0026#34;/\u0026gt; \u0026lt;/aop:config\u0026gt; \u0026lt;/beans\u0026gt;   测试\n1 2 3 4 5 6 7 8 9 10 11  public class UserTest { @Test public void test1() { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); UserMapper userMapper = context.getBean(\u0026#34;userMapper\u0026#34;, UserMapper.class); List\u0026lt;User\u0026gt; userList = userMapper.transaction(); for (User user : userList) { System.out.println(user); } } }   ","date":"2022-03-07T00:00:00Z","image":"https://WangZichen99.github.io/img/2022/03/trees_road.jpg","permalink":"https://WangZichen99.github.io/p/springnote/","title":"Spring笔记"},{"content":"我的第一篇博客\n","date":"2022-03-06T00:00:00Z","image":"https://WangZichen99.github.io/img/2022/03/mountain.jpg","permalink":"https://WangZichen99.github.io/p/firstblog/","title":"我的第一篇博客"}]